<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 4</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#goals"><span
            class="toc-section-number">1</span> Goals</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">2</span> Prelab</a></li>
            <li><a href="#verify-your-setup"><span
            class="toc-section-number">3</span> Verify Your
            Setup</a></li>
            <li><a href="#automation-of-the-measurement"><span
            class="toc-section-number">4</span> Automation of the
            Measurement</a>
            <ul>
            <li><a href="#running-the-beam-profiler"><span
            class="toc-section-number">4.1</span> Running the Beam
            Profiler</a>
            <ul>
            <li><a href="#basic-usage"><span
            class="toc-section-number">4.1.1</span> Basic Usage</a></li>
            <li><a href="#choosing-parameters"><span
            class="toc-section-number">4.1.2</span> Choosing
            Parameters</a></li>
            <li><a href="#output-files"><span
            class="toc-section-number">4.1.3</span> Output
            Files</a></li>
            <li><a href="#validating-the-automation"><span
            class="toc-section-number">4.1.4</span> Validating the
            Automation</a></li>
            </ul></li>
            <li><a href="#customizing-the-script-optional"><span
            class="toc-section-number">4.2</span> Customizing the Script
            (Optional)</a>
            <ul>
            <li><a href="#changing-the-daq-channel"><span
            class="toc-section-number">4.2.1</span> Changing the DAQ
            Channel</a></li>
            <li><a href="#adding-averaging"><span
            class="toc-section-number">4.2.2</span> Adding
            Averaging</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#the-experiment"><span
            class="toc-section-number">5</span> The Experiment</a>
            <ul>
            <li><a
            href="#measuring-the-beam-profile-without-any-lenses"><span
            class="toc-section-number">5.1</span> Measuring the Beam
            Profile Without Any Lenses</a>
            <ul>
            <li><a href="#tips-for-good-measurements"><span
            class="toc-section-number">5.1.1</span> Tips for Good
            Measurements</a></li>
            </ul></li>
            <li><a href="#how-does-a-lens-change-a-gaussian-beam"><span
            class="toc-section-number">5.2</span> How Does a Lens Change
            a Gaussian Beam?</a></li>
            <li><a
            href="#quantitatively-modeling-the-effect-of-a-lens"><span
            class="toc-section-number">5.3</span> Quantitatively
            Modeling the Effect of a Lens</a></li>
            <li><a
            href="#advanced-investigation-minimum-spot-size"><span
            class="toc-section-number">5.4</span> Advanced
            Investigation: Minimum Spot Size</a></li>
            </ul></li>
            <li><a
            href="#appendix-understanding-the-beam-profiler-code"><span
            class="toc-section-number">6</span> Appendix: Understanding
            the Beam Profiler Code</a>
            <ul>
            <li><a href="#the-beamprofiler-class"><span
            class="toc-section-number">6.1</span> The
            <code>BeamProfiler</code> Class</a></li>
            <li><a href="#the-main-measurement-loop"><span
            class="toc-section-number">6.2</span> The Main Measurement
            Loop</a></li>
            <li><a href="#troubleshooting"><span
            class="toc-section-number">6.3</span> Troubleshooting</a>
            <ul>
            <li><a href="#device-not-found-error"><span
            class="toc-section-number">6.3.1</span> “Device not found”
            Error</a></li>
            <li><a href="#motor-doesnt-move"><span
            class="toc-section-number">6.3.2</span> Motor Doesn’t
            Move</a></li>
            <li><a href="#voltage-reads-zero"><span
            class="toc-section-number">6.3.3</span> Voltage Reads
            Zero</a></li>
            <li><a href="#noisy-data"><span
            class="toc-section-number">6.3.4</span> Noisy Data</a></li>
            </ul></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="goals"><span
         class="header-section-number">1</span> Goals</h1>
         <p>In Week 1, we measured the profile of the laser and found it
         to be Gaussian to a good approximation. In Week 3, we derived
         the Gaussian beam model and learned how the profile changes as
         the beam propagates. This week, we will apply automation to
         more rapidly take data and test the model experimentally. Since
         you already set up and verified the motor controller in Week 2,
         we can focus on the physics.</p>
         <p>The full set of learning goals includes:</p>
         <ol type="1">
         <li><p>Automated data acquisition</p>
         <ul>
         <li>Python with Thorlabs Kinesis SDK</li>
         <li>USB DAQ (NI USB-6009) with nidaqmx</li>
         </ul></li>
         <li><p>Fitting and analysis of data in Python</p></li>
         <li><p>Using the predictive model of Gaussian laser beams from
         Week 3</p>
         <ul>
         <li>Contrast Gaussian beams with geometric optics</li>
         </ul></li>
         <li><p>Measure profiles of a Gaussian beam, and extract the
         Gaussian beam parameters</p></li>
         <li><p>Effect of a lens on Gaussian beams</p>
         <ul>
         <li>Is it still Gaussian?</li>
         <li>Does the thin lens equation apply to Gaussian beams?</li>
         <li>What limits the minimum achievable spot size?</li>
         </ul></li>
         </ol>
         <h1 data-number="2" id="prelab"><span
         class="header-section-number">2</span> Prelab</h1>
         <p>This week’s prelab focuses on preparing for automated data
         acquisition. Review the Gaussian beam theory from Week 3’s
         prelab, particularly the beam width equation:</p>
         <p><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi w_0^2}\right)^2}\text{.}\]</span></p>
         <p>You will use this model to analyze your automated
         measurements.</p>
         <h1 data-number="3" id="verify-your-setup"><span
         class="header-section-number">3</span> Verify Your Setup</h1>
         <p>In Week 2, you set up and verified the motor controller and
         DAQ. Before starting the experiments, confirm everything is
         still working:</p>
         <ol type="1">
         <li><input type="checkbox" disabled="" />
         DAQ can read voltages from the photodetector</li>
         <li><input type="checkbox" disabled="" />
         Python can connect to the motor controller (check your serial
         number: ____________)</li>
         <li><input type="checkbox" disabled="" />
         Motor moves when commanded</li>
         </ol>
         <p>If you encounter issues, refer back to the troubleshooting
         section in Week 2’s lab guide.</p>
         <h1 data-number="4" id="automation-of-the-measurement"><span
         class="header-section-number">4</span> Automation of the
         Measurement</h1>
         <p>Before we begin this week’s lab, reflect on your experience
         from Week 1 (and perhaps refer to your lab notebook entry to
         help guide your memory).</p>
         <ol type="1">
         <li>In Week 1, how long did the total process of data taking
         through analysis take to make a measurement of the beam width
         <span class="math inline">\(w\)</span>?</li>
         <li>In this lab, you may have to take 20-30 beam profiles in
         order to measure <span class="math inline">\(w_0\)</span> and
         <span class="math inline">\(z_w\)</span>. How long would this
         take with your manual method?</li>
         <li>What are the most time-consuming portions of the process?
         Which parts benefit most from automation?</li>
         </ol>
         <h2 data-number="4.1" id="running-the-beam-profiler"><span
         class="header-section-number">4.1</span> Running the Beam
         Profiler</h2>
         <p>The automation script is available at:
         <code>resources/lab-guides/gaussian-laser-beams/python/04_beam_profiler.py</code></p>
         <h3 data-number="4.1.1" id="basic-usage"><span
         class="header-section-number">4.1.1</span> Basic Usage</h3>
         <p>Navigate to the script directory and run:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> 04_beam_profiler.py</span></code></pre></div>
         <p>The script will prompt you for:</p>
         <ol type="1">
         <li><strong>Motor serial number</strong>: Found on the KST101
         display (e.g., “26004813”)</li>
         <li><strong>Step size (mm)</strong>: How far to move between
         measurements (recommend 0.05 mm)</li>
         <li><strong>Wait time (ms)</strong>: Delay after each step
         (recommend 500 ms)</li>
         <li><strong>Direction</strong>: “forward” or “backward”</li>
         </ol>
         <h3 data-number="4.1.2" id="choosing-parameters"><span
         class="header-section-number">4.1.2</span> Choosing
         Parameters</h3>
         <p><strong>Step Size</strong>: Smaller step sizes give higher
         resolution but take longer: - 0.05 mm is a good starting point
         for most beams - Use smaller steps (0.02-0.03 mm) for tightly
         focused beams - You can use larger steps (0.1 mm) for initial
         alignment</p>
         <p><strong>Wait Time</strong>: This ensures measurements are
         taken after vibrations settle: - 500 ms is usually sufficient -
         Increase if you see noisy data</p>
         <h3 data-number="4.1.3" id="output-files"><span
         class="header-section-number">4.1.3</span> Output Files</h3>
         <p>The script automatically generates two files with
         timestamps:</p>
         <ol type="1">
         <li><strong>CSV data file</strong>:
         <code>beam_profile_YYYYMMDD_HHMMSS.csv</code>
         <ul>
         <li>Two columns: Position (mm), Voltage (V)</li>
         <li>Ready for analysis with your fitting code from Week 1</li>
         </ul></li>
         <li><strong>Plot image</strong>:
         <code>beam_profile_YYYYMMDD_HHMMSS.png</code>
         <ul>
         <li>Quick visualization of the measured profile</li>
         </ul></li>
         </ol>
         <h3 data-number="4.1.4" id="validating-the-automation"><span
         class="header-section-number">4.1.4</span> Validating the
         Automation</h3>
         <ol start="4" type="1">
         <li>Test and run the automated Python program and evaluate the
         result using the same Python analysis from Week 1.</li>
         <li>Before you go on, make sure the automated acquisition and
         analysis routine gives the same result as the method you used
         in Week 1.</li>
         <li>How long does your new measurement method take? (2-3
         minutes per <span class="math inline">\(w\)</span> measurement
         is very good.)</li>
         </ol>
         <h2 data-number="4.2"
         id="customizing-the-script-optional"><span
         class="header-section-number">4.2</span> Customizing the Script
         (Optional)</h2>
         <p>If you need to modify the script behavior:</p>
         <h3 data-number="4.2.1" id="changing-the-daq-channel"><span
         class="header-section-number">4.2.1</span> Changing the DAQ
         Channel</h3>
         <p>If your photodetector is connected to a different channel
         (e.g., AI1):</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>profiler <span class="op">=</span> BeamProfiler(serial_number, daq_channel<span class="op">=</span><span class="st">&quot;ai1&quot;</span>)</span></code></pre></div>
         <h3 data-number="4.2.2" id="adding-averaging"><span
         class="header-section-number">4.2.2</span> Adding
         Averaging</h3>
         <p>For noisy signals, you can modify
         <code>read_voltage()</code> to average multiple samples:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_voltage(<span class="va">self</span>, num_samples<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Read averaged voltage from DAQ.&quot;&quot;&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>daq_device<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>daq_channel<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        voltages <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>num_samples)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.mean(voltages)</span></code></pre></div>
         <h1 data-number="5" id="the-experiment"><span
         class="header-section-number">5</span> The Experiment</h1>
         <p>The Gaussian beam model of light is useful because it often
         describes the beam of light created by lasers. This section
         will test the validity of the model for our He-Ne laser beam.
         Also, the effect of a lens on a Gaussian beam will be tested,
         and the Gaussian beam model will be compared with predictions
         from the simpler ray theory. Lastly, the Gaussian beam theory
         can be used to describe the minimum possible focus size for a
         beam and a lens.</p>
         <h2 data-number="5.1"
         id="measuring-the-beam-profile-without-any-lenses"><span
         class="header-section-number">5.1</span> Measuring the Beam
         Profile Without Any Lenses</h2>
         <p>There is a straightforward reason that a He-Ne laser should
         produce a Gaussian beam. The laser light builds up between two
         mirrors, and the electromagnetic mode that best matches the
         shape of the mirrors is the Gaussian beam.</p>
         <ol type="1">
         <li><p>Considering the Gaussian beam equations from Week 3’s
         prelab (the electric field, beam width <span
         class="math inline">\(w(z)\)</span>, radius of curvature <span
         class="math inline">\(R(z)\)</span>, and Gouy phase <span
         class="math inline">\(\zeta(z)\)</span>), which aspects of the
         Gaussian beam model can you test? Are there any parts of the
         model you cannot test?</p></li>
         <li><p>Measure the beam width <span
         class="math inline">\(w\)</span> at various distances from the
         laser. Consider carefully:</p>
         <ul>
         <li>What distance should be varying: laser to razor, razor to
         photodetector, or laser to photodetector?</li>
         <li>How did you decide what positions <span
         class="math inline">\(z\)</span> to measure the width at?</li>
         <li>Use meter sticks and other measurement tools available in
         the lab.</li>
         </ul></li>
         <li><p>Fit the data to <span
         class="math inline">\(w(z)\)</span>, the predicted expression
         for a Gaussian beam: <span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi w_0^2}\right)^2}\]</span></p></li>
         <li><p>What is the value of the beam waist <span
         class="math inline">\(w_0\)</span> (including uncertainty)?
         Where does the beam waist <span
         class="math inline">\(z_w\)</span> occur relative to the
         laser?</p></li>
         </ol>
         <h3 data-number="5.1.1" id="tips-for-good-measurements"><span
         class="header-section-number">5.1.1</span> Tips for Good
         Measurements</h3>
         <ol type="1">
         <li><p><strong>Starting Position</strong>: Position the razor
         so the beam is fully unblocked. Use the manual jog controls on
         the KST101 to find a good starting point.</p></li>
         <li><p><strong>Scan Range</strong>: Make sure your scan covers
         the full transition from unblocked to fully blocked. Include
         some data before and after the transition.</p></li>
         <li><p><strong>Real-Time Monitoring</strong>: Watch the live
         plot as data comes in. You can press Ctrl+C to stop early if
         something looks wrong.</p></li>
         <li><p><strong>File Organization</strong>: Consider adding
         descriptive prefixes to filenames to help organize your data
         (e.g., “z=50cm_beam_profile_…”).</p></li>
         </ol>
         <h2 data-number="5.2"
         id="how-does-a-lens-change-a-gaussian-beam"><span
         class="header-section-number">5.2</span> How Does a Lens Change
         a Gaussian Beam?</h2>
         <p>Pick a non-compound lens (not the fancy camera lenses) with
         focal length in the range 100-200 mm and assemble it in a lens
         mount with a retaining ring (see Figure <a
         href="#fig:mount-assembley">1</a>). Recall that it’s very
         important that you <strong>do not handle optical
         components</strong> (lenses, mirrors, polarizers, wave plates,
         beam splitters, etc.) <strong>with your bare hands</strong>.
         The oils on your skin can damage the optics and degrade the
         light in your experiment. Always handle these components while
         using <strong>latex/nitrile gloves or finger cots</strong>.</p>
         <p>Design and carry out an experiment to quantitatively answer
         the questions below. Consider carefully where to put the lens.
         Your data for this section can be used in the next section.</p>
         <ol type="1">
         <li>Insert a lens (after the mirrors) into the beam path to
         change the divergence/convergence of the beam but keep its
         propagation direction the same.</li>
         <li>When this condition (the beam propagation direction is
         unchanged) is met, where does the beam intersect the lens?
         <em>Note: This is the preferred method of adding a lens to an
         optical setup.</em></li>
         <li>Does the beam retain a Gaussian profile after the
         lens?</li>
         <li>What is the new beam waist <span
         class="math inline">\(w_0\)</span> and where does it
         occur?</li>
         <li>What factors affect the beam profile after the lens?</li>
         <li>Does the measured <span class="math inline">\(w(z)\)</span>
         match the Gaussian beam prediction <span
         class="math inline">\(w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi w_0^2}\right)^2}\)</span>?</li>
         </ol>
         <div id="fig:mount-assembley" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/mount-assembly.png"
         style="width:15cm"
         alt="Figure 1: Mounting assemblies for a mirror (left) and a lens (right)." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Mounting
         assemblies for a mirror (left) and a lens (right).</figcaption>
         </figure>
         </div>
         <h2 data-number="5.3"
         id="quantitatively-modeling-the-effect-of-a-lens"><span
         class="header-section-number">5.3</span> Quantitatively
         Modeling the Effect of a Lens</h2>
         <p>One of the simplest ways to model the effect of a lens is
         the thin lens equation, which is based on a ray model of light
         (see Figure <a href="#fig:ray-diagram">2</a>).</p>
         <p><span class="math display">\[
         \frac{1}{S_1}+\frac{1}{S_2}=\frac{1}{f}\]</span></p>
         <ol type="1">
         <li><p>Redraw Figure <a href="#fig:ray-diagram">2</a> to show
         how it would change when the light is modeled as a Gaussian
         beam, rather than rays. In particular, where should the beam
         waists occur? What determines the relative width of the beam
         waist?</p></li>
         <li><p>Experimentally test the accuracy of the thin lens
         equation for the imaging of Gaussian beams. Your data from the
         previous question can probably be used. Is the agreement within
         the estimated uncertainties?</p></li>
         <li><p>Systematic errors: Under what conditions should the thin
         lens equation be most valid? How do these conditions compare to
         conditions of your actual measurements? Can you get better
         agreement?</p></li>
         </ol>
         <div id="fig:ray-diagram" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/ray-diagram.png"
         style="width:15cm"
         alt="Figure 2: Diagram showing the focusing of light by a thin lens in the ray approximation. The diagram identifies the quantities in the thin lens equation: image distance, object distance, and focal length." />
         <figcaption aria-hidden="true"><span>Figure 2:</span> Diagram
         showing the focusing of light by a thin lens in the ray
         approximation. The diagram identifies the quantities in the
         thin lens equation: image distance, object distance, and focal
         length.</figcaption>
         </figure>
         </div>
         <h2 data-number="5.4"
         id="advanced-investigation-minimum-spot-size"><span
         class="header-section-number">5.4</span> Advanced
         Investigation: Minimum Spot Size</h2>
         <p>If time permits, investigate the following:</p>
         <ol type="1">
         <li>What determines the minimum spot size you can achieve with
         a lens?</li>
         <li>How does this relate to the concept of the “diffraction
         limit”?</li>
         <li>Try using a lens with shorter focal length. Does it produce
         a smaller spot? What are the tradeoffs?</li>
         </ol>
         <h1 data-number="6"
         id="appendix-understanding-the-beam-profiler-code"><span
         class="header-section-number">6</span> Appendix: Understanding
         the Beam Profiler Code</h1>
         <p>The beam profiler script uses a class-based structure.
         Understanding the code will help you modify it if needed and
         troubleshoot issues.</p>
         <h2 data-number="6.1" id="the-beamprofiler-class"><span
         class="header-section-number">6.1</span> The
         <code>BeamProfiler</code> Class</h2>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BeamProfiler:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, serial_number, daq_device<span class="op">=</span><span class="st">&quot;Dev1&quot;</span>, daq_channel<span class="op">=</span><span class="st">&quot;ai0&quot;</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Initialize with motor serial number and DAQ settings.&quot;&quot;&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="ex">connect</span>(<span class="va">self</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Connect to motor controller, configure velocity.&quot;&quot;&quot;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_position(<span class="va">self</span>):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Read current position in mm.&quot;&quot;&quot;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> move_to(<span class="va">self</span>, position_mm):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Move to absolute position.&quot;&quot;&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_voltage(<span class="va">self</span>):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Read single voltage from DAQ.&quot;&quot;&quot;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run_scan(<span class="va">self</span>, step_size_mm, wait_time_ms, direction, max_steps):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Execute the automated scan with real-time plotting.&quot;&quot;&quot;</span></span></code></pre></div>
         <h2 data-number="6.2" id="the-main-measurement-loop"><span
         class="header-section-number">6.2</span> The Main Measurement
         Loop</h2>
         <p>The core logic in <code>run_scan()</code> follows this
         pattern:</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> step_num <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Read current position</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    position <span class="op">=</span> <span class="va">self</span>.get_position()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Read photodetector voltage</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    voltage <span class="op">=</span> <span class="va">self</span>.read_voltage()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Save data point immediately</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    writer.writerow([position, voltage])</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Update real-time plot</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (matplotlib code)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. Move to next position</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.move_to(position <span class="op">+</span> step)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6. Wait for vibrations to settle</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time_ms <span class="op">/</span> <span class="dv">1000</span>)</span></code></pre></div>
         <p>This is essentially the same logic you would use when taking
         data manually, just automated.</p>
         <h2 data-number="6.3" id="troubleshooting"><span
         class="header-section-number">6.3</span> Troubleshooting</h2>
         <h3 data-number="6.3.1" id="device-not-found-error"><span
         class="header-section-number">6.3.1</span> “Device not found”
         Error</h3>
         <ul>
         <li>Check USB connection</li>
         <li>Verify serial number matches the display on the KST101</li>
         <li>Make sure no other software (APT User, Kinesis) is using
         the motor</li>
         </ul>
         <h3 data-number="6.3.2" id="motor-doesnt-move"><span
         class="header-section-number">6.3.2</span> Motor Doesn’t
         Move</h3>
         <ul>
         <li>Ensure power is connected to the KST101</li>
         <li>Check that the stage isn’t at a travel limit</li>
         <li>Verify the stage type is configured correctly in Kinesis
         (ZST225B)</li>
         </ul>
         <h3 data-number="6.3.3" id="voltage-reads-zero"><span
         class="header-section-number">6.3.3</span> Voltage Reads
         Zero</h3>
         <ul>
         <li>Check photodetector power</li>
         <li>Verify BNC cable connections to DAQ</li>
         <li>Make sure the beam actually hits the photodetector</li>
         </ul>
         <h3 data-number="6.3.4" id="noisy-data"><span
         class="header-section-number">6.3.4</span> Noisy Data</h3>
         <ul>
         <li>Increase wait time between steps</li>
         <li>Check for mechanical vibrations in your setup</li>
         <li>Shield the photodetector from ambient light</li>
         <li>Average multiple DAQ readings per point (see “Adding
         Averaging” above)</li>
         </ul>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
