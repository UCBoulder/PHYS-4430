<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 4</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#goals"><span
            class="toc-section-number">1</span> Goals</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">2</span> Prelab</a>
            <ul>
            <li><a href="#sec:wave-eqn"><span
            class="toc-section-number">2.1</span> Paraxial wave
            equation</a></li>
            <li><a href="#trying-out-the-gaussian-beam-model"><span
            class="toc-section-number">2.2</span> Trying out the
            gaussian beam model</a></li>
            </ul></li>
            <li><a href="#automation-of-the-measurement"><span
            class="toc-section-number">3</span> Automation of the
            Measurement</a></li>
            <li><a href="#the-experiment"><span
            class="toc-section-number">4</span> The Experiment</a>
            <ul>
            <li><a
            href="#measuring-the-beam-profile-of-your-he-ne-laser-without-any-lenses"><span
            class="toc-section-number">4.1</span> Measuring the beam
            profile of your He-Ne laser without any lenses</a></li>
            <li><a href="#how-does-a-lens-change-a-gaussian-beam"><span
            class="toc-section-number">4.2</span> How does a lens change
            a Gaussian beam?</a></li>
            <li><a
            href="#quantitatively-modeling-the-effect-of-a-lens"><span
            class="toc-section-number">4.3</span> Quantitatively
            modeling the effect of a lens</a></li>
            </ul></li>
            <li><a href="#sec:python-automation"><span
            class="toc-section-number">5</span> Appendix: Python
            Automation Guide</a>
            <ul>
            <li><a href="#hardware-setup"><span
            class="toc-section-number">5.1</span> Hardware
            Setup</a></li>
            <li><a href="#software-prerequisites"><span
            class="toc-section-number">5.2</span> Software
            Prerequisites</a>
            <ul>
            <li><a href="#thorlabs-kinesis-sdk"><span
            class="toc-section-number">5.2.1</span> 1. Thorlabs Kinesis
            SDK</a></li>
            <li><a href="#python-packages"><span
            class="toc-section-number">5.2.2</span> 2. Python
            Packages</a></li>
            <li><a href="#ni-daqmx-drivers"><span
            class="toc-section-number">5.2.3</span> 3. NI-DAQmx
            Drivers</a></li>
            </ul></li>
            <li><a href="#verifying-the-setup"><span
            class="toc-section-number">5.3</span> Verifying the
            Setup</a>
            <ul>
            <li><a href="#test-the-motor-connection"><span
            class="toc-section-number">5.3.1</span> Test the Motor
            Connection</a></li>
            <li><a href="#test-the-daq-connection"><span
            class="toc-section-number">5.3.2</span> Test the DAQ
            Connection</a></li>
            </ul></li>
            <li><a href="#running-the-beam-profiler"><span
            class="toc-section-number">5.4</span> Running the Beam
            Profiler</a>
            <ul>
            <li><a href="#basic-usage"><span
            class="toc-section-number">5.4.1</span> Basic Usage</a></li>
            <li><a href="#choosing-parameters"><span
            class="toc-section-number">5.4.2</span> Choosing
            Parameters</a></li>
            <li><a href="#output-files"><span
            class="toc-section-number">5.4.3</span> Output
            Files</a></li>
            </ul></li>
            <li><a href="#understanding-the-code-structure"><span
            class="toc-section-number">5.5</span> Understanding the Code
            Structure</a>
            <ul>
            <li><a href="#the-beamprofiler-class"><span
            class="toc-section-number">5.5.1</span> The
            <code>BeamProfiler</code> Class</a></li>
            <li><a href="#the-main-measurement-loop"><span
            class="toc-section-number">5.5.2</span> The Main Measurement
            Loop</a></li>
            </ul></li>
            <li><a href="#customizing-the-script"><span
            class="toc-section-number">5.6</span> Customizing the
            Script</a>
            <ul>
            <li><a href="#changing-the-daq-channel"><span
            class="toc-section-number">5.6.1</span> Changing the DAQ
            Channel</a></li>
            <li><a href="#modifying-velocity-settings"><span
            class="toc-section-number">5.6.2</span> Modifying Velocity
            Settings</a></li>
            <li><a href="#adding-averaging"><span
            class="toc-section-number">5.6.3</span> Adding
            Averaging</a></li>
            </ul></li>
            <li><a href="#troubleshooting"><span
            class="toc-section-number">5.7</span> Troubleshooting</a>
            <ul>
            <li><a href="#device-not-found-error"><span
            class="toc-section-number">5.7.1</span> “Device not found”
            Error</a></li>
            <li><a href="#motor-doesnt-move"><span
            class="toc-section-number">5.7.2</span> Motor Doesn’t
            Move</a></li>
            <li><a href="#voltage-reads-zero"><span
            class="toc-section-number">5.7.3</span> Voltage Reads
            Zero</a></li>
            <li><a href="#python-import-errors"><span
            class="toc-section-number">5.7.4</span> Python Import
            Errors</a></li>
            <li><a href="#noisy-data"><span
            class="toc-section-number">5.7.5</span> Noisy Data</a></li>
            </ul></li>
            <li><a href="#tips-for-good-measurements"><span
            class="toc-section-number">5.8</span> Tips for Good
            Measurements</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="goals"><span
         class="header-section-number">1</span> Goals</h1>
         <p>In week one, we measured the profile of the laser and found
         it to be Gaussian to a good approximation. However, we don’t
         have any model for how the profile changes as the beam
         propagates and we will work to improve our model. Also, we will
         apply automation to more rapidly take data. The full set of
         learning goals includes:</p>
         <ol type="1">
         <li>Automated data acquisition.
         <ul>
         <li>Python with Thorlabs Kinesis SDK</li>
         <li>USB DAQ (NI USB-6009) with nidaqmx</li>
         </ul></li>
         <li>Fitting and analysis of data in Python</li>
         <li>Using a predictive model of Gaussian laser beams
         <ul>
         <li>Contrast Gaussian beams with geometric optics</li>
         </ul></li>
         <li>Measure profiles of a Gaussian beam, and extract the
         Gaussian beam parameters</li>
         <li>Effect of a lens on Gaussian beams.
         <ul>
         <li>Is it still Gaussian?</li>
         <li>Does the thin lens equation apply to Gaussian beams?</li>
         <li>What limits the minimum achievable spot size?</li>
         </ul></li>
         </ol>
         <h1 data-number="2" id="prelab"><span
         class="header-section-number">2</span> Prelab</h1>
         <p>Light is a propagating oscillation of the electromagnetic
         field. The general principles which govern electromagnetic
         waves are Maxwell’s equations. From these general relations, a
         vector wave equation can be derived.</p>
         <p><span id="eq:1" class="eqnos"><span class="math display">\[
         \nabla^2\vec{E}=\mu_0\epsilon_0
         \frac{\partial^2\vec{E}}{\partial
         t^2}\text{.}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>One of the simplest solutions is that of a plane wave
         propagating in the <span class="math inline">\(\hat{z}\)</span>
         direction:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=E_x\hat{x}cos(kz-\omega
         t+\phi_x)+E_y\hat{y}cos(kz-\omega
         t+\phi_y)\text{.}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>But as the measurements from the first week showed, our
         laser beams are commonly well approximated by a beam shape with
         a Gaussian intensity profile. Apparently, since these Gaussian
         profile beams exist, they must be solutions of the wave
         equation. The next section will discuss how we derive the
         Gaussian beam electric field, and give a few key results.</p>
         <h2 data-number="2.1" id="sec:wave-eqn"><span
         class="header-section-number">2.1</span> Paraxial wave
         equation</h2>
         <p>One important thing to note about the beam output from most
         lasers is that the width of the beam changes very slowly
         compared to the wavelength of light. Assume a complex solution,
         where the beam is propagating in the <span
         class="math inline">\(\hat{z}\)</span>-direction, with the
         electric field polarization in the <span
         class="math inline">\(\hat{x}\)</span>-direction:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=\hat{x}A(x,y,z)e^{kz-\omega
         t}\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The basic idea is that the spatial pattern of the beam,
         described by the function <span
         class="math inline">\(A(x,y,z)\)</span>, does not change much
         over a wavelength. In the case of the He-Ne laser output, the
         function <span class="math inline">\(A(x,y,z)\)</span> is a
         Gaussian profile that changes its width as a function of <span
         class="math inline">\(z\)</span>. If we substitute the trial
         solution in Equation <a href="#eq:3">3</a> into the wave
         equation in Equation <a href="#eq:1">1</a> we get</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\hat{x} \left[
         \left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial z} - k^2A
         \right]e^{i(kz-\omega
         t)}=\hat{x}\mu_0\epsilon_oA(-\omega^2)e^{i(kz-\omega
         t)}\text{.}\quad\quad\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>This can be simplified recognizing that <span
         class="math inline">\(k^2=\omega^2/c^2=\mu_0\epsilon_0\omega^2\)</span>,
         where the speed of light is related to the permeability and
         permittivity of free space by <span
         class="math inline">\(c=(\mu_0\epsilon_0)^{-1/2}\)</span>.
         Also, the <span class="math inline">\(\hat{x}e^{i(kz-\omega
         t)}\)</span> term is common to both sides and can be dropped,
         which results in</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial
         z}=0\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So far, we have made no approximation to the solution or the
         wave equation, but now we apply the assumption that <span
         class="math inline">\(\partial{A}(x,y,z)/\partial{z}\)</span>
         changes slowly over a wavelength <span
         class="math inline">\(\lambda = 2\pi /k\)</span>, so we neglect
         the term</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\left| \frac{\partial^2A}{\partial z^2}
         \right| \ll \left|2k\frac{\partial A}{\partial
         z}\right|\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <p>Finally, we get the paraxial wave equation,</p>
         <p><span id="eq:7" class="eqnos"><span
         class="math display">\[\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2}=0\text{.}\]</span><span class="eqnos-number">(7)</span></span>
         </p>
         <p>One set of solutions to the paraxial wave equation are
         Gauss-Hermite beams, which have an intensity profiles like
         those shown in Figure <a href="#fig:gauss-hermite">1</a>. These
         are the same solutions as for the quantum simple harmonic
         oscillator, a topic that could be further explored as a final
         project.</p>
         <p>The simplest of these solutions is the Gaussian beam, which
         has an electric field given by</p>
         <p><span id="eq:8" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t) =
         \vec{E}_0\frac{w_0}{w(z)}exp\left(-\frac{x^2+y^2}{w^2(z)}\right)exp\left(ik\frac{x^2+y^2}{2R(z)}\right)e^{-i\zeta(z)}e^{i(kz-\omega
         t)}\text{,}\quad\quad\]</span><span class="eqnos-number">(8)</span></span>
         </p>
         <p>where <span class="math inline">\(\vec{E_0}\)</span> is a
         time-independent vector (orthogonal to propagation direction
         <span class="math inline">\(\hat{z}\)</span>) whose magnitude
         denotes the amplitude of the laser’s electric field and the
         direction denotes the direction of polarization. The beam
         radius <span class="math inline">\(w(z)\)</span>is given by</p>
         <p><span id="eq:9" class="eqnos"><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi
         w_0^2}\right)^2}\text{.}\]</span><span class="eqnos-number">(9)</span></span>
         </p>
         <p><span class="math inline">\(R(z)\)</span>,the radius of
         curvature of the wavefront, is given by</p>
         <p><span id="eq:10" class="eqnos"><span
         class="math display">\[R(z)=z\left(1+\left(\frac{\pi
         w_0^2}{\lambda
         z}\right)^2\right)\text{,}\]</span><span class="eqnos-number">(10)</span></span>
         </p>
         <p>and the Gouy phase is given by</p>
         <p><span id="eq:11" class="eqnos"><span
         class="math display">\[\zeta(z)=arctan\frac{\pi w_0^2}{\lambda
         z}\text{.}\]</span><span class="eqnos-number">(11)</span></span>
         </p>
         <p>The remarkable thing about all these equations is that only
         two parameters need to be specified to give the whole beam
         profile: the wavelength <span
         class="math inline">\(\lambda\)</span> and the beam waist <span
         class="math inline">\(w_0\)</span>, which is the narrowest
         point in the beam profile. There is a more general set of
         Hermite Gaussian modes which are shown in Figure <a
         href="#fig:gauss-hermite">1</a>. The laser cavity typically
         produces the (0,0) mode shown in the upper left corner, but an
         optical cavity can also be used to create these other modes – a
         topic that can be explored in the final projects.</p>
         <div id="fig:gauss-hermite" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-hermite.png"
         style="width:20cm"
         alt="Figure 1: Intensity distributions for the lowest order Gauss-Hermite solutions to the paraxial wave equation. The axes are in units of the beam width, w." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Intensity
         distributions for the lowest order Gauss-Hermite solutions to
         the paraxial wave equation. The axes are in units of the beam
         width, <span class="math inline">\(w\)</span>.</figcaption>
         </figure>
         </div>
         <h2 data-number="2.2"
         id="trying-out-the-gaussian-beam-model"><span
         class="header-section-number">2.2</span> Trying out the
         gaussian beam model</h2>
         <p>In the first week of the lab, we assumed the intensity
         profile of the Gaussian beam was given by <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>.
         The equation for the electric field of the Gaussian Beam in
         Equation <a href="#eq:8">8</a> looks substantially more
         complicated.</p>
         <ol type="1">
         <li>How are the expressions for electric field and intensity
         related?</li>
         <li>Is Equation <a href="#eq:8">8</a> consistent with the
         simple expression for intensity <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>?</li>
         </ol>
         <p>The Gaussian beam equations given in Equations <a
         href="#eq:8">8</a> -<a href="#eq:11">11</a> assume the beam
         comes to its narrowest width (called the beam waist, <span
         class="math inline">\(w_0\)</span>) at <span
         class="math inline">\(z=0\)</span>.</p>
         <ol start="3" type="1">
         <li>How would you rewrite these four equations assuming the
         beam waist occurs at a different position <span
         class="math inline">\(z=z_w\)</span>?</li>
         <li>One way to check your answer is to make sure the equations
         simplify to Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a> in the special case of <span
         class="math inline">\(z_w=0\)</span>.</li>
         <li>Write a Python function to fit <a
         href="../resources/lab-guides/gaussian-laser-beams/Test_beam_width_data.csv">this
         data set</a>. Assume the wavelength is <span
         class="math inline">\(\lambda=632.8\ nm\)</span>.
         <ol type="1">
         <li>What is the functional form for your fit function?</li>
         <li>What are the different fit parameters and what do they
         mean?</li>
         <li>Is it a linear or nonlinear fit function? Why?</li>
         </ol></li>
         <li>You should get that a beam waist of <span
         class="math inline">\(w_0=(93.9\pm0.1)\times10^{-6}\ m\)</span>
         and occurs at a position <span
         class="math inline">\(z_w=0.3396\pm0.0003\ m\)</span>.</li>
         </ol>
         <h1 data-number="3" id="automation-of-the-measurement"><span
         class="header-section-number">3</span> Automation of the
         Measurement</h1>
         <p>Before we begin this week’s lab, reflect on your experience
         from week one (and perhaps refer to your lab notebook entry to
         help guide your memory).</p>
         <ol type="1">
         <li>In week one, how long did the total process of data taking
         through analysis take to make a measurement of the beam width
         <span class="math inline">\(w\)</span>?</li>
         <li>In this lab, you may have to take 20-30 beam profiles in
         order to measure <span class="math inline">\(w_0\)</span> and
         <span class="math inline">\(z_w\)</span>. How long would this
         take with your current method?</li>
         <li>What are the most time consuming portions of the process?
         Which parts of the process would benefit from automation?</li>
         </ol>
         <p>In the next step, you will use Python and your NI USB-6009
         data acquisition device to automate the procedure for measuring
         the width of the laser beam. You can do this with your own
         laptop or with the laptops in the lab.</p>
         <p>In order to set up your measurement automation you will use
         a Python script that controls the motor and reads the
         photodetector. Instructions can be found in the Appendix <a
         href="#sec:python-automation">5</a>.</p>
         <ol start="4" type="1">
         <li>Test and run the automated Python program and evaluate the
         result using the same Python analysis from week one.</li>
         <li>Before you go on, make sure the automated acquisition and
         analysis routine gives the same result as the method you used
         in week one.</li>
         <li>How long does your new measurement method take? (2-3
         minutes per <span class="math inline">\(w\)</span> measurement
         is very good.)</li>
         </ol>
         <h1 data-number="4" id="the-experiment"><span
         class="header-section-number">4</span> The Experiment</h1>
         <p>The Gaussian beam model of light is useful because it often
         describes the beam of light created by lasers. This section
         will test the validity of the model for our He-Ne laser beam.
         Also, the effect of a lens on a Gaussian beam will be tested,
         and the Gaussian beam model will be compared with predictions
         from the simpler ray theory. Lastly, the Gaussian beam theory
         can be used to describe the minimum possible focus size for a
         beam and a lens.</p>
         <h2 data-number="4.1"
         id="measuring-the-beam-profile-of-your-he-ne-laser-without-any-lenses"><span
         class="header-section-number">4.1</span> Measuring the beam
         profile of your He-Ne laser without any lenses</h2>
         <p>There is a straight-forward reason that a He-Ne laser should
         produce a Gaussian beam. The laser light builds up between two
         mirrors, and the electromagnetic mode that best matches the
         shape of the mirrors is the Gaussian beam.</p>
         <ol type="1">
         <li>Considering Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a>, which aspects of the Gaussian beam model
         can you test? Are there any parts of the model you cannot
         test?</li>
         <li>Measure the beam width <span
         class="math inline">\(w\)</span> at various distances from the
         laser. Consider carefully what distance should be varying. Is
         it the distance from laser to razor, the distance from razor to
         photodetector, or the distance from laser to photodetector? How
         did you decide what positions <span
         class="math inline">\(z\)</span> to measure the width at (meter
         sticks and other measurement tools are available in the
         lab)?</li>
         <li>Fit the data to <span class="math inline">\(w(z)\)</span>,
         the predicted expression for a Gaussian beam given in Equation
         <a href="#eq:9">9</a>.</li>
         <li>What is the value of the beam waist <span
         class="math inline">\(w_0\)</span> (including uncertainty)?
         Where does the beam waist <span
         class="math inline">\(z_w\)</span> occur relative to the
         laser?</li>
         </ol>
         <h2 data-number="4.2"
         id="how-does-a-lens-change-a-gaussian-beam"><span
         class="header-section-number">4.2</span> How does a lens change
         a Gaussian beam?</h2>
         <p>Pick a non-compound lens (not the fancy camera lenses) with
         focal length in the range 100-200 mm and assemble it in a lens
         mount with a retaining ring (see Figure <a
         href="#fig:mount-assembley">2</a>). Recall that it’s very
         important that you <strong>do not handle optical
         components</strong> (lenses, mirrors, polarizers, wave plates,
         beam splitters, etc.) <strong>with your bare hands</strong>.
         The oils on your skin can damage the optics and degrade the
         light in your experiment. Always handle these components while
         using <strong>latex/nitrile gloves or finger cots</strong>.</p>
         <p>Design and carry out an experiment to quantitatively answer
         the questions below. Consider carefully where to put the lens.
         Your data for this section can be used in the next section.</p>
         <ol type="1">
         <li>Insert a lens (after the mirrors) into the beam path to
         change the divergence/convergence of the beam but keep its
         propagation direction the same.</li>
         <li>When this condition (the beam propagation direction is
         unchanged) is met, where does the beam intersect the lens?
         <em>Note: This is the preferred method of adding a lens to an
         optical set up.</em></li>
         <li>Does the beam retain a Gaussian profile after the
         lens?</li>
         <li>What is the new beam waist <span
         class="math inline">\(w_0\)</span> and where does it
         occur?</li>
         <li>What factors affect the beam profile after the lens?</li>
         <li>Does the measured <span class="math inline">\(w(z)\)</span>
         match the Gaussian beam prediction given in Equation <a
         href="#eq:9">9</a>?</li>
         </ol>
         <div id="fig:mount-assembley" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/mount-assembly.png"
         style="width:15cm"
         alt="Figure 2: Mounting assemblies for a mirror (left) and a lens (right)." />
         <figcaption aria-hidden="true"><span>Figure 2:</span> Mounting
         assemblies for a mirror (left) and a lens (right).</figcaption>
         </figure>
         </div>
         <h2 data-number="4.3"
         id="quantitatively-modeling-the-effect-of-a-lens"><span
         class="header-section-number">4.3</span> Quantitatively
         modeling the effect of a lens</h2>
         <p>One of the simplest ways to model the effect of a lens is
         the thin lens equation, which is based on a ray model of light
         (see Figure <a href="#fig:ray-diagram">3</a>).</p>
         <p><span class="math display">\[
         \frac{1}{S_1}+\frac{1}{S_2}=\frac{1}{f}\]</span></p>
         <ol type="1">
         <li>Redraw Figure <a href="#fig:ray-diagram">3</a> to show how
         it would change when the light is modeled as a Gaussian beam,
         rather than rays. In particular, where should the beam waists
         occur? What determines the relative width of the beam
         waist?</li>
         <li>Experimentally test the accuracy of the thin lens equation
         for the imaging of Gaussian beams. Your data from the previous
         question can probably be used. Is the agreement within the
         estimated uncertainties?</li>
         <li>Systematic errors: Under what conditions should the thin
         lens equation be most valid? How do these conditions compare to
         conditions of your actual measurements? Can you get better
         agreement?</li>
         </ol>
         <div id="fig:ray-diagram" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/ray-diagram.png"
         style="width:15cm"
         alt="Figure 3: Diagram showing the focusing of light by a thin lens in the ray approximation. The diagram identifies the quantities in the thin lens equation: image distance, object distance, and focal length." />
         <figcaption aria-hidden="true"><span>Figure 3:</span> Diagram
         showing the focusing of light by a thin lens in the ray
         approximation. The diagram identifies the quantities in the
         thin lens equation: image distance, object distance, and focal
         length.</figcaption>
         </figure>
         </div>
         <h1 data-number="5" id="sec:python-automation"><span
         class="header-section-number">5</span> Appendix: Python
         Automation Guide</h1>
         <p>This appendix guides you through setting up and running the
         automated beam profile measurement using Python. The script
         controls the Thorlabs KST101 motor controller to move the
         knife-edge while simultaneously reading voltage from the
         photodetector via the NI-DAQmx.</p>
         <h2 data-number="5.1" id="hardware-setup"><span
         class="header-section-number">5.1</span> Hardware Setup</h2>
         <p>The physical connections are:</p>
         <ol type="1">
         <li><strong>Motor Controller (KST101)</strong>:
         <ul>
         <li>Connect the USB cable from the KST101 cube to your
         computer</li>
         <li>Connect the power supply to the KST101</li>
         <li>The motor should already be mechanically connected to the
         translation stage with the razor</li>
         </ul></li>
         <li><strong>Data Acquisition (NI USB-6009)</strong>:
         <ul>
         <li>Connect the USB cable from the DAQ to your computer</li>
         <li>Connect the photodetector BNC output to the analog input
         terminals:
         <ul>
         <li>Positive signal to AI0+ (pin 2)</li>
         <li>Ground to AI0- (pin 1 or GND)</li>
         </ul></li>
         </ul></li>
         <li><strong>Optical Setup</strong>:
         <ul>
         <li>Position the photodetector after the knife-edge in the beam
         path</li>
         <li>Ensure the beam passes cleanly through when the razor is
         fully retracted</li>
         </ul></li>
         </ol>
         <h2 data-number="5.2" id="software-prerequisites"><span
         class="header-section-number">5.2</span> Software
         Prerequisites</h2>
         <p>Before running the automation script, you need to
         install:</p>
         <h3 data-number="5.2.1" id="thorlabs-kinesis-sdk"><span
         class="header-section-number">5.2.1</span> 1. Thorlabs Kinesis
         SDK</h3>
         <p>Download and install from the Thorlabs website: <a
         href="https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control">https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control</a></p>
         <p><strong>Important</strong>: Choose the correct version: - If
         you have 32-bit Python: Install the 32-bit Kinesis software -
         If you have 64-bit Python: Install the 64-bit Kinesis
         software</p>
         <p>To check your Python version, run:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys.maxsize <span class="op">&gt;</span> <span class="dv">2</span><span class="op">**</span><span class="dv">32</span>)  <span class="co"># True = 64-bit, False = 32-bit</span></span></code></pre></div>
         <h3 data-number="5.2.2" id="python-packages"><span
         class="header-section-number">5.2.2</span> 2. Python
         Packages</h3>
         <p>Install the required packages:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pythonnet nidaqmx numpy matplotlib</span></code></pre></div>
         <h3 data-number="5.2.3" id="ni-daqmx-drivers"><span
         class="header-section-number">5.2.3</span> 3. NI-DAQmx
         Drivers</h3>
         <p>If not already installed, download from: <a
         href="https://www.ni.com/en-us/support/downloads/drivers/download.ni-daq-mx.html">https://www.ni.com/en-us/support/downloads/drivers/download.ni-daq-mx.html</a></p>
         <h2 data-number="5.3" id="verifying-the-setup"><span
         class="header-section-number">5.3</span> Verifying the
         Setup</h2>
         <h3 data-number="5.3.1" id="test-the-motor-connection"><span
         class="header-section-number">5.3.1</span> Test the Motor
         Connection</h3>
         <p>First, verify that Windows recognizes the motor
         controller:</p>
         <ol type="1">
         <li>Connect the USB to the KST101, then turn on power</li>
         <li>Open <strong>Device Manager</strong> and look for the
         device under “USB devices” or “Thorlabs APT Device”</li>
         <li>Note the serial number (displayed on the KST101
         screen)</li>
         </ol>
         <p>If you get a driver error, you may need to disable Memory
         Integrity in Windows Security (ask technical staff for help if
         this occurs on a lab computer).</p>
         <h3 data-number="5.3.2" id="test-the-daq-connection"><span
         class="header-section-number">5.3.2</span> Test the DAQ
         Connection</h3>
         <p>Run this quick test to verify DAQ communication:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># List available devices</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> nidaqmx.system.System.local()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> device <span class="kw">in</span> system.devices:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Found: </span><span class="sc">{</span>device<span class="sc">.</span>name<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Test reading a voltage</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    voltage <span class="op">=</span> task.read()</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span></code></pre></div>
         <p>If no device is found, check the USB connection and ensure
         NI-DAQmx drivers are installed.</p>
         <h2 data-number="5.4" id="running-the-beam-profiler"><span
         class="header-section-number">5.4</span> Running the Beam
         Profiler</h2>
         <p>The automation script is available at:
         <code>resources/lab-guides/gaussian-laser-beams/python/04_beam_profiler.py</code></p>
         <h3 data-number="5.4.1" id="basic-usage"><span
         class="header-section-number">5.4.1</span> Basic Usage</h3>
         <p>Navigate to the script directory and run:</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> 04_beam_profiler.py</span></code></pre></div>
         <p>The script will prompt you for:</p>
         <ol type="1">
         <li><strong>Motor serial number</strong>: Found on the KST101
         display (e.g., “26004813”)</li>
         <li><strong>Step size (mm)</strong>: How far to move between
         measurements (recommend 0.05 mm)</li>
         <li><strong>Wait time (ms)</strong>: Delay after each step
         (recommend 500 ms)</li>
         <li><strong>Direction</strong>: “forward” or “backward”</li>
         </ol>
         <h3 data-number="5.4.2" id="choosing-parameters"><span
         class="header-section-number">5.4.2</span> Choosing
         Parameters</h3>
         <p><strong>Step Size</strong>: Smaller step sizes give higher
         resolution but take longer: - 0.05 mm is a good starting point
         for most beams - Use smaller steps (0.02-0.03 mm) for tightly
         focused beams - You can use larger steps (0.1 mm) for initial
         alignment</p>
         <p><strong>Wait Time</strong>: This ensures measurements are
         taken after vibrations settle: - Use kinematic equation to
         estimate: <span class="math inline">\(x =
         \frac{1}{2}at^2\)</span> - For 0.05 mm step and 1 mm/s²
         acceleration: <span class="math inline">\(t = \sqrt{2 \times
         0.05/1} \approx 316\)</span> ms - Add safety margin: 500 ms is
         usually sufficient - Increase if you see noisy data</p>
         <h3 data-number="5.4.3" id="output-files"><span
         class="header-section-number">5.4.3</span> Output Files</h3>
         <p>The script automatically generates two files with
         timestamps:</p>
         <ol type="1">
         <li><strong>CSV data file</strong>:
         <code>beam_profile_YYYYMMDD_HHMMSS.csv</code>
         <ul>
         <li>Two columns: Position (mm), Voltage (V)</li>
         <li>Ready for analysis with your fitting code from Week 1</li>
         </ul></li>
         <li><strong>Plot image</strong>:
         <code>beam_profile_YYYYMMDD_HHMMSS.png</code>
         <ul>
         <li>Quick visualization of the measured profile</li>
         </ul></li>
         </ol>
         <h2 data-number="5.5"
         id="understanding-the-code-structure"><span
         class="header-section-number">5.5</span> Understanding the Code
         Structure</h2>
         <p>The beam profiler script uses a class-based structure. Here
         are the key components:</p>
         <h3 data-number="5.5.1" id="the-beamprofiler-class"><span
         class="header-section-number">5.5.1</span> The
         <code>BeamProfiler</code> Class</h3>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BeamProfiler:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, serial_number, daq_device<span class="op">=</span><span class="st">&quot;Dev1&quot;</span>, daq_channel<span class="op">=</span><span class="st">&quot;ai0&quot;</span>):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Initialize with motor serial number and DAQ settings.&quot;&quot;&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="ex">connect</span>(<span class="va">self</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Connect to motor controller, configure velocity.&quot;&quot;&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_position(<span class="va">self</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Read current position in mm.&quot;&quot;&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> move_to(<span class="va">self</span>, position_mm):</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Move to absolute position.&quot;&quot;&quot;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_voltage(<span class="va">self</span>):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Read single voltage from DAQ.&quot;&quot;&quot;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> run_scan(<span class="va">self</span>, step_size_mm, wait_time_ms, direction, max_steps):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Execute the automated scan with real-time plotting.&quot;&quot;&quot;</span></span></code></pre></div>
         <h3 data-number="5.5.2" id="the-main-measurement-loop"><span
         class="header-section-number">5.5.2</span> The Main Measurement
         Loop</h3>
         <p>The core logic in <code>run_scan()</code> follows this
         pattern:</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> step_num <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Read current position</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    position <span class="op">=</span> <span class="va">self</span>.get_position()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Read photodetector voltage</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    voltage <span class="op">=</span> <span class="va">self</span>.read_voltage()</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Save data point immediately</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    writer.writerow([position, voltage])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Update real-time plot</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (matplotlib code)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. Move to next position</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.move_to(position <span class="op">+</span> step)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6. Wait for vibrations to settle</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time_ms <span class="op">/</span> <span class="dv">1000</span>)</span></code></pre></div>
         <p>This is essentially the same logic you would use when taking
         data manually, just automated.</p>
         <h2 data-number="5.6" id="customizing-the-script"><span
         class="header-section-number">5.6</span> Customizing the
         Script</h2>
         <h3 data-number="5.6.1" id="changing-the-daq-channel"><span
         class="header-section-number">5.6.1</span> Changing the DAQ
         Channel</h3>
         <p>If your photodetector is connected to a different channel
         (e.g., AI1):</p>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>profiler <span class="op">=</span> BeamProfiler(serial_number, daq_channel<span class="op">=</span><span class="st">&quot;ai1&quot;</span>)</span></code></pre></div>
         <h3 data-number="5.6.2" id="modifying-velocity-settings"><span
         class="header-section-number">5.6.2</span> Modifying Velocity
         Settings</h3>
         <p>The default velocity is 1 mm/s with 1 mm/s² acceleration. To
         change this, modify the <code>connect()</code> method:</p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>vel_params.MaxVelocity <span class="op">=</span> Decimal(<span class="fl">2.0</span>)  <span class="co"># 2 mm/s</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>vel_params.Acceleration <span class="op">=</span> Decimal(<span class="fl">2.0</span>)  <span class="co"># 2 mm/s²</span></span></code></pre></div>
         <h3 data-number="5.6.3" id="adding-averaging"><span
         class="header-section-number">5.6.3</span> Adding
         Averaging</h3>
         <p>For noisy signals, you can modify
         <code>read_voltage()</code> to average multiple samples:</p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_voltage(<span class="va">self</span>, num_samples<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Read averaged voltage from DAQ.&quot;&quot;&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>daq_device<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>daq_channel<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        voltages <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>num_samples)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.mean(voltages)</span></code></pre></div>
         <h2 data-number="5.7" id="troubleshooting"><span
         class="header-section-number">5.7</span> Troubleshooting</h2>
         <h3 data-number="5.7.1" id="device-not-found-error"><span
         class="header-section-number">5.7.1</span> “Device not found”
         Error</h3>
         <ul>
         <li>Check USB connection</li>
         <li>Verify serial number matches the display on the KST101</li>
         <li>Make sure no other software (APT User, Kinesis) is using
         the motor</li>
         </ul>
         <h3 data-number="5.7.2" id="motor-doesnt-move"><span
         class="header-section-number">5.7.2</span> Motor Doesn’t
         Move</h3>
         <ul>
         <li>Ensure power is connected to the KST101</li>
         <li>Check that the stage isn’t at a travel limit</li>
         <li>Verify the stage type is configured correctly in Kinesis
         (ZST225B)</li>
         </ul>
         <h3 data-number="5.7.3" id="voltage-reads-zero"><span
         class="header-section-number">5.7.3</span> Voltage Reads
         Zero</h3>
         <ul>
         <li>Check photodetector power</li>
         <li>Verify BNC cable connections to DAQ</li>
         <li>Make sure the beam actually hits the photodetector</li>
         </ul>
         <h3 data-number="5.7.4" id="python-import-errors"><span
         class="header-section-number">5.7.4</span> Python Import
         Errors</h3>
         <ul>
         <li><strong>pythonnet error</strong>: Ensure Kinesis SDK is
         installed and matches Python architecture (32/64-bit)</li>
         <li><strong>nidaqmx error</strong>: Install NI-DAQmx drivers
         from NI website</li>
         </ul>
         <h3 data-number="5.7.5" id="noisy-data"><span
         class="header-section-number">5.7.5</span> Noisy Data</h3>
         <ul>
         <li>Increase wait time between steps</li>
         <li>Check for mechanical vibrations in your setup</li>
         <li>Shield the photodetector from ambient light</li>
         <li>Average multiple DAQ readings per point</li>
         </ul>
         <h2 data-number="5.8" id="tips-for-good-measurements"><span
         class="header-section-number">5.8</span> Tips for Good
         Measurements</h2>
         <ol type="1">
         <li><p><strong>Starting Position</strong>: Position the razor
         so the beam is fully unblocked. Use the manual jog controls on
         the KST101 to find a good starting point.</p></li>
         <li><p><strong>Scan Range</strong>: Make sure your scan covers
         the full transition from unblocked to fully blocked. Include
         some data before and after the transition.</p></li>
         <li><p><strong>Real-Time Monitoring</strong>: Watch the live
         plot as data comes in. You can press Ctrl+C to stop early if
         something looks wrong.</p></li>
         <li><p><strong>Data Validation</strong>: Before collecting many
         profiles, take one measurement manually and one with
         automation. Compare results to ensure consistency.</p></li>
         <li><p><strong>File Organization</strong>: The script includes
         timestamps in filenames, but consider adding descriptive
         prefixes (e.g., by modifying the <code>filename</code>
         variable) to help organize your data.</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>

      </script>
   </body>
</html>
