<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 2</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#where-we-are-in-the-sequence"><span
            class="toc-section-number">1</span> Where We Are in the
            Sequence</a></li>
            <li><a href="#overview"><span
            class="toc-section-number">2</span> Overview</a>
            <ul>
            <li><a href="#what-is-python"><span
            class="toc-section-number">2.1</span> What is
            Python?</a></li>
            <li><a href="#learning-goals"><span
            class="toc-section-number">2.2</span> Learning
            Goals</a></li>
            </ul></li>
            <li><a href="#overview-of-your-work"><span
            class="toc-section-number">3</span> Overview of Your
            Work</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">4</span> Prelab</a>
            <ul>
            <li><a href="#useful-readings"><span
            class="toc-section-number">4.1</span> Useful
            readings</a></li>
            <li><a href="#why-do-we-minimize-the-sum-of-squares"><span
            class="toc-section-number">4.2</span> Why do we minimize the
            sum of squares?</a></li>
            <li><a href="#sec:min-graph"><span
            class="toc-section-number">4.3</span> Minimizing <span
            class="math inline">\(\chi^2\)</span> graphically</a></li>
            <li><a href="#uncertainty-in-the-fit-parameters"><span
            class="toc-section-number">4.4</span> Uncertainty in the fit
            parameters</a></li>
            <li><a href="#estimating-the-uncertainty-in-the-data"><span
            class="toc-section-number">4.5</span> Estimating the
            uncertainty in the data</a></li>
            <li><a href="#goodness-of-fit"><span
            class="toc-section-number">4.6</span> Goodness of fit</a>
            <ul>
            <li><a href="#sec:plot-res"><span
            class="toc-section-number">4.6.1</span> Plotting the fit
            residuals</a></li>
            <li><a
            href="#chi-by-eye---eyeballing-the-goodness-of-fit"><span
            class="toc-section-number">4.6.2</span> “Chi by eye” -
            eyeballing the goodness of fit</a></li>
            <li><a
            href="#chi2-and-chi_red2-for-testing-the-goodness-of-fit"><span
            class="toc-section-number">4.6.3</span> <span
            class="math inline">\(\chi^2\)</span> and <span
            class="math inline">\(\chi_{red}^2\)</span> for testing the
            “goodness” of fit</a></li>
            <li><a
            href="#choosing-a-strategy-to-estimate-the-uncertainty"><span
            class="toc-section-number">4.6.4</span> Choosing a strategy
            to estimate the uncertainty</a></li>
            <li><a href="#weighted-fits"><span
            class="toc-section-number">4.6.5</span> Weighted
            fits</a></li>
            <li><a
            href="#why-is-it-often-bad-to-overestimate-uncertainties"><span
            class="toc-section-number">4.6.6</span> Why is it often bad
            to overestimate uncertainties?</a></li>
            <li><a
            href="#when-does-curve_fit-underestimate-the-true-uncertainty"><span
            class="toc-section-number">4.6.7</span> When does
            <code>curve_fit</code> underestimate the true
            uncertainty?</a></li>
            <li><a
            href="#statistical-vs.-systematic-uncertainties"><span
            class="toc-section-number">4.6.8</span> Statistical
            vs. Systematic Uncertainties</a></li>
            </ul></li>
            <li><a href="#error-bars"><span
            class="toc-section-number">4.7</span> Error bars</a>
            <ul>
            <li><a href="#error-bars-in-python-with-matplotlib"><span
            class="toc-section-number">4.7.1</span> Error bars in Python
            with Matplotlib</a></li>
            <li><a
            href="#example-gaussian-laser-beam-width-measurement"><span
            class="toc-section-number">4.7.2</span> Example: Gaussian
            laser beam width measurement</a></li>
            </ul></li>
            <li><a
            href="#prelab-exercise-error-function-fitting-practice"><span
            class="toc-section-number">4.8</span> Prelab Exercise: Error
            Function Fitting Practice</a>
            <ul>
            <li><a href="#the-error-function-model"><span
            class="toc-section-number">4.8.1</span> The Error Function
            Model</a></li>
            <li><a href="#practice-exercise"><span
            class="toc-section-number">4.8.2</span> Practice
            Exercise</a></li>
            </ul></li>
            </ul></li>
            <li><a
            href="#introduction-to-python-for-data-acquisition"><span
            class="toc-section-number">5</span> Introduction to Python
            for Data Acquisition</a>
            <ul>
            <li><a href="#development-environment"><span
            class="toc-section-number">5.1</span> Development
            Environment</a></li>
            <li><a
            href="#connect-the-usb-6009-and-verify-it-is-working"><span
            class="toc-section-number">5.2</span> Connect the USB-6009
            and verify it is working</a></li>
            <li><a href="#reading-multiple-samples"><span
            class="toc-section-number">5.3</span> Reading Multiple
            Samples</a>
            <ul>
            <li><a
            href="#understanding-sample-rate-and-samples-to-read"><span
            class="toc-section-number">5.3.1</span> Understanding Sample
            Rate and Samples to Read</a></li>
            <li><a href="#sec:analogmeas"><span
            class="toc-section-number">5.3.2</span> Acquiring Multiple
            Samples</a></li>
            <li><a href="#exercise-capture-a-waveform"><span
            class="toc-section-number">5.3.3</span> Exercise: Capture a
            Waveform</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#digital-sampling-and-nyquist-frequency"><span
            class="toc-section-number">6</span> Digital Sampling and
            Nyquist Frequency</a>
            <ul>
            <li><a href="#exploring-sample-rate-effects"><span
            class="toc-section-number">6.1</span> Exploring Sample Rate
            Effects</a></li>
            <li><a href="#initial-measurements"><span
            class="toc-section-number">6.2</span> Initial
            Measurements</a></li>
            <li><a href="#enhanced-understanding"><span
            class="toc-section-number">6.3</span> Enhanced
            Understanding</a></li>
            <li><a href="#nyquist-frequency"><span
            class="toc-section-number">6.4</span> Nyquist Frequency</a>
            <ul>
            <li><a href="#aliasing-exercises"><span
            class="toc-section-number">6.4.1</span> Aliasing
            Exercises</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#noise-floor-characterization"><span
            class="toc-section-number">7</span> Noise Floor
            Characterization</a>
            <ul>
            <li><a href="#phase-1-configuration-discovery"><span
            class="toc-section-number">7.1</span> Phase 1: Configuration
            Discovery</a>
            <ul>
            <li><a href="#setup"><span
            class="toc-section-number">7.1.1</span> Setup</a></li>
            <li><a
            href="#discovery-1-configuration-must-match-wiring"><span
            class="toc-section-number">7.1.2</span> Discovery 1:
            Configuration Must Match Wiring</a></li>
            <li><a href="#discovery-2-voltage-range"><span
            class="toc-section-number">7.1.3</span> Discovery 2: Voltage
            Range</a></li>
            <li><a href="#what-you-discovered"><span
            class="toc-section-number">7.1.4</span> What You
            Discovered</a></li>
            <li><a href="#configuration-for-this-lab"><span
            class="toc-section-number">7.1.5</span> Configuration for
            This Lab</a></li>
            </ul></li>
            <li><a href="#phase-2-what-limits-your-measurement"><span
            class="toc-section-number">7.2</span> Phase 2: What Limits
            Your Measurement?</a>
            <ul>
            <li><a href="#prediction"><span
            class="toc-section-number">7.2.1</span> Prediction</a></li>
            <li><a href="#measurement"><span
            class="toc-section-number">7.2.2</span> Measurement</a></li>
            <li><a href="#confront-your-prediction"><span
            class="toc-section-number">7.2.3</span> Confront Your
            Prediction</a></li>
            <li><a href="#the-implication-for-gain-selection"><span
            class="toc-section-number">7.2.4</span> The Implication for
            Gain Selection</a></li>
            </ul></li>
            <li><a href="#phase-3-gain-selection-for-week-4"><span
            class="toc-section-number">7.3</span> Phase 3: Gain
            Selection for Week 4</a></li>
            <li><a href="#looking-ahead"><span
            class="toc-section-number">7.4</span> Looking Ahead</a></li>
            <li><a href="#optional-oscilloscope-comparison"><span
            class="toc-section-number">7.5</span> Optional: Oscilloscope
            Comparison</a></li>
            </ul></li>
            <li><a href="#saving-data-and-additional-daq-features"><span
            class="toc-section-number">8</span> Saving Data and
            Additional DAQ Features</a>
            <ul>
            <li><a href="#saving-data-to-a-file"><span
            class="toc-section-number">8.1</span> Saving Data to a
            File</a>
            <ul>
            <li><a href="#exercise-save-and-reload-data"><span
            class="toc-section-number">8.1.1</span> Exercise: Save and
            Reload Data</a></li>
            </ul></li>
            <li><a href="#generating-an-analog-output"><span
            class="toc-section-number">8.2</span> Generating an Analog
            Output</a>
            <ul>
            <li><a href="#exercise-test-analog-output"><span
            class="toc-section-number">8.2.1</span> Exercise: Test
            Analog Output</a></li>
            </ul></li>
            <li><a href="#error-handling"><span
            class="toc-section-number">8.3</span> Error
            Handling</a></li>
            </ul></li>
            <li><a href="#summary"><span
            class="toc-section-number">9</span> Summary</a></li>
            <li><a href="#deliverables-and-assessment"><span
            class="toc-section-number">10</span> Deliverables and
            Assessment</a>
            <ul>
            <li><a href="#prelab-complete-before-lab"><span
            class="toc-section-number">10.1</span> Prelab (complete
            before lab)</a></li>
            <li><a href="#in-lab-documentation"><span
            class="toc-section-number">10.2</span> In-Lab
            Documentation</a></li>
            <li><a href="#key-data-table"><span
            class="toc-section-number">10.3</span> Key Data
            Table</a></li>
            <li><a href="#code-deliverables"><span
            class="toc-section-number">10.4</span> Code
            Deliverables</a></li>
            <li><a href="#reflection-questions"><span
            class="toc-section-number">10.5</span> Reflection
            Questions</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="where-we-are-in-the-sequence"><span
         class="header-section-number">1</span> Where We Are in the
         Sequence</h1>
         <p><strong>Week 2 of 4: Instrumentation and Noise
         Characterization</strong></p>
         <p>Last week you calibrated your photodetector and learned to
         measure beam width manually. This week you’ll learn
         Python-based data acquisition and—critically—characterize your
         measurement system’s noise floor. Your goal: make a
         quantitative, evidence-based decision about which gain setting
         to use for Week 4’s automated measurements.</p>
         <p><strong>Last week:</strong> Aligned optics, calibrated
         photodetector, measured beam width manually</p>
         <p><strong>This week:</strong> Learn DAQ programming →
         Characterize measurement system noise → Choose optimal gain
         setting</p>
         <p><strong>Next week:</strong> Learn Gaussian beam theory → Set
         up motor controller → Take first automated measurement</p>
         <h1 data-number="2" id="overview"><span
         class="header-section-number">2</span> Overview</h1>
         <p>The second week of the Gaussian Beams lab introduces you to
         Python for data acquisition and guides you through interfacing
         Python with the instrumentation and data acquisition systems
         used in this course. You will also learn about digital sampling
         theory and characterize your measurement system’s noise floor—a
         critical step for making informed measurement decisions in Week
         4.</p>
         <p><strong>An important discovery awaits:</strong> The DAQ
         device that records your data has its own noise floor—and this
         is what actually limits your Week 4 measurements. Every
         instrument has limitations. Expert experimentalists
         characterize those limitations and design around them. This
         week, you’ll do exactly that.</p>
         <p>This week’s lab is divided into two parts. In part 1
         (Prelab), you will learn essential curve fitting techniques
         that you’ll use throughout this course. In part 2 (Lab), you
         will learn Python programming for data acquisition using a
         National Instruments DAQ device, the <a
         href="https://www.ni.com/docs/en-US/bundle/usb-6009-specs/page/specs.html">NI
         USB-6009</a>. This multifunction USB powered device has 8
         single-ended (4 differential) analog inputs (14-bit, 48 kS/s),
         2 analog outputs (12-bit, 150 S/s), 12 digital I/O channels,
         and a 32-bit counter. You will then apply these DAQ skills to
         characterize your measurement system’s noise floor and make a
         quantitative decision about optimal gain settings.</p>
         <h2 data-number="2.1" id="what-is-python"><span
         class="header-section-number">2.1</span> What is Python?</h2>
         <p>Python is a versatile programming language widely used in
         scientific computing and data analysis. Many research labs use
         Python for instrument control, data acquisition, and analysis.
         Its advantages include:</p>
         <ul>
         <li>Free and open source</li>
         <li>Extensive scientific libraries (NumPy, SciPy,
         Matplotlib)</li>
         <li>Large community with excellent documentation</li>
         <li>Easy to learn and read</li>
         <li>Works on all major operating systems</li>
         </ul>
         <p>You can use Python on the lab laptops where it is already
         installed. See the <a href="/PHYS-4430/python-resources">Python
         Resources</a> page for installation instructions if you want to
         set it up on your own computer.</p>
         <h2 data-number="2.2" id="learning-goals"><span
         class="header-section-number">2.2</span> Learning Goals</h2>
         <p>After completing the prelab, you will be able to:</p>
         <ol type="1">
         <li>Explain why we minimize the sum of squares to get the best
         fit.</li>
         <li>Carry out a least-squares minimization graphically.</li>
         <li>Plot residuals to visually inspect the goodness of a
         fit.</li>
         <li>Interpret the uncertainty in fit parameters from
         <code>scipy.optimize.curve_fit</code>.</li>
         <li>Compute <span class="math inline">\(\chi^2\)</span> for a
         fit and use it to determine if a fit is “good”.</li>
         <li>Create plots with error bars using Matplotlib.</li>
         </ol>
         <p>After completing the lab, you will be able to:</p>
         <ol type="1">
         <li>Connect a USB DAQ device to a computer and confirm the
         analog inputs are working correctly.</li>
         <li>Write a Python script to read analog voltage
         measurements.</li>
         <li>Configure sample rate and number of samples for data
         acquisition.</li>
         <li>Explain Nyquist’s theorem and choose appropriate sample
         rates.</li>
         <li>Recognize aliasing and understand its causes.</li>
         <li>Measure the DAQ noise floor and compare to datasheet
         specifications.</li>
         <li>Identify which component (photodetector or DAQ) limits your
         measurement system’s noise.</li>
         <li>Calculate signal-to-noise ratio and explain why gain
         improves SNR despite a fixed DAQ noise floor.</li>
         <li>Select and justify an optimal gain setting based on
         quantitative analysis.</li>
         <li>Confront predictions with measurements and identify sources
         of discrepancies.</li>
         <li>Save acquired data to a CSV file.</li>
         </ol>
         <h1 data-number="3" id="overview-of-your-work"><span
         class="header-section-number">3</span> Overview of Your
         Work</h1>
         <p>This week culminates in a decision: <strong>which gain
         setting will you use for Week 4’s automated beam
         profiling?</strong> This isn’t arbitrary—you’ll build the
         quantitative evidence to justify your choice.</p>
         <p><strong>Prelab:</strong> Develop curve-fitting skills you’ll
         use throughout this course. You’ll learn to minimize χ²,
         interpret residuals, and assess goodness of fit. These skills
         are essential for extracting beam widths from your knife-edge
         data.</p>
         <p><strong>In Lab:</strong> You’ll work through a
         predict-measure-compare cycle for noise characterization:</p>
         <ol type="1">
         <li><strong>Learn DAQ fundamentals</strong> — Read voltages
         with Python, understand sampling theory, observe aliasing</li>
         <li><strong>Discover that configuration matters</strong> —
         Measure DAQ noise with different settings and discover that
         instrument behavior depends on configuration</li>
         <li><strong>Identify what limits your measurement</strong> —
         Predict whether the photodetector or DAQ dominates system
         noise, then measure to find out</li>
         <li><strong>Make your decision</strong> — Select a gain setting
         for Week 4 with written justification based on your data</li>
         </ol>
         <p><em>See the detailed deliverables checklist at the end of
         this guide.</em></p>
         <h1 data-number="4" id="prelab"><span
         class="header-section-number">4</span> Prelab</h1>
         <p>This week’s prelab builds on the uncertainty concepts you
         learned during Week 1’s lab (where you measured voltage
         fluctuations and calculated standard deviation). Now we move
         from estimating uncertainties in individual measurements to
         fitting data and propagating those uncertainties to derived
         quantities. This is a “user’s guide” to least-squares fitting
         and determining the goodness of your fits. At the end of the
         prelab you will be able to:</p>
         <ol type="1">
         <li>Explain why we minimize the sum of squares to get the best
         fit.</li>
         <li>Carry out a least-squares minimization graphically.</li>
         <li>Plot residuals to visually inspect the goodness of a
         fit.</li>
         <li>Interpret the uncertainty in fit parameters.</li>
         <li>Compute <span class="math inline">\(\chi^2\)</span> for a
         fit and use it to determine if a fit is “good”.</li>
         <li>Create plots with error bars using Matplotlib.</li>
         </ol>
         <h2 data-number="4.1" id="useful-readings"><span
         class="header-section-number">4.1</span> Useful readings</h2>
         <ol type="1">
         <li>Taylor, J. R. (1997). <em>An Introduction to Error
         Analysis: The Study of Uncertainties in Physical
         Measurements</em> (p. 327). University Science Books. This is
         the standard undergraduate text for measurement and
         uncertainty.</li>
         <li>Bevington, P. R., &amp; Robinson, K. D. (2003). <em>Data
         Reduction and Error Analysis for the Physical Sciences</em>
         Third Edition (3rd ed.). New York: McGraw-Hill. Great for
         advanced undergrad error analysis. Professional physicists use
         it too.</li>
         </ol>
         <h2 data-number="4.2"
         id="why-do-we-minimize-the-sum-of-squares"><span
         class="header-section-number">4.2</span> Why do we minimize the
         sum of squares?</h2>
         <p><strong>Question:</strong> Why do we call it “least-squares”
         fitting?</p>
         <p><strong>Answer:</strong> Because the best fit is determined
         by minimizing the weighted sum of squares of the deviation
         between the data and the fit. Properly speaking this “sum of
         squares” is called “chi-squared” and is given by</p>
         <p><span id="eq:1" class="eqnos"><span
         class="math display">\[\chi^2 = {\displaystyle
         \sum_{i=1}^{N}}\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \ ... \
         ))^2\text{,}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>where there are where <span class="math inline">\(N\)</span>
         data points, <span class="math inline">\((x_i,y_i )\)</span>,
         and the fit function is given by <span
         class="math inline">\(y(x_i,a,b,c, \ … \ )\)</span> where <span
         class="math inline">\(a, b,\)</span> etc. are the fit
         parameters.</p>
         <p><strong>Question:</strong> What assumptions are made for the
         method to be valid?</p>
         <p><strong>Answer:</strong> The two assumptions are:</p>
         <ol type="1">
         <li><strong>Gaussian distributed.</strong> The random
         fluctuations in each data point <span
         class="math inline">\(y_i\)</span> are Gaussian distributed
         with standard deviation <span
         class="math inline">\(\sigma_i\)</span>.</li>
         <li><strong>Uncorrelated.</strong> The random fluctuations in
         any one data point are uncorrelated with those in another data
         point.</li>
         </ol>
         <p><strong>Question:</strong> Why does minimizing the sum of
         squares give us the best fit?</p>
         <p><strong>Answer:</strong> Given the two above assumptions,
         the fit that minimizes the sum of squares is the
         <strong><em>most likely</em></strong> function to produce the
         observed data. This can be proven using a little calculus and
         probability. A more detailed explanation is found in Taylor’s
         <em>Introduction to Error Analysis</em> Sec. 5.5 “Justification
         of the Mean as Best Estimate” or Bevington and Robinson’s
         <em>Data Reduction</em> Sec. 4.1 “Method of Least-Squares”.</p>
         <h2 data-number="4.3" id="sec:min-graph"><span
         class="header-section-number">4.3</span> Minimizing <span
         class="math inline">\(\chi^2\)</span> graphically</h2>
         <p><em>You will rarely minimize <span
         class="math inline">\(\chi^2\)</span> graphically in a lab.
         However, this exercise will help you better understand what
         fitting routines actually do to find the best fit.</em></p>
         <ol type="1">
         <li><p>Download and plot <a
         href="../resources/lab-guides/gaussian-laser-beams/profile_data_without_errors.csv">this
         data set</a>. It was generated by inserting a razor blade into
         path of a laser beam and measuring the photodetector voltage of
         the laser light. The <span class="math inline">\(x\)</span>
         column is the micrometer (razor) position in meters and the
         <span class="math inline">\(y\)</span> column is the
         photodetector voltage in volts.</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the data</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;profile_data_without_errors.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>x_data <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>y_data <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_data, y_data, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (m)&#39;</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Define the same fit function as:</p>
         <p><span class="math display">\[y(x,a,b,c,w) = a \
         Erf\left(\frac{\sqrt{2}}{w}(x-b)\right)+c\]</span></p>
         <p>In Python, this can be written using
         <code>scipy.special.erf</code>:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beam_profile(x, amplitude, center, width, offset):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">        x: position (m)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">        amplitude: half the voltage swing (V)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">        center: beam center position (m)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">        width: beam width w (m)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">        offset: vertical offset (V)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> amplitude <span class="op">*</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> (x <span class="op">-</span> center) <span class="op">/</span> width) <span class="op">+</span> offset</span></code></pre></div></li>
         <li><p>Reduce the fit to two free parameters. This step is only
         necessary because it is hard to visualize more than 3
         dimensions. Assume <span
         class="math inline">\(a_{fit}=(V_{max}-V_{min})/2 =
         1.4375\)</span> and <span class="math inline">\(c_{fit}
         =(V_{max}+V_{min})/2 = 1.45195\)</span>. These were determined
         by averaging the first 6 data points to get <span
         class="math inline">\(V_{min}\)</span> and the last 5 to get
         <span class="math inline">\(V_{max}\)</span>.</p></li>
         <li><p>Use Equation <a href="#eq:1">1</a> to write an
         expression for <span class="math inline">\(\chi^2\)</span> in
         terms of your <span class="math inline">\(w\)</span> and <span
         class="math inline">\(b\)</span> parameters, and the <span
         class="math inline">\(x\)</span> (position) data and <span
         class="math inline">\(y\)</span> (voltage) data. Since you
         don’t have any estimate for the uncertainties <span
         class="math inline">\(\sigma_i\)</span>, assume they are all
         unity so <span class="math inline">\(\sigma_i=1\)</span>.</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chi_squared(width, center, x_data, y_data, amplitude_fixed, offset_fixed):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Calculate chi-squared for given parameters.&quot;&quot;&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    y_fit <span class="op">=</span> beam_profile(x_data, amplitude_fixed, center, width, offset_fixed)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>((y_data <span class="op">-</span> y_fit)<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div></li>
         <li><p><strong>Before running any code</strong>, answer these
         prediction questions in your notebook:</p>
         <ol type="1">
         <li>What shape do you expect the <span
         class="math inline">\(\chi^2\)</span> contours to have?
         (Circular? Elliptical? Irregular?) Why?</li>
         <li>If the contours are elliptical, what would it mean if the
         ellipse is tilted (major axis not aligned with <span
         class="math inline">\(w\)</span> or <span
         class="math inline">\(b\)</span> axes)?</li>
         <li>Where in the <span class="math inline">\((w, b)\)</span>
         plane should the minimum <span
         class="math inline">\(\chi^2\)</span> occur—at the true beam
         width and position, or somewhere else?</li>
         </ol></li>
         <li><p>Make a contour plot of <span
         class="math inline">\(\chi^2(w,b)\)</span> and tweak the plot
         range until you see the minimum. You can use AI assistance or
         the code below. The goal is to <em>interpret</em> the result,
         not to write the code from scratch.</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a grid of width and center values</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>width_range <span class="op">=</span> np.linspace(<span class="fl">0.0003</span>, <span class="fl">0.0007</span>, <span class="dv">100</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>center_range <span class="op">=</span> np.linspace(<span class="fl">0.009</span>, <span class="fl">0.011</span>, <span class="dv">100</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>W, C <span class="op">=</span> np.meshgrid(width_range, center_range)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate chi-squared for each combination</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>amplitude_fixed <span class="op">=</span> <span class="fl">1.4375</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>offset_fixed <span class="op">=</span> <span class="fl">1.45195</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.zeros_like(W)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(center_range)):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(width_range)):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        Z[i, j] <span class="op">=</span> chi_squared(width_range[j], center_range[i], x_data, y_data,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                              amplitude_fixed, offset_fixed)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Make contour plot</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.contour(W <span class="op">*</span> <span class="dv">1000</span>, C <span class="op">*</span> <span class="dv">1000</span>, Z, levels<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">&#39;$</span><span class="ch">\\</span><span class="st">chi^2$&#39;</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;width (mm)&#39;</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;center (mm)&#39;</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;$</span><span class="ch">\\</span><span class="st">chi^2$ Contour Plot&#39;</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         </ol>
         <div id="fig:contour" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/contour.png"
         style="width:15cm" alt="Figure 1: Contour plot example." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Contour
         plot example.</figcaption>
         </figure>
         </div>
         <ol start="7" type="1">
         <li><p><strong>Interpretation questions</strong> (answer in
         your notebook):</p>
         <ol type="1">
         <li>Were your predictions from step 5 correct? If not, explain
         what you learned.</li>
         <li>The contours are likely elliptical and possibly tilted.
         Explain in 2-3 sentences why the parameters <span
         class="math inline">\(w\)</span> and <span
         class="math inline">\(b\)</span> might be correlated (i.e., why
         changing one affects the best value of the other).</li>
         <li>If the noise in the data were doubled, how would the
         contour plot change? Would the minimum move? Would the contours
         spread out or contract?</li>
         </ol></li>
         <li><p>Graphically determine the best fit parameters to 3
         significant digits.</p></li>
         <li><p>Compare with the best fit result from
         <code>scipy.optimize.curve_fit</code> (allow all 4 parameters
         to vary). Do the fits agree for those three digits of
         precision?</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses: [amplitude, center, width, offset]</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [<span class="fl">1.4375</span>, <span class="fl">0.01</span>, <span class="fl">0.0005</span>, <span class="fl">1.45195</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform the fit</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(beam_profile, x_data, y_data, p0<span class="op">=</span>p0)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Best fit parameters:&quot;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  amplitude = </span><span class="sc">{</span>popt[<span class="dv">0</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  center    = </span><span class="sc">{</span>popt[<span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  width     = </span><span class="sc">{</span>popt[<span class="dv">2</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  offset    = </span><span class="sc">{</span>popt[<span class="dv">3</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="4.4"
         id="uncertainty-in-the-fit-parameters"><span
         class="header-section-number">4.4</span> Uncertainty in the fit
         parameters</h2>
         <p><strong>Question:</strong> Where does the uncertainty in the
         fit parameters come from?</p>
         <p><strong>Answer:</strong> The optimal fit parameters depend
         on the data points <span
         class="math inline">\((x_i,y_i)\)</span>. The uncertainty,
         <span class="math inline">\(\sigma_i\)</span>, in the <span
         class="math inline">\(y_i\)</span> means there is a propagated
         uncertainty in the calculation of the fit parameters. The error
         propagation calculation is explained in detail in the
         references, especially Bevington and Robinson.</p>
         <p><strong>Question:</strong> How does <code>curve_fit</code>
         calculate the uncertainty in the fit parameters when no error
         estimate for the <span class="math inline">\(\sigma_i\)</span>
         is provided?</p>
         <p><strong>Answer:</strong> When no uncertainties are provided,
         <code>curve_fit</code> (and other fitting routines) estimate
         the uncertainty in the data <span
         class="math inline">\(\sigma_y^2\)</span> using the “residuals”
         of the best fit:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\sigma_y^2 = \frac{1}{N-n}{\displaystyle
         \sum_{i=1}^{N}}(y_i-y(x_i,a_0,b_0,c_0, \ ... \
         ))^2\text{,}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>where there are <span class="math inline">\(N\)</span> data
         points <span class="math inline">\(y_i\)</span> and the best
         fit value at each point is given by <span
         class="math inline">\(y\)</span>, which depends on <span
         class="math inline">\(x_i\)</span> and the <span
         class="math inline">\(n\)</span> best fit parameters <span
         class="math inline">\(a_0,b_0,c_0, \ ... \ \)</span>. It is
         very similar to how you would estimate the standard deviation
         of a repeated measurement, which for comparison’s sake is given
         by:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\sigma_y^2 = \frac{1}{N-n}{\displaystyle
         \sum_{i=1}^{N}}(y_i-\overline{y})^2\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The parameter uncertainties are then extracted from the
         covariance matrix:</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get parameter uncertainties from the covariance matrix</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Parameter uncertainties:&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_amplitude = </span><span class="sc">{</span>perr[<span class="dv">0</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_center    = </span><span class="sc">{</span>perr[<span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_width     = </span><span class="sc">{</span>perr[<span class="dv">2</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_offset    = </span><span class="sc">{</span>perr[<span class="dv">3</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <h2 data-number="4.5"
         id="estimating-the-uncertainty-in-the-data"><span
         class="header-section-number">4.5</span> Estimating the
         uncertainty in the data</h2>
         <ol type="1">
         <li><p>Use Equation <a href="#eq:2">2</a> and your best fit
         parameters to estimate <span
         class="math inline">\(\sigma_y^2\)</span>, the statistical
         error of each data point given by your data.</p>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate residuals</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>y_fit <span class="op">=</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_data <span class="op">-</span> y_fit</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate variance (N data points, n=4 parameters)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">len</span>(y_data)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>sigma_y_squared <span class="op">=</span> np.<span class="bu">sum</span>(residuals<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (N <span class="op">-</span> n)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>sigma_y <span class="op">=</span> np.sqrt(sigma_y_squared)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Estimated σ_y = </span><span class="sc">{</span>sigma_y<span class="sc">:.6f}</span><span class="ss"> V&quot;</span>)</span></code></pre></div></li>
         <li><p>Compare your result with the estimate from the fit. The
         estimated variance can be calculated from the
         residuals.</p></li>
         <li><p>Do the estimates agree? Why or why not?</p></li>
         </ol>
         <h2 data-number="4.6" id="goodness-of-fit"><span
         class="header-section-number">4.6</span> Goodness of fit</h2>
         <p>This section covers two ways to analyze if a fit is
         good.</p>
         <ol type="1">
         <li>Plotting the residuals.</li>
         <li>Doing a <span class="math inline">\(\chi^2\)</span>
         test.</li>
         </ol>
         <h3 data-number="4.6.1" id="sec:plot-res"><span
         class="header-section-number">4.6.1</span> Plotting the fit
         residuals</h3>
         <p>The first step is to look at the residuals. The residuals,
         <span class="math inline">\(r_i\)</span>, are defined as the
         difference between the data and the fit.</p>
         <p><span class="math display">\[r_i=y_i-y(x_i,a,b,c, \ ... \
         )\]</span></p>
         <ol type="1">
         <li><p>Make a plot of the residuals:</p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and plot residuals</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_data <span class="op">-</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_data, residuals)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">&#39;r&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (m)&#39;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Residuals (V)&#39;</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Fit Residuals&#39;</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Since we didn’t provide any estimates of the
         uncertainties, the fitting assumed the uncertainty of every
         point is the same. Based on the plot of residuals, was this a
         good assumption?</p></li>
         <li><p>Do the residuals look randomly scattered about zero or
         do you notice any systematic error sources?</p></li>
         <li><p>Is the distribution of residuals scattered evenly around
         zero? Or is there a particular range of <span
         class="math inline">\(x\)</span> values where the residuals are
         larger than others?</p></li>
         <li><p>What is the most likely source of the large uncertainty
         as the beam is cut near the center of the beam?</p></li>
         </ol>
         <h3 data-number="4.6.2"
         id="chi-by-eye---eyeballing-the-goodness-of-fit"><span
         class="header-section-number">4.6.2</span> “Chi by eye” -
         eyeballing the goodness of fit</h3>
         <p><strong>Question:</strong> If I have a good fit, should
         every data point lie within an error bar?</p>
         <p><strong>Answer:</strong> No. Most should, but we wouldn’t
         expect every data point to lie within an error bar. If the
         uncertainty is Gaussian distributed with a standard deviation
         <span class="math inline">\(\sigma_i\)</span> for each data
         point, <span class="math inline">\(y_i\)</span>, then we expect
         roughly 68% of the data points to lie within their error bar.
         This is because 68% of the probability in a Gaussian
         distribution lies within one standard deviation of the
         mean.</p>
         <h3 data-number="4.6.3"
         id="chi2-and-chi_red2-for-testing-the-goodness-of-fit"><span
         class="header-section-number">4.6.3</span> <span
         class="math inline">\(\chi^2\)</span> and <span
         class="math inline">\(\chi_{red}^2\)</span> for testing the
         “goodness” of fit</h3>
         <p>This section answers the question “What should <span
         class="math inline">\(\chi^2\)</span> be for a good fit?”</p>
         <p>Suppose the only uncertainty in the data is statistical
         error, with a known standard deviation <span
         class="math inline">\(\sigma_i\)</span>, then on average each
         term in the sum is</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \
         ... \ ))^2 \approx
         1\text{,}\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>and the full <span class="math inline">\(\chi^2\)</span> sum
         of squares is approximately</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\chi^2 = {\displaystyle
         \sum_{i=1}^{N}}\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \ ... \
         ))^2\approx
         N-n\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So a good fit has</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\chi_{red}^2 \equiv
         \frac{\chi^2}{N-n}\approx
         1\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <ol type="1">
         <li><strong>Fact: To find the goodness of fit test, you must
         first estimate the uncertainties on the data points that you
         are fitting.</strong> How would you explain the reason for this
         in your own words?</li>
         </ol>
         <h3 data-number="4.6.4"
         id="choosing-a-strategy-to-estimate-the-uncertainty"><span
         class="header-section-number">4.6.4</span> Choosing a strategy
         to estimate the uncertainty</h3>
         <ol type="1">
         <li><p>Considering your answers from Section <a
         href="#sec:plot-res">4.6.1</a> (especially <a
         href="#sec:plot-res">4.6.1</a>.5), which method would give you
         the best estimate of the uncertainty for each data point, and
         why?</p>
         <ul>
         <li><p>Eyeballing the fluctuations in each data point.</p></li>
         <li><p>Taking <span class="math inline">\(N\)</span>
         measurements at each razor position and then going to the next
         position.</p></li>
         <li><p>Taking the entire data set <span
         class="math inline">\(N\)</span> times.</p></li>
         </ul></li>
         </ol>
         <h3 data-number="4.6.5" id="weighted-fits"><span
         class="header-section-number">4.6.5</span> Weighted fits</h3>
         <p>When you have estimated the uncertainty <span
         class="math inline">\(\sigma_i\)</span> of each data point
         <span class="math inline">\(y_i\)</span> you should use this
         information when fitting to correctly evaluate the <span
         class="math inline">\(\chi^2\)</span> expression in Equation <a
         href="#eq:1">1</a>. The points with high uncertainty contribute
         less information when choosing the best fit parameters.</p>
         <p>In Python’s <code>curve_fit</code>, you provide
         uncertainties using the <code>sigma</code> parameter:</p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Weighted fit with known uncertainties</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    beam_profile,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    x_data,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    y_data,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    p0<span class="op">=</span>p0,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>sigma_list,        <span class="co"># Your uncertainty estimates</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    absolute_sigma<span class="op">=</span><span class="va">True</span>      <span class="co"># Use actual sigma values (not relative)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
         <ol type="1">
         <li><p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/profile_data_with_errors.csv">this
         data set</a> for a beam width measurement with uncertainties.
         The first column is razor position in meters, the second column
         is photodetector output voltage, and the third column is the
         uncertainty on the photodetector output voltage.</p>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data with uncertainties</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;profile_data_with_errors.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>x_data <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>y_data <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>y_err <span class="op">=</span> data[:, <span class="dv">2</span>]</span></code></pre></div></li>
         <li><p>Do a weighted fit using the same fit function as in
         Section <a href="#sec:min-graph">4.3</a>. Use the uncertainty
         estimates in the third column.</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Weighted fit</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    beam_profile, x_data, y_data,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    p0<span class="op">=</span>[<span class="fl">1.4</span>, <span class="fl">0.01</span>, <span class="fl">1.45</span>, <span class="fl">0.0005</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>y_err,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    absolute_sigma<span class="op">=</span><span class="va">True</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span></code></pre></div></li>
         <li><p>Calculate <span
         class="math inline">\(\chi^2\)</span>:</p>
         <div class="sourceCode" id="cb12"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate chi-squared</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>y_fit <span class="op">=</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>chi2 <span class="op">=</span> np.<span class="bu">sum</span>(((y_data <span class="op">-</span> y_fit) <span class="op">/</span> y_err)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>dof <span class="op">=</span> <span class="bu">len</span>(y_data) <span class="op">-</span> <span class="bu">len</span>(popt)  <span class="co"># degrees of freedom</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>chi2_red <span class="op">=</span> chi2 <span class="op">/</span> dof</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Chi-squared: </span><span class="sc">{</span>chi2<span class="sc">:.2f}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Degrees of freedom: </span><span class="sc">{</span>dof<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Reduced chi-squared: </span><span class="sc">{</span>chi2_red<span class="sc">:.2f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         <li><p>How close is the reduced chi-squared to 1?</p></li>
         <li><p><strong>The “chi-squared test”.</strong> This part helps
         us understand if the value of <span
         class="math inline">\(\chi^2\)</span> is statistically likely
         or not. The following graph gives the probability of exceeding
         a particular value of <span
         class="math inline">\(\chi^2\)</span> for <span
         class="math inline">\(\nu=𝑁−𝑛=22\)</span> degrees of freedom.
         It can be calculated using the Cumulative Density Function
         (CDF) for the chi-squared distribution. Use the graph to
         estimate the likelihood this value of <span
         class="math inline">\(\chi^2\)</span> occurred by chance.</p>
         <div class="sourceCode" id="cb13"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate p-value (probability of getting this chi2 or higher by chance)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stats.chi2.cdf(chi2, dof)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;P-value: </span><span class="sc">{</span>p_value<span class="sc">:.4f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <div id="fig:cdf" class="fignos">
         <figure>
         <img src="../resources/lab-guides/gaussian-laser-beams/cdf.png"
         style="width:15cm"
         alt="Figure 2: Cumulative Density Function (CDF) for the chi-squared distribution." />
         <figcaption aria-hidden="true"><span>Figure 2:</span>
         Cumulative Density Function (CDF) for the chi-squared
         distribution.</figcaption>
         </figure>
         </div>
         <h3 data-number="4.6.6"
         id="why-is-it-often-bad-to-overestimate-uncertainties"><span
         class="header-section-number">4.6.6</span> Why is it often bad
         to overestimate uncertainties?</h3>
         <ol type="1">
         <li>Why can overestimating the uncertainty make your fit appear
         good (i.e., <span
         class="math inline">\(\frac{\chi^2}{N-n}\approx
         1\)</span>)?</li>
         </ol>
         <p>Overestimating the uncertainties makes the fit seem good
         (according to a <span class="math inline">\(\chi^2\)</span>
         test), even when it might be obviously a bad fit. It is best to
         do the <span class="math inline">\(\chi^2\)</span> test using
         an honest estimate of your uncertainties. If the <span
         class="math inline">\(\chi^2\)</span> is larger than expected
         <span class="math inline">\((\chi^2&gt;𝑁−𝑛)\)</span>, then you
         should consider both the possibility of systematic error
         sources and the quality of your estimates of the uncertainties.
         On the other hand, if the <span
         class="math inline">\(\chi^2\)</span> test is good <span
         class="math inline">\((\chi^2\approx 𝑁−𝑛)\)</span>, then it
         shows you have a good handle on the model of your system, and
         your sources of uncertainty. Finally, if <span
         class="math inline">\(\chi^2\ll (𝑁−𝑛)\)</span>, this likely
         indicates overestimated uncertainties.</p>
         <h3 data-number="4.6.7"
         id="when-does-curve_fit-underestimate-the-true-uncertainty"><span
         class="header-section-number">4.6.7</span> When does
         <code>curve_fit</code> underestimate the true uncertainty?</h3>
         <p>The uncertainty reported by <code>curve_fit</code> comes
         from the covariance matrix and assumes:</p>
         <ol type="1">
         <li>The only source of error is statistical noise in your
         voltage measurements</li>
         <li>This noise is independent for each data point</li>
         <li>Your model perfectly describes the underlying physics</li>
         </ol>
         <p>In real experiments, these assumptions often fail. Consider
         these scenarios relevant to your beam width measurements:</p>
         <p><strong>Systematic errors in position:</strong> - If your
         micrometer has a 0.01 mm systematic offset, this affects all
         measurements the same way - <code>curve_fit</code> doesn’t know
         about this, so it can’t include it in the parameter uncertainty
         - The true uncertainty in beam width includes uncertainty in
         position calibration</p>
         <p><strong>Model limitations:</strong> - The error function
         model assumes a perfectly Gaussian beam - Real laser beams may
         have slight deviations from Gaussian - The fit uncertainty
         assumes the model is exact</p>
         <p><strong>Correlated noise:</strong> - If 60 Hz interference
         affects multiple adjacent points similarly, they’re not
         independent - <code>curve_fit</code> assumes independent
         errors, so it underestimates uncertainty</p>
         <p><strong>Reflection questions:</strong></p>
         <ol type="1">
         <li><p>Under what conditions might the <code>curve_fit</code>
         uncertainty be a good estimate of your true measurement
         uncertainty?</p></li>
         <li><p>In Week 4, you’ll extract beam waist <span
         class="math inline">\(w_0\)</span> from fits at multiple
         positions. Besides statistical noise in voltage measurements,
         what other sources of uncertainty should you consider? List at
         least two.</p></li>
         </ol>
         <h3 data-number="4.6.8"
         id="statistical-vs.-systematic-uncertainties"><span
         class="header-section-number">4.6.8</span> Statistical
         vs. Systematic Uncertainties</h3>
         <p>Understanding the distinction between statistical and
         systematic uncertainties is crucial for proper error analysis.
         This distinction becomes especially important in Week 4 when
         you construct an uncertainty budget.</p>
         <p><strong>Statistical uncertainties</strong> (also called
         “random uncertainties”) are unpredictable fluctuations that
         vary from measurement to measurement. They average out over
         many measurements—take 100 readings and compute the mean, and
         the statistical uncertainty in that mean decreases by <span
         class="math inline">\(\sqrt{100} = 10\)</span>.</p>
         <p>Examples from this lab: - Voltage noise on the photodetector
         (varies each reading) - Thermal fluctuations in electronic
         components - Shot noise from photon arrival times</p>
         <p><strong>Systematic uncertainties</strong> are consistent
         biases that affect all measurements the same way. They do NOT
         average out—take 100 readings and the systematic error remains
         exactly the same.</p>
         <p>Examples from this lab: - Micrometer calibration offset (if
         it reads 0.02 mm high, ALL positions are 0.02 mm high) - DAQ
         voltage offset (shifts all readings by a fixed amount) - Beam
         not perfectly perpendicular to knife edge (consistent
         underestimate of width)</p>
         <p><strong>Why this matters for fitting:</strong></p>
         <p><code>curve_fit</code> only sees statistical scatter around
         your fit function. It has no way to detect systematic offsets.
         If your micrometer is miscalibrated by 0.1 mm, the fit will
         find parameters that are systematically shifted, and
         <code>curve_fit</code> will not include this in the reported
         uncertainty.</p>
         <p><strong>Quick self-test:</strong> Classify each of these as
         statistical (St) or systematic (Sy):</p>
         <ol type="1">
         <li>The photodetector gain knob is actually at 28 dB when the
         label says 30 dB: _____</li>
         <li>60 Hz pickup causing voltage fluctuations: _____</li>
         <li>The laser power slowly drifting over 30 minutes: _____
         (tricky—think about whether it averages out)</li>
         <li>Room lights flickering: _____</li>
         </ol>
         <p><em>Answers: 1=Sy, 2=St (if averaging over many cycles),
         3=Sy (drift is correlated, doesn’t average out), 4=St</em></p>
         <p>In Week 4, when you construct your uncertainty budget, you
         will need to identify the dominant sources of both statistical
         AND systematic uncertainty, and combine them appropriately.</p>
         <h2 data-number="4.7" id="error-bars"><span
         class="header-section-number">4.7</span> Error bars</h2>
         <p>The error bar is a graphical way to display the uncertainty
         in a measurement. In order to put error bars on a plot you must
         first estimate the error for each point. Anytime you include
         error bars in a plot you should explain how the uncertainty in
         each point was estimated (e.g., you “eyeballed” the
         uncertainty, or you sampled it <span
         class="math inline">\(N\)</span> times and took the standard
         deviation of the mean, etc.)</p>
         <h3 data-number="4.7.1"
         id="error-bars-in-python-with-matplotlib"><span
         class="header-section-number">4.7.1</span> Error bars in Python
         with Matplotlib</h3>
         <p>Creating plots with error bars in Python is straightforward
         using <code>plt.errorbar()</code>:</p>
         <div class="sourceCode" id="cb14"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data with uncertainties</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;gaussian_data_with_errors.txt&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> data[:, <span class="dv">0</span>]      <span class="co"># Position</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[:, <span class="dv">1</span>]      <span class="co"># Voltage</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>y_err <span class="op">=</span> data[:, <span class="dv">2</span>]  <span class="co"># Uncertainty</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plot with error bars</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.errorbar(x, y, yerr<span class="op">=</span>y_err, fmt<span class="op">=</span><span class="st">&#39;o&#39;</span>, capsize<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="st">&#39;Data with uncertainties&#39;</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Micrometer Position (inches)&#39;</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Photodetector Voltage (V)&#39;</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Gaussian Beam Width Measurement&#39;</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <p>The <code>errorbar()</code> function parameters: -
         <code>x</code>, <code>y</code>: Data points -
         <code>yerr</code>: Uncertainty values (can also use
         <code>xerr</code> for horizontal error bars) -
         <code>fmt='o'</code>: Marker style (circles) -
         <code>capsize=3</code>: Size of error bar caps</p>
         <h3 data-number="4.7.2"
         id="example-gaussian-laser-beam-width-measurement"><span
         class="header-section-number">4.7.2</span> Example: Gaussian
         laser beam width measurement</h3>
         <p>Suppose you had estimated the uncertainty at every point in
         a width measurement of your Gaussian laser beam to be <span
         class="math inline">\(0.04 \ V\)</span>. This error was chosen
         to demonstrate the mechanics of making a plot with error bars,
         but the uncertainty in the actual data was probably smaller
         than this.</p>
         <center>
         <div id="tbl:example-data" class="tablenos">
         <table id="tbl:example-data">
         <caption><span>Table 1:</span> Table of data with a fixed
         uncertainty used to illustrate creating plots with error bars.
         </caption>
         <colgroup>
         <col style="width: 35%" />
         <col style="width: 32%" />
         <col style="width: 32%" />
         </colgroup>
         <thead>
         <tr class="header">
         <th style="text-align: center;">Micrometer Position
         (inches)</th>
         <th style="text-align: center;">Photodetector Voltage (V)</th>
         <th style="text-align: center;">Estimated uncertainty (V)</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td style="text-align: center;">0.410</td>
         <td style="text-align: center;">0.015</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.412</td>
         <td style="text-align: center;">0.016</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.414</td>
         <td style="text-align: center;">0.017</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.416</td>
         <td style="text-align: center;">0.026</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.418</td>
         <td style="text-align: center;">0.060</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.420</td>
         <td style="text-align: center;">0.176</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.422</td>
         <td style="text-align: center;">0.460</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.424</td>
         <td style="text-align: center;">0.849</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.426</td>
         <td style="text-align: center;">1.364</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.428</td>
         <td style="text-align: center;">1.971</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.430</td>
         <td style="text-align: center;">2.410</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.432</td>
         <td style="text-align: center;">2.703</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.434</td>
         <td style="text-align: center;">2.795</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.436</td>
         <td style="text-align: center;">2.861</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="odd">
         <td style="text-align: center;">0.438</td>
         <td style="text-align: center;">2.879</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr class="even">
         <td style="text-align: center;">0.440</td>
         <td style="text-align: center;">2.884</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         </tbody>
         </table>
         </div>
         </center>
         <p><br></p>
         <p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/gaussian_data_with_errors.txt">this
         data set</a> and create a plot with error bars like Figure <a
         href="#fig:gauss-example">3</a>.</p>
         <div class="sourceCode" id="cb15"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;gaussian_data_with_errors.txt&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>voltage <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>uncertainty <span class="op">=</span> data[:, <span class="dv">2</span>]</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plot</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.errorbar(position, voltage, yerr<span class="op">=</span>uncertainty,</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>             fmt<span class="op">=</span><span class="st">&#39;o&#39;</span>, capsize<span class="op">=</span><span class="dv">3</span>, markersize<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (inches)&#39;</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Photodetector Output (V)&#39;</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Gaussian Beam Width Measurement&#39;</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <div id="fig:gauss-example" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-example.png"
         style="width:15cm"
         alt="Figure 3: Plot of the provided Gaussian Beam data showing error bars." />
         <figcaption aria-hidden="true"><span>Figure 3:</span> Plot of
         the provided Gaussian Beam data showing error
         bars.</figcaption>
         </figure>
         </div>
         <h2 data-number="4.8"
         id="prelab-exercise-error-function-fitting-practice"><span
         class="header-section-number">4.8</span> Prelab Exercise: Error
         Function Fitting Practice</h2>
         <p>Now that you understand curve fitting, apply it to beam
         width analysis. This exercise prepares you for analyzing your
         own knife-edge measurements.</p>
         <p><strong>Note on AI assistance:</strong> You may use AI tools
         to help write your curve fitting code. However, the learning
         goal is to understand what the code does and why. Be prepared
         to explain: (1) what the fit parameters mean physically, (2)
         why the error function is the appropriate model, and (3) how to
         interpret the uncertainties reported by
         <code>curve_fit</code>.</p>
         <h3 data-number="4.8.1" id="the-error-function-model"><span
         class="header-section-number">4.8.1</span> The Error Function
         Model</h3>
         <p>In Week 1, you derived that blocking a Gaussian beam with a
         knife edge produces a signal described by:</p>
         <p><span class="math display">\[P(x) = \frac{P_0}{2}\left[1 +
         \text{erf}\left(\frac{\sqrt{2}(x-x_0)}{w}\right)\right]\]</span></p>
         <p>where <span class="math inline">\(w\)</span> is the beam
         width, <span class="math inline">\(x_0\)</span> is the beam
         center position, and <span class="math inline">\(P_0\)</span>
         is the total power.</p>
         <p>For fitting, we use a slightly more general form that
         accounts for offsets:</p>
         <p><span class="math display">\[y(x) = a \cdot
         \text{erf}\left(\frac{\sqrt{2}}{w}(x-b)\right) + c\]</span></p>
         <p>where: - <span class="math inline">\(a\)</span> = amplitude
         (half the voltage swing) - <span
         class="math inline">\(b\)</span> = beam center position - <span
         class="math inline">\(w\)</span> = beam width (what we want!) -
         <span class="math inline">\(c\)</span> = vertical offset</p>
         <h3 data-number="4.8.2" id="practice-exercise"><span
         class="header-section-number">4.8.2</span> Practice
         Exercise</h3>
         <p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/Test_Profile_Data.csv">Test_Profile_Data.csv</a>
         and complete the following:</p>
         <ol type="1">
         <li><p><strong>Plot the raw data</strong> (position
         vs. voltage). Does it look like an error function?</p></li>
         <li><p><strong>Define the fit function</strong> (same as used
         earlier):</p>
         <div class="sourceCode" id="cb16"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beam_profile(x, amplitude, center, width, offset):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">        x: position (m)</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">        amplitude: half the voltage swing (V)</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co">        center: beam center position (m)</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">        width: beam width w (m)</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">        offset: vertical offset (V)</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> amplitude <span class="op">*</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> (x <span class="op">-</span> center) <span class="op">/</span> width) <span class="op">+</span> offset</span></code></pre></div></li>
         <li><p><strong>Perform the fit:</strong></p>
         <div class="sourceCode" id="cb17"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;Test_Profile_Data.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> data[:, <span class="dv">0</span>]  <span class="co"># Position (m)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[:, <span class="dv">1</span>]  <span class="co"># Voltage (V)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses (estimate from your plot)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Order: [amplitude, center, width, offset]</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [<span class="fl">1.0</span>, <span class="fl">0.001</span>, <span class="fl">0.0005</span>, <span class="fl">0.5</span>]</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(beam_profile, x, y, p0<span class="op">=</span>p0)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))  <span class="co"># Standard errors</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam width w = </span><span class="sc">{</span>popt[<span class="dv">2</span>]<span class="sc">:.2e}</span><span class="ss"> ± </span><span class="sc">{</span>perr[<span class="dv">2</span>]<span class="sc">:.2e}</span><span class="ss"> m&quot;</span>)</span></code></pre></div></li>
         <li><p><strong>Verify your result:</strong> You should get
         <span class="math inline">\(w = 4.52 \times 10^{-4}\)</span> m
         (approximately 0.45 mm).</p></li>
         <li><p><strong>Plot data and fit together</strong> to verify
         the fit is reasonable.</p></li>
         <li><p><strong>Interpret the uncertainties:</strong> What is
         the fractional uncertainty in your beam width? Is this
         uncertainty dominated by statistical noise or could there be
         systematic effects?</p></li>
         </ol>
         <p><em>Save your fitting code—you will use this same procedure
         to analyze your own knife-edge data in lab.</em></p>
         <h1 data-number="5"
         id="introduction-to-python-for-data-acquisition"><span
         class="header-section-number">5</span> Introduction to Python
         for Data Acquisition</h1>
         <p>In this part of the lab, you will learn to use Python for
         data acquisition. We’ll use the <code>nidaqmx</code> library to
         interface with National Instruments DAQ devices.</p>
         <h2 data-number="5.1" id="development-environment"><span
         class="header-section-number">5.1</span> Development
         Environment</h2>
         <p>For this lab, we recommend starting with <strong>Jupyter
         Notebook</strong> for interactive exploration, then
         transitioning to <strong>VS Code</strong> or another editor for
         writing reusable scripts. See the <a
         href="/PHYS-4430/python-resources">Python Resources</a> page
         for setup instructions.</p>
         <h2 data-number="5.2"
         id="connect-the-usb-6009-and-verify-it-is-working"><span
         class="header-section-number">5.2</span> Connect the USB-6009
         and verify it is working</h2>
         <ol type="1">
         <li><p>Ensure the NI-DAQmx drivers are installed (they should
         already be on lab computers). If needed, download from <a
         href="https://www.ni.com/en-us/support/downloads/drivers/download.ni-daq-mx.html">NI-DAQmx</a>.</p></li>
         <li><p>Connect the USB cable to your computer and the
         USB-6009.</p></li>
         <li><p>Open NI Measurement &amp; Automation Explorer (NI-MAX)
         to verify the device is recognized:</p>
         <ul>
         <li>The device should appear under “Devices and
         Interfaces”</li>
         <li>Right-click and run “Self-Test” to verify the
         connection</li>
         <li>Open the “Test Panel” to test analog inputs manually</li>
         </ul></li>
         <li><p>Use Python to list available DAQ devices:</p>
         <div class="sourceCode" id="cb18"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.system <span class="im">import</span> System</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># List all connected DAQ devices</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> System.local()</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> device <span class="kw">in</span> system.devices:</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Device: </span><span class="sc">{</span>device<span class="sc">.</span>name<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Product Type: </span><span class="sc">{</span>device<span class="sc">.</span>product_type<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  AI Channels: </span><span class="sc">{</span>[ch.name <span class="cf">for</span> ch <span class="kw">in</span> device.ai_physical_chans]<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         <li><p>Connect the 5V power rail to <code>AI0+</code> and
         ground to <code>AI0-</code>. You must connect both wires since
         the device measures a potential difference between the two
         terminals.</p></li>
         <li><p>Read a voltage to verify the connection:</p>
         <div class="sourceCode" id="cb19"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    voltage <span class="op">=</span> task.read()</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Measured voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="5.3" id="reading-multiple-samples"><span
         class="header-section-number">5.3</span> Reading Multiple
         Samples</h2>
         <p>To capture time-varying signals, you need to configure the
         sample rate and number of samples.</p>
         <h3 data-number="5.3.1"
         id="understanding-sample-rate-and-samples-to-read"><span
         class="header-section-number">5.3.1</span> Understanding Sample
         Rate and Samples to Read</h3>
         <p>When acquiring data, you must specify:</p>
         <ul>
         <li><strong>Sample Rate</strong>: How many samples per second
         (Hz)</li>
         <li><strong>Samples to Read</strong>: Total number of samples
         to acquire</li>
         </ul>
         <p>For example, to capture 5 periods of a 1 kHz sine wave with
         20 samples per period:</p>
         <ul>
         <li>Samples to Read = 5 periods × 20 samples/period = 100
         samples</li>
         <li>Total time = 5 periods / 1000 Hz = 5 ms</li>
         <li>Sample Rate = 100 samples / 0.005 s = 20,000 Hz</li>
         </ul>
         <h3 data-number="5.3.2" id="sec:analogmeas"><span
         class="header-section-number">5.3.2</span> Acquiring Multiple
         Samples</h3>
         <div class="sourceCode" id="cb20"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">20000</span>  <span class="co"># Hz</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>samples_to_read <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Acquire data</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    task.timing.cfg_samp_clk_timing(</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        rate<span class="op">=</span>sample_rate,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        samps_per_chan<span class="op">=</span>samples_to_read</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>samples_to_read)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Create time array</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(samples_to_read) <span class="op">/</span> sample_rate</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>plt.plot(time <span class="op">*</span> <span class="dv">1000</span>, data)  <span class="co"># Time in ms</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Acquired Signal&#39;</span>)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="5.3.3" id="exercise-capture-a-waveform"><span
         class="header-section-number">5.3.3</span> Exercise: Capture a
         Waveform</h3>
         <p><em>Equipment: Use the Tektronix TBS 2000 Series
         oscilloscope and Keysight EDU33212A waveform generator at your
         station. These are the same instruments you used in PHYS
         3330.</em></p>
         <ol type="1">
         <li>Connect your waveform generator to both an oscilloscope and
         your DAQ device.</li>
         <li>Set the waveform generator to output a sine wave at a
         frequency compatible with your sample rate calculation.</li>
         <li>Modify the sample rate and samples to read to capture
         approximately 5 complete periods.</li>
         <li>Run the acquisition and compare the Python plot with the
         oscilloscope display. Are they compatible?</li>
         <li>Add to your notebook: the Python code, the resulting plot,
         and the oscilloscope output. Explain how they all make sense
         together.</li>
         </ol>
         <h1 data-number="6"
         id="digital-sampling-and-nyquist-frequency"><span
         class="header-section-number">6</span> Digital Sampling and
         Nyquist Frequency</h1>
         <p>Now that you can acquire data with the DAQ, it’s important
         to understand how the choice of sample rate affects your
         measurements. This section explores what happens when you
         sample a signal too slowly.</p>
         <h2 data-number="6.1" id="exploring-sample-rate-effects"><span
         class="header-section-number">6.1</span> Exploring Sample Rate
         Effects</h2>
         <ol type="1">
         <li><p>Modify your Python script so that the <em>Number of
         Samples</em> and <em>Sample Rate</em> are easily configurable
         variables at the top:</p>
         <div class="sourceCode" id="cb21"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration - easily adjustable</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>SAMPLE_RATE <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Samples per second</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>NUM_SAMPLES <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Total samples (1 second of data)</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>DAQ_CHANNEL <span class="op">=</span> <span class="st">&quot;Dev1/ai0&quot;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acquire_data(sample_rate, num_samples, channel):</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Acquire data from DAQ with specified parameters.&quot;&quot;&quot;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(channel)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>num_samples)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(data)</span></code></pre></div></li>
         <li><p>Set up a function generator to produce a <strong>1 kHz
         sine wave</strong>.</p></li>
         <li><p>Connect the function generator’s output to both the
         oscilloscope and the DAQ.</p></li>
         </ol>
         <h2 data-number="6.2" id="initial-measurements"><span
         class="header-section-number">6.2</span> Initial
         Measurements</h2>
         <ol type="1">
         <li><p>Set the sample rate in your Python script to <strong>500
         samples per second</strong> and the number of samples such that
         it records 1 second of data.</p></li>
         <li><p>Record and plot a dataset with both the oscilloscope and
         the DAQ. Make sure that the time range on the oscilloscope is
         set such that it is on the same order as the data being
         recorded by the DAQ.</p>
         <div class="sourceCode" id="cb22"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Acquire and plot data</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> acquire_data(SAMPLE_RATE, NUM_SAMPLES, DAQ_CHANNEL)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(NUM_SAMPLES) <span class="op">/</span> SAMPLE_RATE</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>plt.plot(time, data)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (s)&#39;</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f&#39;Acquired Signal (</span><span class="sc">{</span>SAMPLE_RATE<span class="sc">}</span><span class="ss"> Hz sample rate)&#39;</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Compare the two plots. What are the major differences
         between the two?</p></li>
         <li><p>Why might one or both of these plots be giving an
         incorrect result? Think about the wave you are measuring and
         the result you are getting. How do they relate?</p></li>
         </ol>
         <h2 data-number="6.3" id="enhanced-understanding"><span
         class="header-section-number">6.3</span> Enhanced
         Understanding</h2>
         <p>This section will guide you to an understanding of Nyquist’s
         theorem and a more appropriate sample rate for digital data
         collection.</p>
         <ol type="1">
         <li><p>Why do you think the data from the DAQ produced a wave
         of lower frequency?</p></li>
         <li><p>Adjust the sample rate in a way you think might provide
         a more accurate measurement of the wave. What do you think the
         measured waveform will look like this time?</p></li>
         <li><p>Take a dataset, record and plot it. Did it match your
         predictions?</p></li>
         <li><p>Now record another dataset with the function generator
         set to the same parameters but the sample rate set to
         <strong>3000 samples per second</strong> and the number of
         samples set to record 1 second of data.</p></li>
         <li><p>Plot this new dataset. What is the frequency of the new
         dataset?</p></li>
         <li><p>What are the fundamental differences between the first,
         second, and third datasets?</p></li>
         </ol>
         <h2 data-number="6.4" id="nyquist-frequency"><span
         class="header-section-number">6.4</span> Nyquist Frequency</h2>
         <p>The discrepancies between the sampled waveforms can be
         explained by <strong>Nyquist’s theorem</strong>. It states that
         to accurately measure a signal by discrete sampling methods
         (like the DAQ) the sampling rate must be at least twice that of
         the measured signal. If this were not the case, a measurement
         might not be taken at every interval of oscillation, a
         situation called “undersampling.” Sampling the signal at least
         twice as fast as the maximum frequency of interest ensures that
         at least two data points are recorded each period.</p>
         <p><strong>Definition:</strong></p>
         <p>The <em>Nyquist Frequency</em> is defined to be half the
         sample rate.</p>
         <h3 data-number="6.4.1" id="aliasing-exercises"><span
         class="header-section-number">6.4.1</span> Aliasing
         Exercises</h3>
         <ol type="1">
         <li><p><strong>Predict</strong> the <em>apparent</em> frequency
         (in Hz) of the signal recorded by the DAQ.
         <strong>Observe</strong> what really happens using your
         waveform generator, DAQ, and Python script.
         <strong>Explain</strong> the result. Suppose the DAQ is set to
         1 kS/s sample rate in all of the cases, while the waveform
         generator is set to:</p>
         <ol type="1">
         <li>1000 Hz</li>
         <li>998 Hz</li>
         <li>1004 Hz</li>
         <li>1500 Hz</li>
         <li>2000 Hz</li>
         <li>1997 Hz</li>
         <li>2005 Hz</li>
         </ol>
         <p>In understanding what is going on, it may help to draw a few
         periods of the wave and then indicate where the DAQ will sample
         the waveform.</p></li>
         <li><p>You <em>want</em> to measure the random fluctuations
         (noise) in a signal from 0-100 Hz.</p>
         <ol type="1">
         <li>If you set the sample rate at 200 Hz, what set of frequency
         ranges will contribute to the noise measurement?</li>
         <li>If you set the sample rate at 1000 Hz, what set of
         frequency ranges will contribute to the noise measurement?</li>
         <li>How could you help achieve the desired measurement in 2.1
         using a combination of changing the sample rate and adding
         filtering? Explain why your choice of sample rate and signal
         filter would work better.</li>
         </ol></li>
         <li><p><strong>Undersampling on the oscilloscope.</strong>
         Undersampling is an issue with any device that samples data at
         regular discrete time intervals. This question requires the use
         of a Tektronix TBS 2000 Series oscilloscope and the Keysight
         EDU33212A waveform generator.</p>
         <ol type="1">
         <li>The oscilloscope’s sample rate depends on the time/div
         setting. On the Tektronix TBS 2000, you can see acquisition
         information by pressing <strong>Acquire</strong> on the front
         panel. The sample rate changes as you adjust the horizontal
         (time) scale—slower time scales use lower sample rates.</li>
         <li>Predict what you should observe if you set the waveform
         generator to the same frequency as the oscilloscope’s sample
         rate. Try it out, compare with your prediction, and explain
         your observations.</li>
         <li>What happens if you change the oscilloscope time scale? Or
         change the waveform generator frequency slightly? Try to
         explain what you observe.</li>
         </ol>
         <p><em>Note: You may need to use the waveform generator’s
         “Sync/Trigger out” connector to trigger the oscilloscope
         externally for stable display at certain
         frequencies.</em></p></li>
         </ol>
         <h1 data-number="7" id="noise-floor-characterization"><span
         class="header-section-number">7</span> Noise Floor
         Characterization</h1>
         <p>You’ve learned how sample rate affects what you can
         measure—too slow, and you get aliasing. Now you’ll investigate
         what limits how <em>precisely</em> you can measure: the noise
         floor.</p>
         <p>In Week 1, you calibrated your photodetector’s gain and
         offset. This week, you’ll characterize your measurement
         system’s noise floor—and discover what actually limits your
         measurements.</p>
         <p><strong>Connection to Week 1:</strong> The “RMS noise” you
         measure here IS the standard deviation of repeated voltage
         measurements. When we say the DAQ has “5 mV RMS noise,” we mean
         that if you sample a constant input many times, the standard
         deviation will be about 5 mV. This becomes the minimum
         achievable uncertainty (<span
         class="math inline">\(\sigma_V\)</span>) for any voltage
         measurement.</p>
         <p><strong>Connection to aliasing:</strong> The noise you’ll
         measure is broadband—it contains all frequencies. This is why
         your sample rate matters even for noise measurements: higher
         sample rates capture more of the noise spectrum.</p>
         <p><strong>Why this matters:</strong> In Week 4, you’ll measure
         beam profiles where the signal varies over a wide range.
         Understanding your actual noise floor is essential for making
         informed measurement decisions.</p>
         <h2 data-number="7.1"
         id="phase-1-configuration-discovery"><span
         class="header-section-number">7.1</span> Phase 1: Configuration
         Discovery</h2>
         <p>You’ll discover how DAQ configuration affects
         measurements—and what happens when configuration doesn’t match
         your physical setup.</p>
         <h3 data-number="7.1.1" id="setup"><span
         class="header-section-number">7.1.1</span> Setup</h3>
         <ol type="1">
         <li><strong>Ensure nothing is connected</strong> to the DAQ
         inputs.</li>
         <li><strong>Short AI0+ to GND.</strong> Leave AI0-
         disconnected.</li>
         </ol>
         <p>This is a reasonable setup for a single-ended measurement:
         one signal wire connected to ground.</p>
         <h3 data-number="7.1.2"
         id="discovery-1-configuration-must-match-wiring"><span
         class="header-section-number">7.1.2</span> Discovery 1:
         Configuration Must Match Wiring</h3>
         <p>The USB-6009 can measure voltages in two ways:</p>
         <ul>
         <li><strong>RSE (Referenced Single-Ended):</strong> Measures
         AI0+ relative to system ground</li>
         <li><strong>Differential:</strong> Measures the difference
         between AI0+ and AI0-</li>
         </ul>
         <p><strong>Predict:</strong> You’ve grounded AI0+ and left AI0-
         floating. What will happen if you measure in each mode?</p>
         <ul>
         <li>Both modes will read ~0V (grounded input means zero
         voltage)</li>
         <li>RSE will work correctly; Differential will give unexpected
         results</li>
         <li>Differential will work correctly; RSE will give unexpected
         results</li>
         </ul>
         <p><strong>Measure:</strong></p>
         <div class="sourceCode" id="cb23"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType, TerminalConfiguration</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_noise(channel<span class="op">=</span><span class="st">&quot;Dev1/ai0&quot;</span>, num_samples<span class="op">=</span><span class="dv">1000</span>, sample_rate<span class="op">=</span><span class="dv">10000</span>,</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                  terminal_config<span class="op">=</span>TerminalConfiguration.RSE,</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>                  voltage_range<span class="op">=</span><span class="fl">10.0</span>):</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Measure noise with specified configuration.&quot;&quot;&quot;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>            channel,</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>            terminal_config<span class="op">=</span>terminal_config,</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>            min_val<span class="op">=-</span>voltage_range,</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>            max_val<span class="op">=</span>voltage_range</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> np.array(task.read(number_of_samples_per_channel<span class="op">=</span>num_samples))</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(data), np.std(data)</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare terminal configurations (same ±10V range)</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>dc_rse, noise_rse <span class="op">=</span> measure_noise(terminal_config<span class="op">=</span>TerminalConfiguration.RSE, voltage_range<span class="op">=</span><span class="fl">10.0</span>)</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>dc_diff, noise_diff <span class="op">=</span> measure_noise(terminal_config<span class="op">=</span>TerminalConfiguration.DIFF, voltage_range<span class="op">=</span><span class="fl">10.0</span>)</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;RSE  ±10V: DC = </span><span class="sc">{</span>dc_rse<span class="op">*</span><span class="dv">1000</span><span class="sc">:7.2f}</span><span class="ss"> mV, RMS noise = </span><span class="sc">{</span>noise_rse<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;DIFF ±10V: DC = </span><span class="sc">{</span>dc_diff<span class="op">*</span><span class="dv">1000</span><span class="sc">:7.2f}</span><span class="ss"> mV, RMS noise = </span><span class="sc">{</span>noise_diff<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span></code></pre></div>
         <p><strong>Record your results:</strong></p>
         <table>
         <thead>
         <tr class="header">
         <th>Configuration</th>
         <th>DC (mV)</th>
         <th>RMS Noise (mV)</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>RSE ±10V</td>
         <td></td>
         <td></td>
         </tr>
         <tr class="even">
         <td>DIFF ±10V</td>
         <td></td>
         <td></td>
         </tr>
         </tbody>
         </table>
         <p><strong>What happened?</strong></p>
         <ul>
         <li><strong>RSE mode</strong> measures AI0+ relative to ground.
         Since AI0+ <em>is</em> grounded, you get ~0V with the expected
         ~5 mV noise.</li>
         <li><strong>Differential mode</strong> measures (AI0+) −
         (AI0−). AI0+ is grounded (0V), but AI0− is
         <em>floating</em>—picking up electrical noise from the
         environment. The result is unpredictable: a large, possibly
         unstable DC offset and high noise.</li>
         </ul>
         <p><strong>The lesson:</strong> Your software configuration
         must match your physical wiring. A floating input in
         differential mode doesn’t give zero—it gives garbage.</p>
         <h3 data-number="7.1.3" id="discovery-2-voltage-range"><span
         class="header-section-number">7.1.3</span> Discovery 2: Voltage
         Range</h3>
         <p>Now let’s see how voltage range affects noise with a
         <em>properly configured</em> measurement.</p>
         <p><strong>Change your wiring:</strong> Connect both AI0+ and
         AI0- to GND. This creates a valid zero-volt input for
         differential mode.</p>
         <p><strong>Predict:</strong> The ±1V range can measure smaller
         voltages more precisely than ±10V. Will this affect noise?</p>
         <ul>
         <li>No effect—noise is noise</li>
         <li>Lower noise with ±1V range</li>
         <li>Higher noise with ±1V range</li>
         </ul>
         <p><strong>Measure:</strong></p>
         <div class="sourceCode" id="cb24"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare voltage ranges (same DIFF terminal config)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>dc_10v, noise_10v <span class="op">=</span> measure_noise(terminal_config<span class="op">=</span>TerminalConfiguration.DIFF, voltage_range<span class="op">=</span><span class="fl">10.0</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>dc_1v, noise_1v <span class="op">=</span> measure_noise(terminal_config<span class="op">=</span>TerminalConfiguration.DIFF, voltage_range<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;DIFF ±10V: DC = </span><span class="sc">{</span>dc_10v<span class="op">*</span><span class="dv">1000</span><span class="sc">:7.2f}</span><span class="ss"> mV, RMS noise = </span><span class="sc">{</span>noise_10v<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;DIFF ±1V:  DC = </span><span class="sc">{</span>dc_1v<span class="op">*</span><span class="dv">1000</span><span class="sc">:7.2f}</span><span class="ss"> mV, RMS noise = </span><span class="sc">{</span>noise_1v<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span></code></pre></div>
         <p><strong>Record your results:</strong></p>
         <table>
         <thead>
         <tr class="header">
         <th>Configuration</th>
         <th>DC (mV)</th>
         <th>RMS Noise (mV)</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>DIFF ±10V</td>
         <td></td>
         <td></td>
         </tr>
         <tr class="even">
         <td>DIFF ±1V</td>
         <td></td>
         <td></td>
         </tr>
         </tbody>
         </table>
         <h3 data-number="7.1.4" id="what-you-discovered"><span
         class="header-section-number">7.1.4</span> What You
         Discovered</h3>
         <ol type="1">
         <li><p><strong>Configuration must match wiring:</strong> When
         you configured differential mode but only grounded AI0+, the
         floating AI0- produced garbage readings. This is a common
         mistake—your software settings must match your physical
         circuit.</p></li>
         <li><p><strong>Range affects noise:</strong> Narrower voltage
         ranges have lower noise floors. The USB-6009 datasheet confirms
         this:</p>
         <ul>
         <li>RSE ±10V: ~5 mV RMS</li>
         <li>DIFF ±1V: ~0.5 mV RMS</li>
         </ul></li>
         <li><p><strong>Tradeoffs exist:</strong> Lower noise sounds
         better, but the ±1V range saturates (clips) any signal above
         1V. Your Week 4 beam profile will have signals from near-zero
         to several volts—you need the ±10V range despite its higher
         noise.</p></li>
         </ol>
         <h3 data-number="7.1.5" id="configuration-for-this-lab"><span
         class="header-section-number">7.1.5</span> Configuration for
         This Lab</h3>
         <p>For the rest of this lab and Week 4, use <strong>RSE mode
         with ±10V range</strong>:</p>
         <ul>
         <li>Your photodetector outputs a single-ended signal (one wire
         referenced to ground)</li>
         <li>Your signals can exceed 1V</li>
         <li>This matches your Week 1 calibration</li>
         </ul>
         <p><strong>Use this function for all remaining
         measurements:</strong></p>
         <div class="sourceCode" id="cb25"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType, TerminalConfiguration</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_noise(channel<span class="op">=</span><span class="st">&quot;Dev1/ai0&quot;</span>, num_samples<span class="op">=</span><span class="dv">1000</span>, sample_rate<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Measure DC level and RMS noise. Uses RSE ±10V configuration.&quot;&quot;&quot;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            channel,</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            terminal_config<span class="op">=</span>TerminalConfiguration.RSE,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>            min_val<span class="op">=-</span><span class="fl">10.0</span>,</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>            max_val<span class="op">=</span><span class="fl">10.0</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> np.array(task.read(number_of_samples_per_channel<span class="op">=</span>num_samples))</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(data), np.std(data)</span></code></pre></div>
         <h2 data-number="7.2"
         id="phase-2-what-limits-your-measurement"><span
         class="header-section-number">7.2</span> Phase 2: What Limits
         Your Measurement?</h2>
         <p>Now the key question: when you connect your photodetector,
         will the noise change?</p>
         <h3 data-number="7.2.1" id="prediction"><span
         class="header-section-number">7.2.1</span> Prediction</h3>
         <p>Before measuring, make a prediction:</p>
         <p><strong>Given information:</strong></p>
         <ul>
         <li>Your DAQ noise (RSE ±10V): ~5 mV RMS (you just measured
         this)</li>
         <li>Photodetector noise (from datasheet):
         <ul>
         <li>0 dB gain: ~0.3 mV RMS</li>
         <li>70 dB gain: ~1.1 mV RMS</li>
         </ul></li>
         </ul>
         <p><strong>Your prediction:</strong> When you connect the
         capped photodetector (dark, no light), the measured noise
         will:</p>
         <ul>
         <li>Increase significantly (photodetector adds substantial
         noise)</li>
         <li>Increase slightly (by less than 0.5 mV, since noise adds in
         quadrature)</li>
         <li>Stay approximately the same (~5 mV)</li>
         <li>Decrease (photodetector somehow reduces noise)</li>
         </ul>
         <p><strong>Your reasoning (1-2 sentences):</strong>
         _______________________________________________</p>
         <h3 data-number="7.2.2" id="measurement"><span
         class="header-section-number">7.2.2</span> Measurement</h3>
         <ol type="1">
         <li><strong>Connect</strong> the photodetector to the DAQ.</li>
         <li><strong>Cap the photodetector</strong> to block all
         light.</li>
         <li>Measure noise at two gain settings:</li>
         </ol>
         <div class="sourceCode" id="cb26"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Measure at 0 dB gain (set on photodetector)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>dc_0db, noise_0db <span class="op">=</span> measure_noise()</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;0 dB gain - Noise: </span><span class="sc">{</span>noise_0db<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Change photodetector to 70 dB gain, then measure again</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>dc_70db, noise_70db <span class="op">=</span> measure_noise()</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;70 dB gain - Noise: </span><span class="sc">{</span>noise_70db<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span></code></pre></div>
         <p><strong>Results:</strong></p>
         <table>
         <thead>
         <tr class="header">
         <th>Gain</th>
         <th>Measured Noise</th>
         <th>Photodetector Spec</th>
         <th>DAQ Noise</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>0 dB</td>
         <td>_______ mV</td>
         <td>0.3 mV</td>
         <td>~5 mV</td>
         </tr>
         <tr class="even">
         <td>70 dB</td>
         <td>_______ mV</td>
         <td>1.1 mV</td>
         <td>~5 mV</td>
         </tr>
         </tbody>
         </table>
         <h3 data-number="7.2.3" id="confront-your-prediction"><span
         class="header-section-number">7.2.3</span> Confront Your
         Prediction</h3>
         <ol type="1">
         <li><p><strong>Was your prediction correct?</strong> Did noise
         change significantly when you connected the
         photodetector?</p></li>
         <li><p><strong>Reflect on your reasoning:</strong> If your
         prediction was correct, what reasoning led you to the right
         answer? If incorrect, what assumption failed?</p></li>
         <li><p><strong>What does this tell you?</strong> If noise
         stayed at ~5 mV regardless of gain, which component dominates
         your system noise?</p></li>
         <li><p><strong>Why doesn’t photodetector noise show
         up?</strong> The photodetector’s 0.3-1.1 mV noise is real, but
         it’s smaller than the DAQ’s 5 mV noise floor. You cannot
         measure something smaller than your instrument’s noise
         floor.</p></li>
         </ol>
         <h3 data-number="7.2.4"
         id="the-implication-for-gain-selection"><span
         class="header-section-number">7.2.4</span> The Implication for
         Gain Selection</h3>
         <p>Here’s the key insight: <strong>if noise is fixed at ~5 mV
         regardless of gain, then increasing gain improves your
         signal-to-noise ratio.</strong></p>
         <table>
         <thead>
         <tr class="header">
         <th>Gain</th>
         <th>Signal</th>
         <th>Noise</th>
         <th>SNR</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>Low (0 dB)</td>
         <td>Small</td>
         <td>~5 mV</td>
         <td>Low</td>
         </tr>
         <tr class="even">
         <td>High (70 dB)</td>
         <td>Large</td>
         <td>~5 mV</td>
         <td>High</td>
         </tr>
         </tbody>
         </table>
         <p><strong>The strategy:</strong> Use the highest gain that
         doesn’t saturate your signal.</p>
         <h2 data-number="7.3"
         id="phase-3-gain-selection-for-week-4"><span
         class="header-section-number">7.3</span> Phase 3: Gain
         Selection for Week 4</h2>
         <p>Choose your photodetector gain setting for Week 4 beam
         profile measurements.</p>
         <p><strong>Constraints:</strong></p>
         <ul>
         <li>DAQ saturates at ±10 V (photodetector max output is also 10
         V)</li>
         <li>DAQ noise floor: ~5 mV RMS</li>
         <li>Your Week 1 calibration data (signal vs. gain)</li>
         </ul>
         <p><strong>Your task:</strong> Select a gain that maximizes SNR
         without saturating on your brightest measurement.</p>
         <p><strong>Selected gain:</strong> _______ dB</p>
         <p><strong>Justification (include your reasoning about
         saturation margin and expected SNR):</strong>
         _______________________________________________</p>
         <p>Compare with a neighboring group. Different choices can be
         valid if the reasoning is sound.</p>
         <h2 data-number="7.4" id="looking-ahead"><span
         class="header-section-number">7.4</span> Looking Ahead</h2>
         <p>The noise floor you measured (~5 mV) will directly affect
         your Week 4 beam profile uncertainty:</p>
         <ol type="1">
         <li><strong>Today:</strong> You characterized the DAQ noise
         floor that limits your measurements</li>
         <li><strong>Week 3:</strong> You’ll learn how measurement
         uncertainties propagate through calculations</li>
         <li><strong>Week 4:</strong> Your DAQ noise determines
         uncertainty in each data point, which propagates through curve
         fitting to give uncertainty in beam width</li>
         </ol>
         <p>Keep your noise measurement accessible—you’ll need it for
         Week 3’s error propagation exercises.</p>
         <h2 data-number="7.5"
         id="optional-oscilloscope-comparison"><span
         class="header-section-number">7.5</span> Optional: Oscilloscope
         Comparison</h2>
         <p>The oscilloscope has a much lower noise floor than the DAQ.
         If time permits, compare noise measurements.</p>
         <p><strong>Setup:</strong> Connect the photodetector output to
         oscilloscope CH1.</p>
         <div class="sourceCode" id="cb27"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvisa</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>rm <span class="op">=</span> pyvisa.ResourceManager()</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>scope <span class="op">=</span> rm.open_resource(<span class="st">&quot;USB0::0x0699::...&quot;</span>)  <span class="co"># Your scope address</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>scope.timeout <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Capture waveform and compute noise (std dev)</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>scope.write(<span class="st">&quot;DATA:SOURCE CH1&quot;</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> scope.query_binary_values(<span class="st">&quot;CURVE?&quot;</span>, datatype<span class="op">=</span><span class="st">&#39;b&#39;</span>, container<span class="op">=</span>np.array)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>v_scale <span class="op">=</span> <span class="bu">float</span>(scope.query(<span class="st">&quot;WFMPRE:YMULT?&quot;</span>))</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>v_off <span class="op">=</span> <span class="bu">float</span>(scope.query(<span class="st">&quot;WFMPRE:YOFF?&quot;</span>))</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>voltage <span class="op">=</span> (raw <span class="op">-</span> v_off) <span class="op">*</span> v_scale</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;RMS noise: </span><span class="sc">{</span>np<span class="sc">.</span>std(voltage)<span class="op">*</span><span class="dv">1000</span><span class="sc">:.2f}</span><span class="ss"> mV&quot;</span>)</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>scope.close()</span></code></pre></div>
         <p>See <a
         href="/PHYS-4430/python-visa#tektronix-tbs2000-oscilloscope">VISA
         Instrument Control</a> for complete oscilloscope examples.</p>
         <p><strong>Question:</strong> With the oscilloscope’s lower
         noise floor, can you now see the photodetector noise increase
         with gain?</p>
         <h1 data-number="8"
         id="saving-data-and-additional-daq-features"><span
         class="header-section-number">8</span> Saving Data and
         Additional DAQ Features</h1>
         <h2 data-number="8.1" id="saving-data-to-a-file"><span
         class="header-section-number">8.1</span> Saving Data to a
         File</h2>
         <p>Save your acquired data to a CSV file for later
         analysis:</p>
         <div class="sourceCode" id="cb28"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># After acquiring data...</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a timestamp for the filename</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>timestamp <span class="op">=</span> datetime.now().strftime(<span class="st">&quot;%Y%m</span><span class="sc">%d</span><span class="st">_%H%M%S&quot;</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> <span class="ss">f&quot;data_</span><span class="sc">{</span>timestamp<span class="sc">}</span><span class="ss">.csv&quot;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create time array</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="bu">len</span>(data)) <span class="op">/</span> sample_rate</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Save to CSV</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>np.savetxt(</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    filename,</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    np.column_stack([time, data]),</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>,</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    header<span class="op">=</span><span class="st">&#39;Time (s), Voltage (V)&#39;</span>,</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    comments<span class="op">=</span><span class="st">&#39;&#39;</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Data saved to </span><span class="sc">{</span>filename<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.1.1"
         id="exercise-save-and-reload-data"><span
         class="header-section-number">8.1.1</span> Exercise: Save and
         Reload Data</h3>
         <ol type="1">
         <li><p>Acquire a waveform and save it to a CSV file.</p></li>
         <li><p>Load the data back and plot it:</p>
         <div class="sourceCode" id="cb29"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>loaded_data <span class="op">=</span> np.loadtxt(filename, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>time_loaded <span class="op">=</span> loaded_data[:, <span class="dv">0</span>]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>voltage_loaded <span class="op">=</span> loaded_data[:, <span class="dv">1</span>]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>plt.plot(time_loaded <span class="op">*</span> <span class="dv">1000</span>, voltage_loaded)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Loaded Data&#39;</span>)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Verify the loaded data matches your original
         acquisition.</p></li>
         </ol>
         <h2 data-number="8.2" id="generating-an-analog-output"><span
         class="header-section-number">8.2</span> Generating an Analog
         Output</h2>
         <p>The USB-6009 can also generate analog voltages (though at a
         limited rate of 150 S/s). Note that the USB-6009’s analog
         outputs have a range of 0-5V only, so we must specify this
         range explicitly:</p>
         <div class="sourceCode" id="cb30"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Output a DC voltage</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    task.ao_channels.add_ao_voltage_chan(<span class="st">&quot;Dev1/ao0&quot;</span>, min_val<span class="op">=</span><span class="fl">0.0</span>, max_val<span class="op">=</span><span class="fl">5.0</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    task.write(<span class="fl">2.5</span>, auto_start<span class="op">=</span><span class="va">True</span>)  <span class="co"># Output 2.5 V</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Outputting 2.5 V on AO0&quot;</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">input</span>(<span class="st">&quot;Press Enter to stop...&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.2.1" id="exercise-test-analog-output"><span
         class="header-section-number">8.2.1</span> Exercise: Test
         Analog Output</h3>
         <ol type="1">
         <li>Configure your DAQ to output a voltage on
         <code>AO0</code>.</li>
         <li>Connect <code>AO0</code> to <code>AI0</code> (loopback
         test).</li>
         <li>Write a script that:
         <ul>
         <li>Outputs a voltage on <code>AO0</code></li>
         <li>Reads the voltage on <code>AI0</code></li>
         <li>Verifies they match</li>
         </ul></li>
         </ol>
         <h2 data-number="8.3" id="error-handling"><span
         class="header-section-number">8.3</span> Error Handling</h2>
         <p>Always include error handling in your data acquisition
         code:</p>
         <div class="sourceCode" id="cb31"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.errors <span class="im">import</span> DaqError</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        voltage <span class="op">=</span> task.read()</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> DaqError <span class="im">as</span> e:</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;DAQ Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Check that:&quot;</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - The DAQ device is connected&quot;</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - The device name is correct (try &#39;Dev1&#39;, &#39;Dev2&#39;, etc.)&quot;</span>)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - NI-DAQmx drivers are installed&quot;</span>)</span></code></pre></div>
         <h1 data-number="9" id="summary"><span
         class="header-section-number">9</span> Summary</h1>
         <p>In this lab, you learned to:</p>
         <ol type="1">
         <li>Connect and verify a USB DAQ device</li>
         <li>Read single and multiple voltage samples</li>
         <li>Configure sample rate and acquisition timing</li>
         <li>Explain Nyquist’s theorem and recognize aliasing</li>
         <li>Choose appropriate sample rates for your signals</li>
         <li>Discover that DAQ configuration (terminal mode, voltage
         range) affects noise performance</li>
         <li>Characterize the DAQ noise floor and identify it as the
         dominant noise source</li>
         <li>Reason through why gain improves SNR when noise is
         fixed</li>
         <li>Make a quantitative decision about optimal gain for Week 4
         measurements</li>
         <li>Save data to CSV files</li>
         <li>Generate analog output voltages</li>
         <li>Handle common errors</li>
         </ol>
         <p><strong>Key takeaway:</strong> You discovered that
         instrument behavior depends on configuration—default settings
         are not always what you expect. You also found that the DAQ
         noise floor (~5 mV in RSE mode) limits your measurements, not
         the photodetector noise. These authentic discoveries—that
         understanding your instruments matters—are central to
         experimental physics.</p>
         <p>See the <a href="/PHYS-4430/python-resources">Python
         Resources</a> page and the example scripts in the
         <code>python/</code> folder for more detailed examples.</p>
         <h1 data-number="10" id="deliverables-and-assessment"><span
         class="header-section-number">10</span> Deliverables and
         Assessment</h1>
         <p>Your lab notebook should include the following for this
         week:</p>
         <h2 data-number="10.1" id="prelab-complete-before-lab"><span
         class="header-section-number">10.1</span> Prelab (complete
         before lab)</h2>
         <ol type="1">
         <li><strong>Least-squares fitting exercises</strong>: contour
         plot of <span class="math inline">\(\chi^2\)</span>, graphical
         minimization results</li>
         <li><strong>Residuals analysis</strong>: plot of residuals,
         answers to goodness-of-fit questions</li>
         <li><strong>Weighted fit</strong>: results using data with
         uncertainties, <span class="math inline">\(\chi^2\)</span> test
         calculation</li>
         <li><strong>Error bars plot</strong>: reproduction of the
         example plot with error bars</li>
         </ol>
         <h2 data-number="10.2" id="in-lab-documentation"><span
         class="header-section-number">10.2</span> In-Lab
         Documentation</h2>
         <ol type="1">
         <li><strong>DAQ verification</strong>: screenshot or plot
         showing successful voltage reading</li>
         <li><strong>Waveform capture</strong>: comparison of Python
         plot vs. oscilloscope display</li>
         <li><strong>Aliasing exercises</strong>: completed
         prediction-observation-explanation for all frequency cases</li>
         <li><strong>Configuration discovery</strong> (Phase 1):
         <ul>
         <li>DAQ noise with default settings: _______ mV</li>
         <li>DAQ noise with explicit RSE ±10V: _______ mV</li>
         <li>Explanation of why configuration affects noise</li>
         </ul></li>
         <li><strong>Noise source identification</strong> (Phase 2):
         <ul>
         <li>Prediction of whether photodetector changes noise</li>
         <li>Measurements at 0 dB and 70 dB gain</li>
         <li>Conclusion about dominant noise source</li>
         </ul></li>
         <li><strong>Gain setting decision</strong> (Phase 3): your
         selected gain with written justification</li>
         <li><strong>Peer comparison</strong>: other group’s gain
         setting and brief discussion</li>
         </ol>
         <h2 data-number="10.3" id="key-data-table"><span
         class="header-section-number">10.3</span> Key Data Table</h2>
         <p><strong>Photodetector Noise Test</strong></p>
         <table>
         <colgroup>
         <col style="width: 8%" />
         <col style="width: 22%" />
         <col style="width: 27%" />
         <col style="width: 16%" />
         <col style="width: 25%" />
         </colgroup>
         <thead>
         <tr class="header">
         <th>Gain</th>
         <th>Measured Noise</th>
         <th>Photodetector Spec</th>
         <th>DAQ Noise</th>
         <th>Dominant Source</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>0 dB</td>
         <td>_______ mV</td>
         <td>0.3 mV</td>
         <td>~5 mV</td>
         <td>_______</td>
         </tr>
         <tr class="even">
         <td>70 dB</td>
         <td>_______ mV</td>
         <td>1.1 mV</td>
         <td>~5 mV</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <h2 data-number="10.4" id="code-deliverables"><span
         class="header-section-number">10.4</span> Code
         Deliverables</h2>
         <ol type="1">
         <li>Working <code>measure_noise()</code> function with explicit
         RSE configuration</li>
         <li>Python script for waveform acquisition and plotting</li>
         </ol>
         <h2 data-number="10.5" id="reflection-questions"><span
         class="header-section-number">10.5</span> Reflection
         Questions</h2>
         <ol type="1">
         <li><p>You measured DAQ noise with two different
         configurations. Why does the choice of terminal mode and
         voltage range affect the noise level? What lesson does this
         teach about working with instruments?</p></li>
         <li><p>Given that the DAQ noise floor is fixed at ~5 mV (in RSE
         mode), explain in 2-3 sentences why using higher gain improves
         SNR. What limits how high you can set the gain?</p></li>
         <li><p>You discovered that differential mode with ±1V range has
         ~0.5 mV noise—10× lower than RSE mode. Why can’t you use this
         lower-noise configuration for your Week 4
         measurements?</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
