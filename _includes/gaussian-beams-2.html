<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 2</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#where-we-are-in-the-sequence"
            id="toc-where-we-are-in-the-sequence"><span
            class="toc-section-number">1</span> Where We Are in the
            Sequence</a></li>
            <li><a href="#overview" id="toc-overview"><span
            class="toc-section-number">2</span> Overview</a>
            <ul>
            <li><a href="#what-is-python" id="toc-what-is-python"><span
            class="toc-section-number">2.1</span> What is
            Python?</a></li>
            <li><a href="#learning-goals" id="toc-learning-goals"><span
            class="toc-section-number">2.2</span> Learning
            Goals</a></li>
            </ul></li>
            <li><a href="#prelab" id="toc-prelab"><span
            class="toc-section-number">3</span> Prelab</a>
            <ul>
            <li><a href="#useful-readings"
            id="toc-useful-readings"><span
            class="toc-section-number">3.1</span> Useful
            readings</a></li>
            <li><a href="#why-do-we-minimize-the-sum-of-squares"
            id="toc-why-do-we-minimize-the-sum-of-squares"><span
            class="toc-section-number">3.2</span> Why do we minimize the
            sum of squares?</a></li>
            <li><a href="#sec:min-graph" id="toc-sec:min-graph"><span
            class="toc-section-number">3.3</span> Minimizing <span
            class="math inline">\(\chi^2\)</span> graphically</a></li>
            <li><a href="#uncertainty-in-the-fit-parameters"
            id="toc-uncertainty-in-the-fit-parameters"><span
            class="toc-section-number">3.4</span> Uncertainty in the fit
            parameters</a></li>
            <li><a href="#estimating-the-uncertainty-in-the-data"
            id="toc-estimating-the-uncertainty-in-the-data"><span
            class="toc-section-number">3.5</span> Estimating the
            uncertainty in the data</a></li>
            <li><a href="#goodness-of-fit"
            id="toc-goodness-of-fit"><span
            class="toc-section-number">3.6</span> Goodness of fit</a>
            <ul>
            <li><a href="#sec:plot-res" id="toc-sec:plot-res"><span
            class="toc-section-number">3.6.1</span> Plotting the fit
            residuals</a></li>
            <li><a href="#chi-by-eye---eyeballing-the-goodness-of-fit"
            id="toc-chi-by-eye---eyeballing-the-goodness-of-fit"><span
            class="toc-section-number">3.6.2</span> “Chi by eye” -
            eyeballing the goodness of fit</a></li>
            <li><a
            href="#chi2-and-chi_red2-for-testing-the-goodness-of-fit"
            id="toc-chi2-and-chi_red2-for-testing-the-goodness-of-fit"><span
            class="toc-section-number">3.6.3</span> <span
            class="math inline">\(\chi^2\)</span> and <span
            class="math inline">\(\chi_{red}^2\)</span> for testing the
            “goodness” of fit</a></li>
            <li><a
            href="#choosing-a-strategy-to-estimate-the-uncertainty"
            id="toc-choosing-a-strategy-to-estimate-the-uncertainty"><span
            class="toc-section-number">3.6.4</span> Choosing a strategy
            to estimate the uncertainty</a></li>
            <li><a href="#weighted-fits" id="toc-weighted-fits"><span
            class="toc-section-number">3.6.5</span> Weighted
            fits</a></li>
            <li><a
            href="#why-is-it-often-bad-to-overestimate-uncertainties"
            id="toc-why-is-it-often-bad-to-overestimate-uncertainties"><span
            class="toc-section-number">3.6.6</span> Why is it often bad
            to overestimate uncertainties?</a></li>
            <li><a
            href="#when-does-curve_fit-underestimate-the-true-uncertainty"
            id="toc-when-does-curve_fit-underestimate-the-true-uncertainty"><span
            class="toc-section-number">3.6.7</span> When does
            <code>curve_fit</code> underestimate the true
            uncertainty?</a></li>
            <li><a href="#random-vs.-systematic-uncertainties"
            id="toc-random-vs.-systematic-uncertainties"><span
            class="toc-section-number">3.6.8</span> Random
            vs. Systematic Uncertainties</a></li>
            </ul></li>
            <li><a href="#error-bars" id="toc-error-bars"><span
            class="toc-section-number">3.7</span> Error bars</a>
            <ul>
            <li><a href="#error-bars-in-python-with-matplotlib"
            id="toc-error-bars-in-python-with-matplotlib"><span
            class="toc-section-number">3.7.1</span> Error bars in Python
            with Matplotlib</a></li>
            <li><a href="#example-gaussian-laser-beam-width-measurement"
            id="toc-example-gaussian-laser-beam-width-measurement"><span
            class="toc-section-number">3.7.2</span> Example: Gaussian
            laser beam width measurement</a></li>
            </ul></li>
            <li><a
            href="#prelab-exercise-error-function-fitting-practice"
            id="toc-prelab-exercise-error-function-fitting-practice"><span
            class="toc-section-number">3.8</span> Prelab Exercise: Error
            Function Fitting Practice</a>
            <ul>
            <li><a href="#the-error-function-model"
            id="toc-the-error-function-model"><span
            class="toc-section-number">3.8.1</span> The Error Function
            Model</a></li>
            <li><a href="#practice-exercise"
            id="toc-practice-exercise"><span
            class="toc-section-number">3.8.2</span> Practice
            Exercise</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#introduction-to-python-for-data-acquisition"
            id="toc-introduction-to-python-for-data-acquisition"><span
            class="toc-section-number">4</span> Introduction to Python
            for Data Acquisition</a>
            <ul>
            <li><a href="#development-environment"
            id="toc-development-environment"><span
            class="toc-section-number">4.1</span> Development
            Environment</a></li>
            <li><a href="#connect-the-usb-6009-and-verify-it-is-working"
            id="toc-connect-the-usb-6009-and-verify-it-is-working"><span
            class="toc-section-number">4.2</span> Connect the USB-6009
            and verify it is working</a></li>
            <li><a href="#reading-multiple-samples"
            id="toc-reading-multiple-samples"><span
            class="toc-section-number">4.3</span> Reading Multiple
            Samples</a>
            <ul>
            <li><a href="#understanding-sample-rate-and-samples-to-read"
            id="toc-understanding-sample-rate-and-samples-to-read"><span
            class="toc-section-number">4.3.1</span> Understanding Sample
            Rate and Samples to Read</a></li>
            <li><a href="#sec:analogmeas" id="toc-sec:analogmeas"><span
            class="toc-section-number">4.3.2</span> Acquiring Multiple
            Samples</a></li>
            <li><a href="#exercise-capture-a-waveform"
            id="toc-exercise-capture-a-waveform"><span
            class="toc-section-number">4.3.3</span> Exercise: Capture a
            Waveform</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#digital-sampling-and-nyquist-frequency"
            id="toc-digital-sampling-and-nyquist-frequency"><span
            class="toc-section-number">5</span> Digital Sampling and
            Nyquist Frequency</a>
            <ul>
            <li><a href="#exploring-sample-rate-effects"
            id="toc-exploring-sample-rate-effects"><span
            class="toc-section-number">5.1</span> Exploring Sample Rate
            Effects</a></li>
            <li><a href="#initial-measurements"
            id="toc-initial-measurements"><span
            class="toc-section-number">5.2</span> Initial
            Measurements</a></li>
            <li><a href="#enhanced-understanding"
            id="toc-enhanced-understanding"><span
            class="toc-section-number">5.3</span> Enhanced
            Understanding</a></li>
            <li><a href="#nyquist-frequency"
            id="toc-nyquist-frequency"><span
            class="toc-section-number">5.4</span> Nyquist Frequency</a>
            <ul>
            <li><a href="#aliasing-exercises"
            id="toc-aliasing-exercises"><span
            class="toc-section-number">5.4.1</span> Aliasing
            Exercises</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#photodetector-noise-characterization"
            id="toc-photodetector-noise-characterization"><span
            class="toc-section-number">6</span> Photodetector Noise
            Characterization</a>
            <ul>
            <li><a href="#background-noise-in-amplified-photodetectors"
            id="toc-background-noise-in-amplified-photodetectors"><span
            class="toc-section-number">6.1</span> Background: Noise in
            Amplified Photodetectors</a>
            <ul>
            <li><a href="#sources-of-noise"
            id="toc-sources-of-noise"><span
            class="toc-section-number">6.1.1</span> Sources of
            Noise</a></li>
            <li><a href="#the-gain-noise-tradeoff"
            id="toc-the-gain-noise-tradeoff"><span
            class="toc-section-number">6.1.2</span> The Gain-Noise
            Tradeoff</a></li>
            <li><a href="#signal-to-noise-ratio-snr"
            id="toc-signal-to-noise-ratio-snr"><span
            class="toc-section-number">6.1.3</span> Signal-to-Noise
            Ratio (SNR)</a></li>
            </ul></li>
            <li><a href="#part-1-measuring-the-noise-floor"
            id="toc-part-1-measuring-the-noise-floor"><span
            class="toc-section-number">6.2</span> Part 1: Measuring the
            Noise Floor</a>
            <ul>
            <li><a href="#dark-noise-measurement"
            id="toc-dark-noise-measurement"><span
            class="toc-section-number">6.2.1</span> Dark Noise
            Measurement</a></li>
            </ul></li>
            <li><a href="#part-2-signal-to-noise-measurement"
            id="toc-part-2-signal-to-noise-measurement"><span
            class="toc-section-number">6.3</span> Part 2:
            Signal-to-Noise Measurement</a>
            <ul>
            <li><a href="#setup" id="toc-setup"><span
            class="toc-section-number">6.3.1</span> Setup</a></li>
            <li><a href="#prediction" id="toc-prediction"><span
            class="toc-section-number">6.3.2</span> Prediction</a></li>
            <li><a href="#measurement" id="toc-measurement"><span
            class="toc-section-number">6.3.3</span> Measurement</a></li>
            </ul></li>
            <li><a href="#part-3-automating-noise-measurements"
            id="toc-part-3-automating-noise-measurements"><span
            class="toc-section-number">6.4</span> Part 3: Automating
            Noise Measurements</a>
            <ul>
            <li><a href="#design-decisions"
            id="toc-design-decisions"><span
            class="toc-section-number">6.4.1</span> Design
            Decisions</a></li>
            <li><a href="#code-framework" id="toc-code-framework"><span
            class="toc-section-number">6.4.2</span> Code
            Framework</a></li>
            <li><a href="#understanding-your-code-required"
            id="toc-understanding-your-code-required"><span
            class="toc-section-number">6.4.3</span> Understanding Your
            Code (Required)</a></li>
            <li><a href="#debugging-exercise-find-the-bugs"
            id="toc-debugging-exercise-find-the-bugs"><span
            class="toc-section-number">6.4.4</span> Debugging Exercise:
            Find the Bugs</a></li>
            </ul></li>
            <li><a href="#part-4-choosing-your-week-4-gain-setting"
            id="toc-part-4-choosing-your-week-4-gain-setting"><span
            class="toc-section-number">6.5</span> Part 4: Choosing Your
            Week 4 Gain Setting</a>
            <ul>
            <li><a href="#your-signal-range"
            id="toc-your-signal-range"><span
            class="toc-section-number">6.5.1</span> Your Signal
            Range</a></li>
            <li><a href="#the-constraints"
            id="toc-the-constraints"><span
            class="toc-section-number">6.5.2</span> The
            Constraints</a></li>
            <li><a href="#analysis" id="toc-analysis"><span
            class="toc-section-number">6.5.3</span> Analysis</a></li>
            <li><a href="#your-decision" id="toc-your-decision"><span
            class="toc-section-number">6.5.4</span> Your
            Decision</a></li>
            </ul></li>
            <li><a href="#peer-comparison-gain-setting-choices"
            id="toc-peer-comparison-gain-setting-choices"><span
            class="toc-section-number">6.6</span> Peer Comparison: Gain
            Setting Choices</a></li>
            <li><a
            href="#part-5-week-4-validation-to-complete-in-week-4"
            id="toc-part-5-week-4-validation-to-complete-in-week-4"><span
            class="toc-section-number">6.7</span> Part 5: Week 4
            Validation (To Complete in Week 4)</a></li>
            <li><a href="#looking-ahead-connecting-noise-to-uncertainty"
            id="toc-looking-ahead-connecting-noise-to-uncertainty"><span
            class="toc-section-number">6.8</span> Looking Ahead:
            Connecting Noise to Uncertainty</a></li>
            <li><a href="#noise-characterization-troubleshooting"
            id="toc-noise-characterization-troubleshooting"><span
            class="toc-section-number">6.9</span> Noise Characterization
            Troubleshooting</a></li>
            </ul></li>
            <li><a href="#saving-data-and-additional-daq-features"
            id="toc-saving-data-and-additional-daq-features"><span
            class="toc-section-number">7</span> Saving Data and
            Additional DAQ Features</a>
            <ul>
            <li><a href="#saving-data-to-a-file"
            id="toc-saving-data-to-a-file"><span
            class="toc-section-number">7.1</span> Saving Data to a
            File</a>
            <ul>
            <li><a href="#exercise-save-and-reload-data"
            id="toc-exercise-save-and-reload-data"><span
            class="toc-section-number">7.1.1</span> Exercise: Save and
            Reload Data</a></li>
            </ul></li>
            <li><a href="#generating-an-analog-output"
            id="toc-generating-an-analog-output"><span
            class="toc-section-number">7.2</span> Generating an Analog
            Output</a>
            <ul>
            <li><a href="#exercise-test-analog-output"
            id="toc-exercise-test-analog-output"><span
            class="toc-section-number">7.2.1</span> Exercise: Test
            Analog Output</a></li>
            </ul></li>
            <li><a href="#error-handling" id="toc-error-handling"><span
            class="toc-section-number">7.3</span> Error
            Handling</a></li>
            </ul></li>
            <li><a href="#summary" id="toc-summary"><span
            class="toc-section-number">8</span> Summary</a></li>
            <li><a href="#deliverables-and-assessment"
            id="toc-deliverables-and-assessment"><span
            class="toc-section-number">9</span> Deliverables and
            Assessment</a>
            <ul>
            <li><a href="#prelab-complete-before-lab"
            id="toc-prelab-complete-before-lab"><span
            class="toc-section-number">9.1</span> Prelab (complete
            before lab)</a></li>
            <li><a href="#in-lab-documentation"
            id="toc-in-lab-documentation"><span
            class="toc-section-number">9.2</span> In-Lab
            Documentation</a></li>
            <li><a href="#key-data-tables"
            id="toc-key-data-tables"><span
            class="toc-section-number">9.3</span> Key Data
            Tables</a></li>
            <li><a href="#code-deliverables"
            id="toc-code-deliverables"><span
            class="toc-section-number">9.4</span> Code
            Deliverables</a></li>
            <li><a href="#reflection-questions"
            id="toc-reflection-questions"><span
            class="toc-section-number">9.5</span> Reflection
            Questions</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="where-we-are-in-the-sequence"><span
         class="header-section-number">1</span> Where We Are in the
         Sequence</h1>
         <p><strong>Week 2 of 4: Instrumentation and Noise
         Characterization</strong></p>
         <p>Last week you calibrated your photodetector and learned to
         measure beam width manually. This week you’ll learn
         Python-based data acquisition and—critically—characterize your
         photodetector’s noise performance. Your goal: make a
         quantitative, evidence-based decision about which gain setting
         to use for Week 4’s automated measurements.</p>
         <p><strong>Last week:</strong> Aligned optics, calibrated
         photodetector, measured beam width manually <strong>This
         week:</strong> Learn DAQ programming → Characterize noise →
         Choose optimal gain setting <strong>Next week:</strong> Learn
         FFT analysis → Set up motor controller → Prepare for
         automation</p>
         <h1 data-number="2" id="overview"><span
         class="header-section-number">2</span> Overview</h1>
         <p>The second week of the Gaussian Beams lab introduces you to
         Python for data acquisition and guides you through interfacing
         Python with the instrumentation and data acquisition systems
         used in this course. You will also learn about digital sampling
         theory and characterize the noise performance of your
         photodetector—a critical step for making informed measurement
         decisions in Week 4.</p>
         <p>This week’s lab is divided into two parts. In part 1
         (Prelab), you will learn essential curve fitting techniques
         that you’ll use throughout this course. In part 2 (Lab), you
         will learn Python programming for data acquisition using a
         National Instruments DAQ device, the <a
         href="http://sine.ni.com/nips/cds/view/p/lang/en/nid/201987">NI
         USB-6009</a>. This multifunction USB powered device has 4
         (differential) analog inputs (14-bit, 48 kS/s), 2 analog
         outputs (12-bit, 150 S/s), 12 digital I/O channels, and a
         32-bit counter. You will then apply these DAQ skills to
         characterize your photodetector’s noise floor and make a
         quantitative decision about optimal gain settings.</p>
         <h2 data-number="2.1" id="what-is-python"><span
         class="header-section-number">2.1</span> What is Python?</h2>
         <p>Python is a versatile programming language widely used in
         scientific computing and data analysis. Many research labs use
         Python for instrument control, data acquisition, and analysis.
         Its advantages include:</p>
         <ul>
         <li>Free and open source</li>
         <li>Extensive scientific libraries (NumPy, SciPy,
         Matplotlib)</li>
         <li>Large community with excellent documentation</li>
         <li>Easy to learn and read</li>
         <li>Works on all major operating systems</li>
         </ul>
         <p>You can use Python on the lab laptops where it is already
         installed. See the <a href="/PHYS-4430/python-resources">Python
         Resources</a> page for installation instructions if you want to
         set it up on your own computer.</p>
         <h2 data-number="2.2" id="learning-goals"><span
         class="header-section-number">2.2</span> Learning Goals</h2>
         <p>After completing the prelab, you will be able to:</p>
         <ol type="1">
         <li>Explain why we minimize the sum of squares to get the best
         fit.</li>
         <li>Carry out a least-squares minimization graphically.</li>
         <li>Plot residuals to visually inspect the goodness of a
         fit.</li>
         <li>Interpret the uncertainty in fit parameters from
         <code>scipy.optimize.curve_fit</code>.</li>
         <li>Compute <span class="math inline">\(\chi^2\)</span> for a
         fit and use it to determine if a fit is “good”.</li>
         <li>Create plots with error bars using Matplotlib.</li>
         </ol>
         <p>After completing the lab, you will be able to:</p>
         <ol type="1">
         <li>Connect a USB DAQ device to a computer and confirm the
         analog inputs are working correctly.</li>
         <li>Write a Python script to read analog voltage
         measurements.</li>
         <li>Configure sample rate and number of samples for data
         acquisition.</li>
         <li>Explain Nyquist’s theorem and choose appropriate sample
         rates.</li>
         <li>Recognize aliasing and understand its causes.</li>
         <li>Measure the photodetector’s noise floor and compare to
         datasheet specifications.</li>
         <li>Calculate signal-to-noise ratio and predict how it depends
         on gain setting.</li>
         <li>Select and justify an optimal gain setting based on
         quantitative analysis.</li>
         <li>Save acquired data to a CSV file.</li>
         </ol>
         <h1 data-number="3" id="prelab"><span
         class="header-section-number">3</span> Prelab</h1>
         <p>This week’s prelab builds on the uncertainty concepts you
         learned in the Week 1 prelab. Now we move from estimating
         uncertainties in individual measurements to fitting data and
         propagating those uncertainties to derived quantities. This is
         a “user’s guide” to least-squares fitting and determining the
         goodness of your fits. At the end of the prelab you will be
         able to:</p>
         <ol type="1">
         <li>Explain why we minimize the sum of squares to get the best
         fit.</li>
         <li>Carry out a least-squares minimization graphically.</li>
         <li>Plot residuals to visually inspect the goodness of a
         fit.</li>
         <li>Interpret the uncertainty in fit parameters.</li>
         <li>Compute <span class="math inline">\(\chi^2\)</span> for a
         fit and use it to determine if a fit is “good”.</li>
         <li>Create plots with error bars using Matplotlib.</li>
         </ol>
         <h2 data-number="3.1" id="useful-readings"><span
         class="header-section-number">3.1</span> Useful readings</h2>
         <ol type="1">
         <li>Taylor, J. R. (1997). <em>An Introduction to Error
         Analysis: The Study of Uncertainties in Physical
         Measurements</em> (p. 327). University Science Books. This is
         the standard undergraduate text for measurement and
         uncertainty.</li>
         <li>Bevington, P. R., &amp; Robinson, K. D. (2003). <em>Data
         Reduction and Error Analysis for the Physical Sciences</em>
         Third Edition (3rd ed.). New York: McGraw-Hill. Great for
         advanced undergrad error analysis. Professional physicists use
         it too.</li>
         </ol>
         <h2 data-number="3.2"
         id="why-do-we-minimize-the-sum-of-squares"><span
         class="header-section-number">3.2</span> Why do we minimize the
         sum of squares?</h2>
         <p><strong>Question:</strong> Why do we call it “least-squares”
         fitting?</p>
         <p><strong>Answer:</strong> Because the best fit is determined
         by minimizing the weighted sum of squares of the deviation
         between the data and the fit. Properly speaking this “sum of
         squares” is called “chi-squared” and is given by</p>
         <p><span class="math display">\[\chi^2 = {\displaystyle
         \sum_{i=1}^{N}}\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \ ... \
         ))^2\text{,}\]</span> {#eq:1}</p>
         <p>where there are where <span class="math inline">\(N\)</span>
         data points, <span class="math inline">\((x_i,y_i )\)</span>,
         and the fit function is given by <span
         class="math inline">\(y(x_i,a,b,c, \ … \ )\)</span> where <span
         class="math inline">\(a, b,\)</span> etc. are the fit
         parameters.</p>
         <p><strong>Question:</strong> What assumptions are made for the
         method to be valid?</p>
         <p><strong>Answer:</strong> The two assumptions are:</p>
         <ol type="1">
         <li><strong>Gaussian distributed.</strong> The random
         fluctuations in each data point <span
         class="math inline">\(y_i\)</span> are Gaussian distributed
         with standard deviation <span
         class="math inline">\(\sigma_i\)</span>.</li>
         <li><strong>Uncorrelated.</strong> The random fluctuations in
         any one data point are uncorrelated with those in another data
         point.</li>
         </ol>
         <p><strong>Question:</strong> Why does minimizing the sum of
         squares give us the best fit?</p>
         <p><strong>Answer:</strong> Given the two above assumptions,
         the fit that minimizes the sum of squares is the
         <strong><em>most likely</em></strong> function to produce the
         observed data. This can be proven using a little calculus and
         probability. A more detailed explanation is found in Taylor’s
         <em>Introduction to Error Analysis</em> Sec. 5.5 “Justification
         of the Mean as Best Estimate” or Bevington and Robinson’s
         <em>Data Reduction</em> Sec. 4.1 “Method of Least-Squares”.</p>
         <h2 data-number="3.3" id="sec:min-graph"><span
         class="header-section-number">3.3</span> Minimizing <span
         class="math inline">\(\chi^2\)</span> graphically</h2>
         <p><em>You will rarely minimize <span
         class="math inline">\(\chi^2\)</span> graphically in a lab.
         However, this exercise will help you better understand what
         fitting routines actually do to find the best fit.</em></p>
         <ol type="1">
         <li><p>Download and plot <a
         href="../resources/lab-guides/gaussian-laser-beams/profile_data_without_errors.csv">this
         data set</a>. It was generated by inserting a razor blade into
         path of a laser beam and measuring the photodetector voltage of
         the laser light. The <span class="math inline">\(x\)</span>
         column is the micrometer (razor) position in meters and the
         <span class="math inline">\(y\)</span> column is the
         photodetector voltage in volts.</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the data</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;profile_data_without_errors.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>x_data <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>y_data <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_data, y_data, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (m)&#39;</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Define the same fit function as:</p>
         <p><span class="math display">\[y(x,a,b,c,w) = a \
         Erf\left(\frac{\sqrt{2}}{w}(x-b)\right)+c\]</span></p>
         <p>In Python, this can be written using
         <code>scipy.special.erf</code>:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beam_profile(x, a, b, c, w):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.&quot;&quot;&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> (x <span class="op">-</span> b) <span class="op">/</span> w) <span class="op">+</span> c</span></code></pre></div></li>
         <li><p>Reduce the fit to two free parameters. This step is only
         necessary because it is hard to visualize more than 3
         dimensions. Assume <span
         class="math inline">\(a_{fit}=(V_{max}-V_{min})/2 =
         1.4375\)</span> and <span class="math inline">\(c_{fit}
         =(V_{max}+V_{min})/2 = 1.45195\)</span>. These were determined
         by averaging the first 6 data points to get <span
         class="math inline">\(V_{min}\)</span> and the last 5 to get
         <span class="math inline">\(V_{max}\)</span>.</p></li>
         <li><p>Use Equation <span class="citation"
         data-cites="eq:1">@eq:1</span> to write an expression for <span
         class="math inline">\(\chi^2\)</span> in terms of your <span
         class="math inline">\(w\)</span> and <span
         class="math inline">\(b\)</span> parameters, and the <span
         class="math inline">\(x\)</span> (position) data and <span
         class="math inline">\(y\)</span> (voltage) data. Since you
         don’t have any estimate for the uncertainties <span
         class="math inline">\(\sigma_i\)</span>, assume they are all
         unity so <span class="math inline">\(\sigma_i=1\)</span>.</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chi_squared(w, b, x_data, y_data, a_fixed, c_fixed):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Calculate chi-squared for given parameters.&quot;&quot;&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    y_fit <span class="op">=</span> beam_profile(x_data, a_fixed, b, c_fixed, w)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>((y_data <span class="op">-</span> y_fit)<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div></li>
         <li><p><strong>Before running any code</strong>, answer these
         prediction questions in your notebook:</p>
         <ol type="1">
         <li>What shape do you expect the <span
         class="math inline">\(\chi^2\)</span> contours to have?
         (Circular? Elliptical? Irregular?) Why?</li>
         <li>If the contours are elliptical, what would it mean if the
         ellipse is tilted (major axis not aligned with <span
         class="math inline">\(w\)</span> or <span
         class="math inline">\(b\)</span> axes)?</li>
         <li>Where in the <span class="math inline">\((w, b)\)</span>
         plane should the minimum <span
         class="math inline">\(\chi^2\)</span> occur—at the true beam
         width and position, or somewhere else?</li>
         </ol></li>
         <li><p>Make a contour plot of <span
         class="math inline">\(\chi^2(w,b)\)</span> and tweak the plot
         range until you see the minimum. You can use AI assistance or
         the code below. The goal is to <em>interpret</em> the result,
         not to write the code from scratch.</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a grid of w and b values</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>w_range <span class="op">=</span> np.linspace(<span class="fl">0.0003</span>, <span class="fl">0.0007</span>, <span class="dv">100</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>b_range <span class="op">=</span> np.linspace(<span class="fl">0.009</span>, <span class="fl">0.011</span>, <span class="dv">100</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>W, B <span class="op">=</span> np.meshgrid(w_range, b_range)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate chi-squared for each combination</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>a_fixed <span class="op">=</span> <span class="fl">1.4375</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>c_fixed <span class="op">=</span> <span class="fl">1.45195</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.zeros_like(W)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b_range)):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(w_range)):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        Z[i, j] <span class="op">=</span> chi_squared(w_range[j], b_range[i], x_data, y_data,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                              a_fixed, c_fixed)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Make contour plot</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.contour(W <span class="op">*</span> <span class="dv">1000</span>, B <span class="op">*</span> <span class="dv">1000</span>, Z, levels<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">&#39;$</span><span class="ch">\\</span><span class="st">chi^2$&#39;</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;w (mm)&#39;</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;b (mm)&#39;</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;$</span><span class="ch">\\</span><span class="st">chi^2$ Contour Plot&#39;</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         </ol>
         <figure id="fig:contour">
         <img
         src="../resources/lab-guides/gaussian-laser-beams/contour.png"
         style="width:15cm" alt="Contour plot example." />
         <figcaption aria-hidden="true">Contour plot
         example.</figcaption>
         </figure>
         <ol start="7" type="1">
         <li><p><strong>Interpretation questions</strong> (answer in
         your notebook):</p>
         <ol type="1">
         <li>Were your predictions from step 5 correct? If not, explain
         what you learned.</li>
         <li>The contours are likely elliptical and possibly tilted.
         Explain in 2-3 sentences why the parameters <span
         class="math inline">\(w\)</span> and <span
         class="math inline">\(b\)</span> might be correlated (i.e., why
         changing one affects the best value of the other).</li>
         <li>If the noise in the data were doubled, how would the
         contour plot change? Would the minimum move? Would the contours
         spread out or contract?</li>
         </ol></li>
         <li><p>Graphically determine the best fit parameters to 3
         significant digits.</p></li>
         <li><p>Compare with the best fit result from
         <code>scipy.optimize.curve_fit</code> (allow all 4 parameters
         to vary). Do the fits agree for those three digits of
         precision?</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [<span class="fl">1.4375</span>, <span class="fl">0.01</span>, <span class="fl">1.45195</span>, <span class="fl">0.0005</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform the fit</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(beam_profile, x_data, y_data, p0<span class="op">=</span>p0)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Best fit parameters:&quot;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  a = </span><span class="sc">{</span>popt[<span class="dv">0</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  b = </span><span class="sc">{</span>popt[<span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  c = </span><span class="sc">{</span>popt[<span class="dv">2</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  w = </span><span class="sc">{</span>popt[<span class="dv">3</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="3.4"
         id="uncertainty-in-the-fit-parameters"><span
         class="header-section-number">3.4</span> Uncertainty in the fit
         parameters</h2>
         <p><strong>Question:</strong> Where does the uncertainty in the
         fit parameters come from?</p>
         <p><strong>Answer:</strong> The optimal fit parameters depend
         on the data points <span
         class="math inline">\((x_i,y_i)\)</span>. The uncertainty,
         <span class="math inline">\(\sigma_i\)</span>, in the <span
         class="math inline">\(y_i\)</span> means there is a propagated
         uncertainty in the calculation of the fit parameters. The error
         propagation calculation is explained in detail in the
         references, especially Bevington and Robinson.</p>
         <p><strong>Question:</strong> How does <code>curve_fit</code>
         calculate the uncertainty in the fit parameters when no error
         estimate for the <span class="math inline">\(\sigma_i\)</span>
         is provided?</p>
         <p><strong>Answer:</strong> When no uncertainties are provided,
         <code>curve_fit</code> (and other fitting routines) estimate
         the uncertainty in the data <span
         class="math inline">\(\sigma_y^2\)</span> using the “residuals”
         of the best fit:</p>
         <p><span class="math display">\[\sigma_y^2 =
         \frac{1}{N-n}{\displaystyle
         \sum_{i=1}^{N}}(y_i-y(x_i,a_0,b_0,c_0, \ ... \
         ))^2\text{,}\quad\quad\]</span> {#eq:2}</p>
         <p>where there are <span class="math inline">\(N\)</span> data
         points <span class="math inline">\(y_i\)</span> and the best
         fit value at each point is given by <span
         class="math inline">\(y\)</span>, which depends on <span
         class="math inline">\(x_i\)</span> and the <span
         class="math inline">\(n\)</span> best fit parameters <span
         class="math inline">\(a_0,b_0,c_0, \ ... \ \)</span>. It is
         very similar to how you would estimate the standard deviation
         of a repeated measurement, which for comparison’s sake is given
         by:</p>
         <p><span class="math display">\[\sigma_y^2 =
         \frac{1}{N-n}{\displaystyle
         \sum_{i=1}^{N}}(y_i-\overline{y})^2\text{.}\]</span>
         {#eq:3}</p>
         <p>The parameter uncertainties are then extracted from the
         covariance matrix:</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get parameter uncertainties from the covariance matrix</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Parameter uncertainties:&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_a = </span><span class="sc">{</span>perr[<span class="dv">0</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_b = </span><span class="sc">{</span>perr[<span class="dv">1</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_c = </span><span class="sc">{</span>perr[<span class="dv">2</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;  σ_w = </span><span class="sc">{</span>perr[<span class="dv">3</span>]<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <h2 data-number="3.5"
         id="estimating-the-uncertainty-in-the-data"><span
         class="header-section-number">3.5</span> Estimating the
         uncertainty in the data</h2>
         <ol type="1">
         <li><p>Use Equation <span class="citation"
         data-cites="eq:2">@eq:2</span> and your best fit parameters to
         estimate <span class="math inline">\(\sigma_y^2\)</span>, the
         random error of each data point given by your data.</p>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate residuals</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>y_fit <span class="op">=</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_data <span class="op">-</span> y_fit</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate variance (N data points, n=4 parameters)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">len</span>(y_data)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>sigma_y_squared <span class="op">=</span> np.<span class="bu">sum</span>(residuals<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (N <span class="op">-</span> n)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>sigma_y <span class="op">=</span> np.sqrt(sigma_y_squared)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Estimated σ_y = </span><span class="sc">{</span>sigma_y<span class="sc">:.6f}</span><span class="ss"> V&quot;</span>)</span></code></pre></div></li>
         <li><p>Compare your result with the estimate from the fit. The
         estimated variance can be calculated from the
         residuals.</p></li>
         <li><p>Do the estimates agree? Why or why not?</p></li>
         </ol>
         <h2 data-number="3.6" id="goodness-of-fit"><span
         class="header-section-number">3.6</span> Goodness of fit</h2>
         <p>This section covers two ways to analyze if a fit is
         good.</p>
         <ol type="1">
         <li>Plotting the residuals.</li>
         <li>Doing a <span class="math inline">\(\chi^2\)</span>
         test.</li>
         </ol>
         <h3 data-number="3.6.1" id="sec:plot-res"><span
         class="header-section-number">3.6.1</span> Plotting the fit
         residuals</h3>
         <p>The first step is to look at the residuals. The residuals,
         <span class="math inline">\(r_i\)</span>, are defined as the
         difference between the data and the fit.</p>
         <p><span class="math display">\[r_i=y_i-y(x_i,a,b,c, \ ... \
         )\]</span></p>
         <ol type="1">
         <li><p>Make a plot of the residuals:</p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and plot residuals</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_data <span class="op">-</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_data, residuals)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">&#39;r&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;--&#39;</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (m)&#39;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Residuals (V)&#39;</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Fit Residuals&#39;</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Since we didn’t provide any estimates of the
         uncertainties, the fitting assumed the uncertainty of every
         point is the same. Based on the plot of residuals, was this a
         good assumption?</p></li>
         <li><p>Do the residuals look randomly scattered about zero or
         do you notice any systematic error sources?</p></li>
         <li><p>Is the distribution of residuals scattered evenly around
         zero? Or is there a particular range of <span
         class="math inline">\(x\)</span> values where the residuals are
         larger than others?</p></li>
         <li><p>What is the most likely source of the large uncertainty
         as the beam is cut near the center of the beam?</p></li>
         </ol>
         <h3 data-number="3.6.2"
         id="chi-by-eye---eyeballing-the-goodness-of-fit"><span
         class="header-section-number">3.6.2</span> “Chi by eye” -
         eyeballing the goodness of fit</h3>
         <p><strong>Question:</strong> If I have a good fit, should
         every data point lie within an error bar?</p>
         <p><strong>Answer:</strong> No. Most should, but we wouldn’t
         expect every data point to lie within an error bar. If the
         uncertainty is Gaussian distributed with a standard deviation
         <span class="math inline">\(\sigma_i\)</span> for each data
         point, <span class="math inline">\(y_i\)</span>, then we expect
         roughly 68% of the data points to lie within their error bar.
         This is because 68% of the probability in a Gaussian
         distribution lies within one standard deviation of the
         mean.</p>
         <h3 data-number="3.6.3"
         id="chi2-and-chi_red2-for-testing-the-goodness-of-fit"><span
         class="header-section-number">3.6.3</span> <span
         class="math inline">\(\chi^2\)</span> and <span
         class="math inline">\(\chi_{red}^2\)</span> for testing the
         “goodness” of fit</h3>
         <p>This section answers the question “What should <span
         class="math inline">\(\chi^2\)</span> be for a good fit?”</p>
         <p>Suppose the only uncertainty in the data is statistical
         (i.e., random) error, with a known standard deviation <span
         class="math inline">\(\sigma_i\)</span>, then on average each
         term in the sum is</p>
         <p><span
         class="math display">\[\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \
         ... \ ))^2 \approx 1\text{,}\]</span> {#eq:4}</p>
         <p>and the full <span class="math inline">\(\chi^2\)</span> sum
         of squares is approximately</p>
         <p><span class="math display">\[\chi^2 = {\displaystyle
         \sum_{i=1}^{N}}\frac{1}{\sigma_i^2}(y_i-y(x_i,a,b,c, \ ... \
         ))^2\approx N-n\text{.}\quad\quad\]</span> {#eq:5}</p>
         <p>So a good fit has</p>
         <p><span class="math display">\[\chi_{red}^2 \equiv
         \frac{\chi^2}{N-n}\approx 1\text{.}\]</span> {#eq:6}</p>
         <ol type="1">
         <li><strong>Fact: To find the goodness of fit test, you must
         first estimate the uncertainties on the data points that you
         are fitting.</strong> How would you explain the reason for this
         in your own words?</li>
         </ol>
         <h3 data-number="3.6.4"
         id="choosing-a-strategy-to-estimate-the-uncertainty"><span
         class="header-section-number">3.6.4</span> Choosing a strategy
         to estimate the uncertainty</h3>
         <ol type="1">
         <li><p>Considering your answers from Section <span
         class="citation" data-cites="sec:plot-res">@sec:plot-res</span>
         (especially <span class="citation"
         data-cites="sec:plot-res">@sec:plot-res</span>.5), which method
         would give you the best estimate of the uncertainty for each
         data point, and why?</p>
         <ul>
         <li><p>Eyeballing the fluctuations in each data point.</p></li>
         <li><p>Taking <span class="math inline">\(N\)</span>
         measurements at each razor position and then going to the next
         position.</p></li>
         <li><p>Taking the entire data set <span
         class="math inline">\(N\)</span> times.</p></li>
         </ul></li>
         </ol>
         <h3 data-number="3.6.5" id="weighted-fits"><span
         class="header-section-number">3.6.5</span> Weighted fits</h3>
         <p>When you have estimated the uncertainty <span
         class="math inline">\(\sigma_i\)</span> of each data point
         <span class="math inline">\(y_i\)</span> you should use this
         information when fitting to correctly evaluate the <span
         class="math inline">\(\chi^2\)</span> expression in Equation
         <span class="citation" data-cites="eq:1">@eq:1</span>. The
         points with high uncertainty contribute less information when
         choosing the best fit parameters.</p>
         <p>In Python’s <code>curve_fit</code>, you provide
         uncertainties using the <code>sigma</code> parameter:</p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Weighted fit with known uncertainties</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    beam_profile,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    x_data,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    y_data,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    p0<span class="op">=</span>p0,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>sigma_list,        <span class="co"># Your uncertainty estimates</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    absolute_sigma<span class="op">=</span><span class="va">True</span>      <span class="co"># Use actual sigma values (not relative)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
         <ol type="1">
         <li><p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/profile_data_with_errors.csv">this
         data set</a> for a beam width measurement with uncertainties.
         The first column is razor position in meters, the second column
         is photodetector output voltage, and the third column is the
         uncertainty on the photodetector output voltage.</p>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data with uncertainties</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;profile_data_with_errors.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>x_data <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>y_data <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>y_err <span class="op">=</span> data[:, <span class="dv">2</span>]</span></code></pre></div></li>
         <li><p>Do a weighted fit using the same fit function as in
         Section <span class="citation"
         data-cites="sec:min-graph">@sec:min-graph</span>. Use the
         uncertainty estimates in the third column.</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Weighted fit</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    beam_profile, x_data, y_data,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    p0<span class="op">=</span>[<span class="fl">1.4</span>, <span class="fl">0.01</span>, <span class="fl">1.45</span>, <span class="fl">0.0005</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>y_err,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    absolute_sigma<span class="op">=</span><span class="va">True</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span></code></pre></div></li>
         <li><p>Calculate <span
         class="math inline">\(\chi^2\)</span>:</p>
         <div class="sourceCode" id="cb12"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate chi-squared</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>y_fit <span class="op">=</span> beam_profile(x_data, <span class="op">*</span>popt)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>chi2 <span class="op">=</span> np.<span class="bu">sum</span>(((y_data <span class="op">-</span> y_fit) <span class="op">/</span> y_err)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>dof <span class="op">=</span> <span class="bu">len</span>(y_data) <span class="op">-</span> <span class="bu">len</span>(popt)  <span class="co"># degrees of freedom</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>chi2_red <span class="op">=</span> chi2 <span class="op">/</span> dof</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Chi-squared: </span><span class="sc">{</span>chi2<span class="sc">:.2f}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Degrees of freedom: </span><span class="sc">{</span>dof<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Reduced chi-squared: </span><span class="sc">{</span>chi2_red<span class="sc">:.2f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         <li><p>How close is the reduced chi-squared to 1?</p></li>
         <li><p><strong>The “chi-squared test”.</strong> This part helps
         us understand if the value of <span
         class="math inline">\(\chi^2\)</span> is statistically likely
         or not. The following graph gives the probability of exceeding
         a particular value of <span
         class="math inline">\(\chi^2\)</span> for <span
         class="math inline">\(\nu=𝑁−𝑛=22\)</span> degrees of freedom.
         It can be calculated using the Cumulative Density Function
         (CDF) for the chi-squared distribution. Use the graph to
         estimate the likelihood this value of <span
         class="math inline">\(\chi^2\)</span> occurred by chance.</p>
         <div class="sourceCode" id="cb13"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate p-value (probability of getting this chi2 or higher by chance)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> stats.chi2.cdf(chi2, dof)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;P-value: </span><span class="sc">{</span>p_value<span class="sc">:.4f}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <figure id="fig:cdf">
         <img src="../resources/lab-guides/gaussian-laser-beams/cdf.png"
         style="width:15cm"
         alt="Cumulative Density Function (CDF) for the chi-squared distribution." />
         <figcaption aria-hidden="true">Cumulative Density Function
         (CDF) for the chi-squared distribution.</figcaption>
         </figure>
         <h3 data-number="3.6.6"
         id="why-is-it-often-bad-to-overestimate-uncertainties"><span
         class="header-section-number">3.6.6</span> Why is it often bad
         to overestimate uncertainties?</h3>
         <ol type="1">
         <li>Why can overestimating the uncertainty make your fit appear
         good (i.e., <span
         class="math inline">\(\frac{\chi^2}{N-n}\approx
         1\)</span>)?</li>
         </ol>
         <p>Overestimating the uncertainties makes the fit seem good
         (according to a <span class="math inline">\(\chi^2\)</span>
         test), even when it might be obviously a bad fit. It is best to
         do the <span class="math inline">\(\chi^2\)</span> test using
         an honest estimate of your uncertainties. If the <span
         class="math inline">\(\chi^2\)</span> is larger than expected
         <span class="math inline">\((\chi^2&gt;𝑁−𝑛)\)</span>, then you
         should consider both the possibility of systematic error
         sources and the quality of your estimates of the uncertainties.
         On the other hand, if the <span
         class="math inline">\(\chi^2\)</span> test is good <span
         class="math inline">\((\chi^2\approx 𝑁−𝑛)\)</span>, then it
         shows you have a good handle on the model of your system, and
         your sources of uncertainty. Finally, if <span
         class="math inline">\(\chi^2\ll (𝑁−𝑛)\)</span>, this likely
         indicates overestimated uncertainties.</p>
         <h3 data-number="3.6.7"
         id="when-does-curve_fit-underestimate-the-true-uncertainty"><span
         class="header-section-number">3.6.7</span> When does
         <code>curve_fit</code> underestimate the true uncertainty?</h3>
         <p>The uncertainty reported by <code>curve_fit</code> comes
         from the covariance matrix and assumes:</p>
         <ol type="1">
         <li>The only source of error is random noise in your voltage
         measurements</li>
         <li>This noise is independent for each data point</li>
         <li>Your model perfectly describes the underlying physics</li>
         </ol>
         <p>In real experiments, these assumptions often fail. Consider
         these scenarios relevant to your beam width measurements:</p>
         <p><strong>Systematic errors in position:</strong> - If your
         micrometer has a 0.01 mm systematic offset, this affects all
         measurements the same way - <code>curve_fit</code> doesn’t know
         about this, so it can’t include it in the parameter uncertainty
         - The true uncertainty in beam width includes uncertainty in
         position calibration</p>
         <p><strong>Model limitations:</strong> - The error function
         model assumes a perfectly Gaussian beam - Real laser beams may
         have slight deviations from Gaussian - The fit uncertainty
         assumes the model is exact</p>
         <p><strong>Correlated noise:</strong> - If 60 Hz interference
         affects multiple adjacent points similarly, they’re not
         independent - <code>curve_fit</code> assumes independent
         errors, so it underestimates uncertainty</p>
         <p><strong>Reflection questions:</strong></p>
         <ol type="1">
         <li><p>Under what conditions might the <code>curve_fit</code>
         uncertainty be a good estimate of your true measurement
         uncertainty?</p></li>
         <li><p>In Week 4, you’ll extract beam waist <span
         class="math inline">\(w_0\)</span> from fits at multiple
         positions. Besides random noise in voltage measurements, what
         other sources of uncertainty should you consider? List at least
         two.</p></li>
         </ol>
         <h3 data-number="3.6.8"
         id="random-vs.-systematic-uncertainties"><span
         class="header-section-number">3.6.8</span> Random
         vs. Systematic Uncertainties</h3>
         <p>Understanding the distinction between random and systematic
         uncertainties is crucial for proper error analysis. This
         distinction becomes especially important in Week 4 when you
         construct an uncertainty budget.</p>
         <p><strong>Random uncertainties</strong> are unpredictable
         fluctuations that vary from measurement to measurement. They
         average out over many measurements—take 100 readings and
         compute the mean, and the random uncertainty in that mean
         decreases by <span class="math inline">\(\sqrt{100} =
         10\)</span>.</p>
         <p>Examples from this lab: - Voltage noise on the photodetector
         (varies each reading) - Thermal fluctuations in electronic
         components - Shot noise from random photon arrival times</p>
         <p><strong>Systematic uncertainties</strong> are consistent
         biases that affect all measurements the same way. They do NOT
         average out—take 100 readings and the systematic error remains
         exactly the same.</p>
         <p>Examples from this lab: - Micrometer calibration offset (if
         it reads 0.02 mm high, ALL positions are 0.02 mm high) - DAQ
         voltage offset (shifts all readings by a fixed amount) - Beam
         not perfectly perpendicular to knife edge (consistent
         underestimate of width)</p>
         <p><strong>Why this matters for fitting:</strong></p>
         <p><code>curve_fit</code> only sees random scatter around your
         fit function. It has no way to detect systematic offsets. If
         your micrometer is miscalibrated by 0.1 mm, the fit will find
         parameters that are systematically shifted, and
         <code>curve_fit</code> will not include this in the reported
         uncertainty.</p>
         <p><strong>Quick self-test:</strong> Classify each of these as
         random (R) or systematic (S):</p>
         <ol type="1">
         <li>The photodetector gain knob is actually at 28 dB when the
         label says 30 dB: _____</li>
         <li>60 Hz pickup causing voltage fluctuations: _____</li>
         <li>The laser power slowly drifting over 30 minutes: _____
         (tricky—think about whether it averages out)</li>
         <li>Room lights flickering: _____</li>
         </ol>
         <p><em>Answers: 1=S, 2=R (if averaging over many cycles), 3=S
         (drift is correlated, doesn’t average out), 4=R</em></p>
         <p>In Week 4, when you construct your uncertainty budget, you
         will need to identify the dominant sources of both random AND
         systematic uncertainty, and combine them appropriately.</p>
         <h2 data-number="3.7" id="error-bars"><span
         class="header-section-number">3.7</span> Error bars</h2>
         <p>The error bar is a graphical way to display the uncertainty
         in a measurement. In order to put error bars on a plot you must
         first estimate the error for each point. Anytime you include
         error bars in a plot you should explain how the uncertainty in
         each point was estimated (e.g., you “eyeballed” the
         uncertainty, or you sampled it <span
         class="math inline">\(N\)</span> times and took the standard
         deviation of the mean, etc.)</p>
         <h3 data-number="3.7.1"
         id="error-bars-in-python-with-matplotlib"><span
         class="header-section-number">3.7.1</span> Error bars in Python
         with Matplotlib</h3>
         <p>Creating plots with error bars in Python is straightforward
         using <code>plt.errorbar()</code>:</p>
         <div class="sourceCode" id="cb14"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data with uncertainties</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;gaussian_data_with_errors.txt&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> data[:, <span class="dv">0</span>]      <span class="co"># Position</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[:, <span class="dv">1</span>]      <span class="co"># Voltage</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>y_err <span class="op">=</span> data[:, <span class="dv">2</span>]  <span class="co"># Uncertainty</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plot with error bars</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.errorbar(x, y, yerr<span class="op">=</span>y_err, fmt<span class="op">=</span><span class="st">&#39;o&#39;</span>, capsize<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="st">&#39;Data with uncertainties&#39;</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Micrometer Position (inches)&#39;</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Photodetector Voltage (V)&#39;</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Gaussian Beam Width Measurement&#39;</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <p>The <code>errorbar()</code> function parameters: -
         <code>x</code>, <code>y</code>: Data points -
         <code>yerr</code>: Uncertainty values (can also use
         <code>xerr</code> for horizontal error bars) -
         <code>fmt='o'</code>: Marker style (circles) -
         <code>capsize=3</code>: Size of error bar caps</p>
         <h3 data-number="3.7.2"
         id="example-gaussian-laser-beam-width-measurement"><span
         class="header-section-number">3.7.2</span> Example: Gaussian
         laser beam width measurement</h3>
         <p>Suppose you had estimated the uncertainty at every point in
         a width measurement of your Gaussian laser beam to be <span
         class="math inline">\(0.04 \ V\)</span>. This error was chosen
         to demonstrate the mechanics of making a plot with error bars,
         but the uncertainty in the actual data was probably smaller
         than this.</p>
         <center>
         <table id="tbl:example-data">
         <caption>Table of data with a fixed uncertainty used to
         illustrate creating plots with error bars.</caption>
         <colgroup>
         <col style="width: 35%" />
         <col style="width: 32%" />
         <col style="width: 32%" />
         </colgroup>
         <thead>
         <tr>
         <th style="text-align: center;">Micrometer Position
         (inches)</th>
         <th style="text-align: center;">Photodetector Voltage (V)</th>
         <th style="text-align: center;">Estimated uncertainty (V)</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td style="text-align: center;">0.410</td>
         <td style="text-align: center;">0.015</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.412</td>
         <td style="text-align: center;">0.016</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.414</td>
         <td style="text-align: center;">0.017</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.416</td>
         <td style="text-align: center;">0.026</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.418</td>
         <td style="text-align: center;">0.060</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.420</td>
         <td style="text-align: center;">0.176</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.422</td>
         <td style="text-align: center;">0.460</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.424</td>
         <td style="text-align: center;">0.849</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.426</td>
         <td style="text-align: center;">1.364</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.428</td>
         <td style="text-align: center;">1.971</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.430</td>
         <td style="text-align: center;">2.410</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.432</td>
         <td style="text-align: center;">2.703</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.434</td>
         <td style="text-align: center;">2.795</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.436</td>
         <td style="text-align: center;">2.861</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.438</td>
         <td style="text-align: center;">2.879</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         <tr>
         <td style="text-align: center;">0.440</td>
         <td style="text-align: center;">2.884</td>
         <td style="text-align: center;">0.04</td>
         </tr>
         </tbody>
         </table>
         </center>
         <p><br></p>
         <p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/gaussian_data_with_errors.txt">this
         data set</a> and create a plot with error bars like Figure
         <span class="citation"
         data-cites="fig:gauss-example">@fig:gauss-example</span>.</p>
         <div class="sourceCode" id="cb15"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;gaussian_data_with_errors.txt&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>voltage <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>uncertainty <span class="op">=</span> data[:, <span class="dv">2</span>]</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plot</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.errorbar(position, voltage, yerr<span class="op">=</span>uncertainty,</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>             fmt<span class="op">=</span><span class="st">&#39;o&#39;</span>, capsize<span class="op">=</span><span class="dv">3</span>, markersize<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (inches)&#39;</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Photodetector Output (V)&#39;</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Gaussian Beam Width Measurement&#39;</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <figure id="fig:gauss-example">
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-example.png"
         style="width:15cm"
         alt="Plot of the provided Gaussian Beam data showing error bars." />
         <figcaption aria-hidden="true">Plot of the provided Gaussian
         Beam data showing error bars.</figcaption>
         </figure>
         <h2 data-number="3.8"
         id="prelab-exercise-error-function-fitting-practice"><span
         class="header-section-number">3.8</span> Prelab Exercise: Error
         Function Fitting Practice</h2>
         <p>Now that you understand curve fitting, apply it to beam
         width analysis. This exercise prepares you for analyzing your
         own knife-edge measurements.</p>
         <p><strong>Note on AI assistance:</strong> You may use AI tools
         to help write your curve fitting code. However, the learning
         goal is to understand what the code does and why. Be prepared
         to explain: (1) what the fit parameters mean physically, (2)
         why the error function is the appropriate model, and (3) how to
         interpret the uncertainties reported by
         <code>curve_fit</code>.</p>
         <h3 data-number="3.8.1" id="the-error-function-model"><span
         class="header-section-number">3.8.1</span> The Error Function
         Model</h3>
         <p>In Week 1, you derived that blocking a Gaussian beam with a
         knife edge produces a signal described by:</p>
         <p><span class="math display">\[P(x) = \frac{P_0}{2}\left[1 +
         \text{erf}\left(\frac{\sqrt{2}(x-x_0)}{w}\right)\right]\]</span></p>
         <p>where <span class="math inline">\(w\)</span> is the beam
         width, <span class="math inline">\(x_0\)</span> is the beam
         center position, and <span class="math inline">\(P_0\)</span>
         is the total power.</p>
         <p>For fitting, we use a slightly more general form that
         accounts for offsets:</p>
         <p><span class="math display">\[y(x) = a \cdot
         \text{erf}\left(\frac{\sqrt{2}}{w}(x-b)\right) + c\]</span></p>
         <p>where: - <span class="math inline">\(a\)</span> = amplitude
         (half the voltage swing) - <span
         class="math inline">\(b\)</span> = beam center position - <span
         class="math inline">\(w\)</span> = beam width (what we want!) -
         <span class="math inline">\(c\)</span> = vertical offset</p>
         <h3 data-number="3.8.2" id="practice-exercise"><span
         class="header-section-number">3.8.2</span> Practice
         Exercise</h3>
         <p>Download <a
         href="../resources/lab-guides/gaussian-laser-beams/Test_Profile_Data.csv">Test_Profile_Data.csv</a>
         and complete the following:</p>
         <ol type="1">
         <li><p><strong>Plot the raw data</strong> (position
         vs. voltage). Does it look like an error function?</p></li>
         <li><p><strong>Define the fit function:</strong></p>
         <div class="sourceCode" id="cb16"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> erf_model(x, a, w, b, c):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.&quot;&quot;&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">/</span> w <span class="op">*</span> (x <span class="op">-</span> b)) <span class="op">+</span> c</span></code></pre></div></li>
         <li><p><strong>Perform the fit:</strong></p>
         <div class="sourceCode" id="cb17"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;Test_Profile_Data.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> data[:, <span class="dv">0</span>]  <span class="co"># Position (m)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[:, <span class="dv">1</span>]  <span class="co"># Voltage (V)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses (estimate from your plot)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [<span class="fl">1.0</span>, <span class="fl">0.0005</span>, <span class="fl">0.001</span>, <span class="fl">0.5</span>]  <span class="co"># [a, w, b, c]</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(erf_model, x, y, p0<span class="op">=</span>p0)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))  <span class="co"># Standard errors</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam width w = </span><span class="sc">{</span>popt[<span class="dv">1</span>]<span class="sc">:.2e}</span><span class="ss"> ± </span><span class="sc">{</span>perr[<span class="dv">1</span>]<span class="sc">:.2e}</span><span class="ss"> m&quot;</span>)</span></code></pre></div></li>
         <li><p><strong>Verify your result:</strong> You should get
         <span class="math inline">\(w = 4.52 \times 10^{-4}\)</span> m
         (approximately 0.45 mm).</p></li>
         <li><p><strong>Plot data and fit together</strong> to verify
         the fit is reasonable.</p></li>
         <li><p><strong>Interpret the uncertainties:</strong> What is
         the fractional uncertainty in your beam width? Is this
         uncertainty dominated by random noise or could there be
         systematic effects?</p></li>
         </ol>
         <p><em>Save your fitting code—you will use this same procedure
         to analyze your own knife-edge data in lab.</em></p>
         <h1 data-number="4"
         id="introduction-to-python-for-data-acquisition"><span
         class="header-section-number">4</span> Introduction to Python
         for Data Acquisition</h1>
         <p>In this part of the lab, you will learn to use Python for
         data acquisition. We’ll use the <code>nidaqmx</code> library to
         interface with National Instruments DAQ devices.</p>
         <h2 data-number="4.1" id="development-environment"><span
         class="header-section-number">4.1</span> Development
         Environment</h2>
         <p>For this lab, we recommend starting with <strong>Jupyter
         Notebook</strong> for interactive exploration, then
         transitioning to <strong>VS Code</strong> or another editor for
         writing reusable scripts. See the <a
         href="/PHYS-4430/python-resources">Python Resources</a> page
         for setup instructions.</p>
         <h2 data-number="4.2"
         id="connect-the-usb-6009-and-verify-it-is-working"><span
         class="header-section-number">4.2</span> Connect the USB-6009
         and verify it is working</h2>
         <ol type="1">
         <li><p>Ensure the NI-DAQmx drivers are installed (they should
         already be on lab computers). If needed, download from <a
         href="https://www.ni.com/en-us/support/downloads/drivers/download.ni-daq-mx.html">NI-DAQmx</a>.</p></li>
         <li><p>Connect the USB cable to your computer and the
         USB-6009.</p></li>
         <li><p>Open NI Measurement &amp; Automation Explorer (NI-MAX)
         to verify the device is recognized:</p>
         <ul>
         <li>The device should appear under “Devices and
         Interfaces”</li>
         <li>Right-click and run “Self-Test” to verify the
         connection</li>
         <li>Open the “Test Panel” to test analog inputs manually</li>
         </ul></li>
         <li><p>Use Python to list available DAQ devices:</p>
         <div class="sourceCode" id="cb18"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.system <span class="im">import</span> System</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># List all connected DAQ devices</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> System.local()</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> device <span class="kw">in</span> system.devices:</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Device: </span><span class="sc">{</span>device<span class="sc">.</span>name<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Product Type: </span><span class="sc">{</span>device<span class="sc">.</span>product_type<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  AI Channels: </span><span class="sc">{</span>[ch.name <span class="cf">for</span> ch <span class="kw">in</span> device.ai_physical_chans]<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         <li><p>Connect the 5V power rail to <code>AI0+</code> and
         ground to <code>AI0-</code>. You must connect both wires since
         the device measures a potential difference between the two
         terminals.</p></li>
         <li><p>Read a voltage to verify the connection:</p>
         <div class="sourceCode" id="cb19"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    voltage <span class="op">=</span> task.read()</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Measured voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="4.3" id="reading-multiple-samples"><span
         class="header-section-number">4.3</span> Reading Multiple
         Samples</h2>
         <p>To capture time-varying signals, you need to configure the
         sample rate and number of samples.</p>
         <h3 data-number="4.3.1"
         id="understanding-sample-rate-and-samples-to-read"><span
         class="header-section-number">4.3.1</span> Understanding Sample
         Rate and Samples to Read</h3>
         <p>When acquiring data, you must specify:</p>
         <ul>
         <li><strong>Sample Rate</strong>: How many samples per second
         (Hz)</li>
         <li><strong>Samples to Read</strong>: Total number of samples
         to acquire</li>
         </ul>
         <p>For example, to capture 5 periods of a 1 kHz sine wave with
         20 samples per period:</p>
         <ul>
         <li>Samples to Read = 5 periods × 20 samples/period = 100
         samples</li>
         <li>Total time = 5 periods / 1000 Hz = 5 ms</li>
         <li>Sample Rate = 100 samples / 0.005 s = 20,000 Hz</li>
         </ul>
         <h3 data-number="4.3.2" id="sec:analogmeas"><span
         class="header-section-number">4.3.2</span> Acquiring Multiple
         Samples</h3>
         <div class="sourceCode" id="cb20"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">20000</span>  <span class="co"># Hz</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>samples_to_read <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Acquire data</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    task.timing.cfg_samp_clk_timing(</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        rate<span class="op">=</span>sample_rate,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        samps_per_chan<span class="op">=</span>samples_to_read</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>samples_to_read)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Create time array</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(samples_to_read) <span class="op">/</span> sample_rate</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>plt.plot(time <span class="op">*</span> <span class="dv">1000</span>, data)  <span class="co"># Time in ms</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Acquired Signal&#39;</span>)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="4.3.3" id="exercise-capture-a-waveform"><span
         class="header-section-number">4.3.3</span> Exercise: Capture a
         Waveform</h3>
         <ol type="1">
         <li>Connect your waveform generator to both an oscilloscope and
         your DAQ device.</li>
         <li>Set the waveform generator to output a sine wave at a
         frequency compatible with your sample rate calculation.</li>
         <li>Modify the sample rate and samples to read to capture
         approximately 5 complete periods.</li>
         <li>Run the acquisition and compare the Python plot with the
         oscilloscope display. Are they compatible?</li>
         <li>Add to your notebook: the Python code, the resulting plot,
         and the oscilloscope output. Explain how they all make sense
         together.</li>
         </ol>
         <h1 data-number="5"
         id="digital-sampling-and-nyquist-frequency"><span
         class="header-section-number">5</span> Digital Sampling and
         Nyquist Frequency</h1>
         <p>Now that you can acquire data with the DAQ, it’s important
         to understand how the choice of sample rate affects your
         measurements. This section explores what happens when you
         sample a signal too slowly.</p>
         <h2 data-number="5.1" id="exploring-sample-rate-effects"><span
         class="header-section-number">5.1</span> Exploring Sample Rate
         Effects</h2>
         <ol type="1">
         <li><p>Modify your Python script so that the <em>Number of
         Samples</em> and <em>Sample Rate</em> are easily configurable
         variables at the top:</p>
         <div class="sourceCode" id="cb21"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration - easily adjustable</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>SAMPLE_RATE <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Samples per second</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>NUM_SAMPLES <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Total samples (1 second of data)</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>DAQ_CHANNEL <span class="op">=</span> <span class="st">&quot;Dev1/ai0&quot;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acquire_data(sample_rate, num_samples, channel):</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Acquire data from DAQ with specified parameters.&quot;&quot;&quot;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(channel)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>num_samples)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(data)</span></code></pre></div></li>
         <li><p>Set up a function generator to produce a <strong>1 kHz
         sine wave</strong>.</p></li>
         <li><p>Connect the function generator’s output to both the
         oscilloscope and the DAQ.</p></li>
         </ol>
         <h2 data-number="5.2" id="initial-measurements"><span
         class="header-section-number">5.2</span> Initial
         Measurements</h2>
         <ol type="1">
         <li><p>Set the sample rate in your Python script to <strong>500
         samples per second</strong> and the number of samples such that
         it records 1 second of data.</p></li>
         <li><p>Record and plot a dataset with both the oscilloscope and
         the DAQ. Make sure that the time range on the oscilloscope is
         set such that it is on the same order as the data being
         recorded by the DAQ.</p>
         <div class="sourceCode" id="cb22"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Acquire and plot data</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> acquire_data(SAMPLE_RATE, NUM_SAMPLES, DAQ_CHANNEL)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(NUM_SAMPLES) <span class="op">/</span> SAMPLE_RATE</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>plt.plot(time, data)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (s)&#39;</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f&#39;Acquired Signal (</span><span class="sc">{</span>SAMPLE_RATE<span class="sc">}</span><span class="ss"> Hz sample rate)&#39;</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Compare the two plots. What are the major differences
         between the two?</p></li>
         <li><p>Why might one or both of these plots be giving an
         incorrect result? Think about the wave you are measuring and
         the result you are getting. How do they relate?</p></li>
         </ol>
         <h2 data-number="5.3" id="enhanced-understanding"><span
         class="header-section-number">5.3</span> Enhanced
         Understanding</h2>
         <p>This section will guide you to an understanding of Nyquist’s
         theorem and a more appropriate sample rate for digital data
         collection.</p>
         <ol type="1">
         <li><p>Why do you think the data from the DAQ produced a wave
         of lower frequency?</p></li>
         <li><p>Adjust the sample rate in a way you think might provide
         a more accurate measurement of the wave. What do you think the
         measured waveform will look like this time?</p></li>
         <li><p>Take a dataset, record and plot it. Did it match your
         predictions?</p></li>
         <li><p>Now record another dataset with the function generator
         set to the same parameters but the sample rate set to
         <strong>3000 samples per second</strong> and the number of
         samples set to record 1 second of data.</p></li>
         <li><p>Plot this new dataset. What is the frequency of the new
         dataset?</p></li>
         <li><p>What are the fundamental differences between the first,
         second, and third datasets?</p></li>
         </ol>
         <h2 data-number="5.4" id="nyquist-frequency"><span
         class="header-section-number">5.4</span> Nyquist Frequency</h2>
         <p>The discrepancies between the sampled waveforms can be
         explained by <strong>Nyquist’s theorem</strong>. It states that
         to accurately measure a signal by discrete sampling methods
         (like the DAQ) the sampling rate must be at least twice that of
         the measured signal. If this were not the case, a measurement
         might not be taken at every interval of oscillation, a
         situation called “undersampling.” Sampling the signal at least
         twice as fast as the maximum frequency of interest ensures that
         at least two data points are recorded each period.</p>
         <p><strong>Definition:</strong></p>
         <p>The <em>Nyquist Frequency</em> is defined to be half the
         sample rate.</p>
         <h3 data-number="5.4.1" id="aliasing-exercises"><span
         class="header-section-number">5.4.1</span> Aliasing
         Exercises</h3>
         <ol type="1">
         <li><p><strong>Predict</strong> the <em>apparent</em> frequency
         (in Hz) of the signal recorded by the DAQ.
         <strong>Observe</strong> what really happens using your
         waveform generator, DAQ, and Python script.
         <strong>Explain</strong> the result. Suppose the DAQ is set to
         1 kS/s sample rate in all of the cases, while the waveform
         generator is set to:</p>
         <ol type="1">
         <li>1000 Hz</li>
         <li>998 Hz</li>
         <li>1004 Hz</li>
         <li>1500 Hz</li>
         <li>2000 Hz</li>
         <li>1997 Hz</li>
         <li>2005 Hz</li>
         </ol>
         <p>In understanding what is going on, it may help to draw a few
         periods of the wave and then indicate where the DAQ will sample
         the waveform.</p></li>
         <li><p>You <em>want</em> to measure the random fluctuations
         (noise) in a signal from 0-100 Hz.</p>
         <ol type="1">
         <li>If you set the sample rate at 200 Hz, what set of frequency
         ranges will contribute to the noise measurement?</li>
         <li>If you set the sample rate at 1000 Hz, what set of
         frequency ranges will contribute to the noise measurement?</li>
         <li>How could you help achieve the desired measurement in 2.1
         using a combination of changing the sample rate and adding
         filtering? Explain why your choice of sample rate and signal
         filter would work better.</li>
         </ol></li>
         <li><p><strong>Undersampling on the oscilloscope.</strong>
         Undersampling is an issue with any device that samples data at
         regular discrete time intervals. This question requires the use
         of a Rigol DS1052E oscilloscope and a waveform generator.</p>
         <ol type="1">
         <li>Figure <span class="citation"
         data-cites="fig:scope-menu">@fig:scope-menu</span> is copied
         from the Rigol Oscilloscope manual. The Horizontal menu allows
         you to view the actual sample rate “Sa Rate” of the digital
         acquisition on the scope.</li>
         <li>Predict what should you observe if you set the waveform
         generator to the same frequency as the sample rate? Try it out,
         compare with your prediction, and explain your
         observations.</li>
         <li>What happens if you change the oscilloscope time scale? Or
         change the waveform generator frequency slightly? Try to
         explain what you observe.</li>
         </ol></li>
         </ol>
         <figure id="fig:scope-menu">
         <img
         src="../resources/lab-guides/gaussian-laser-beams/scope-menu.png"
         style="width:20cm"
         alt="The horizontal menu on the Rigol DS1052E Oscilloscope." />
         <figcaption aria-hidden="true">The horizontal menu on the Rigol
         DS1052E Oscilloscope.</figcaption>
         </figure>
         <h1 data-number="6"
         id="photodetector-noise-characterization"><span
         class="header-section-number">6</span> Photodetector Noise
         Characterization</h1>
         <p>In Week 1, you calibrated your photodetector’s gain and
         offset at several settings. You may have noticed that at higher
         gain settings, the signal becomes “noisier.” This is not a
         flaw—it’s a fundamental tradeoff in amplified
         photodetectors.</p>
         <p>In this section, you will:</p>
         <ol type="1">
         <li>Measure the noise floor at different gain settings and
         compare to datasheet specifications</li>
         <li>Predict how signal-to-noise ratio depends on gain, then
         verify experimentally</li>
         <li>Select and justify a gain setting for Week 4 based on
         quantitative analysis</li>
         </ol>
         <p>This matters because in Week 4, you will measure beam
         profiles where the signal varies over a wide range. Choosing
         the right gain setting requires balancing amplification against
         added noise.</p>
         <h2 data-number="6.1"
         id="background-noise-in-amplified-photodetectors"><span
         class="header-section-number">6.1</span> Background: Noise in
         Amplified Photodetectors</h2>
         <h3 data-number="6.1.1" id="sources-of-noise"><span
         class="header-section-number">6.1.1</span> Sources of
         Noise</h3>
         <p>The photodetector datasheet specifies “Output Noise (RMS)”
         at each gain setting. This noise comes from several
         sources:</p>
         <ul>
         <li><strong>Shot noise</strong>: Random arrival times of
         photons, proportional to √signal</li>
         <li><strong>Johnson noise</strong>: Thermal noise in resistors,
         independent of signal</li>
         <li><strong>Amplifier noise</strong>: The transimpedance
         amplifier adds its own noise</li>
         </ul>
         <p>At low signal levels, amplifier and Johnson noise dominate.
         At high signal levels, shot noise becomes significant.</p>
         <h3 data-number="6.1.2" id="the-gain-noise-tradeoff"><span
         class="header-section-number">6.1.2</span> The Gain-Noise
         Tradeoff</h3>
         <p>Higher gain amplifies your signal, but also amplifies
         internal noise sources.</p>
         <p><strong>Important:</strong> Your lab station has either a
         <strong>PDA36A</strong> or <strong>PDA36A2</strong>
         photodetector. These have different noise specifications! Check
         the label on your detector and look up the specifications in
         the appropriate datasheet (both are available in the lab).</p>
         <p><strong>Fill in the datasheet values for YOUR
         detector:</strong></p>
         <table style="width:100%;">
         <colgroup>
         <col style="width: 17%" />
         <col style="width: 27%" />
         <col style="width: 27%" />
         <col style="width: 27%" />
         </colgroup>
         <thead>
         <tr>
         <th>Gain Setting</th>
         <th>Transimpedance (V/A)</th>
         <th>Datasheet Noise RMS</th>
         <th>Datasheet Bandwidth</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>0 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>30 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>50 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>70 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <p><strong>Calculate:</strong> What is the ratio of noise at 70
         dB to noise at 0 dB for your detector? _______</p>
         <p><em>Note: The PDA36A and PDA36A2 have quite different noise
         characteristics—the A2 version has significantly lower noise at
         high gain settings. The datasheet noise values assume full
         bandwidth at each gain setting. Higher gain settings have lower
         bandwidth, which actually reduces high-frequency noise. This is
         one reason noise doesn’t scale directly with gain. For the
         quasi-DC measurements in this lab, bandwidth effects are
         negligible.</em></p>
         <h3 data-number="6.1.3" id="signal-to-noise-ratio-snr"><span
         class="header-section-number">6.1.3</span> Signal-to-Noise
         Ratio (SNR)</h3>
         <p>The signal-to-noise ratio determines measurement
         precision:</p>
         <p><span class="math display">\[\text{SNR} =
         \frac{V_{\text{signal}}}{V_{\text{noise, RMS}}}\]</span></p>
         <p>For meaningful measurements, you generally want SNR &gt; 10
         (distinguishable from noise) or SNR &gt; 100 (precise
         measurements).</p>
         <p><strong>Prelab Questions:</strong></p>
         <p><em>Use the datasheet values you recorded in the table
         above.</em></p>
         <ol type="1">
         <li><p>If your photodetector signal is 10 mV at 0 dB gain, what
         is the approximate SNR using your detector’s datasheet noise
         value at 0 dB? <em>(1-2 sentences with
         calculation)</em></p></li>
         <li><p>If you increase to 30 dB gain (~32× voltage gain),
         predict what happens to: (a) the signal voltage, (b) the noise
         voltage (use your datasheet values), and (c) the SNR. Show your
         calculation. <em>(Show numerical work for each
         part)</em></p></li>
         <li><p>At what gain setting would SNR reach a maximum? What
         limits SNR at very high gain? <em>(2-3 sentences; consider what
         happens when signal approaches saturation)</em></p></li>
         </ol>
         <h2 data-number="6.2"
         id="part-1-measuring-the-noise-floor"><span
         class="header-section-number">6.2</span> Part 1: Measuring the
         Noise Floor</h2>
         <h3 data-number="6.2.1" id="dark-noise-measurement"><span
         class="header-section-number">6.2.1</span> Dark Noise
         Measurement</h3>
         <p>You will measure the “dark noise”—the output when no light
         reaches the photodetector.</p>
         <ol type="1">
         <li><p><strong>Block all light</strong> from reaching the
         photodetector using the aperture cap. Even small amounts of
         ambient light will affect your measurement.</p></li>
         <li><p><strong>Configure the oscilloscope:</strong></p>
         <ul>
         <li>Connect photodetector output to CH1</li>
         <li>Set vertical scale to show the noise (~1 mV/div)</li>
         <li>Set horizontal scale to ~1 ms/div</li>
         <li>Enable RMS measurement (Measure → Type → RMS)</li>
         </ul></li>
         <li><p><strong>Measure at four gain settings:</strong> 0 dB, 30
         dB, 50 dB, and 70 dB.</p></li>
         </ol>
         <p><strong>Data Table:</strong> (Transfer your datasheet values
         from the Background section)</p>
         <table>
         <colgroup>
         <col style="width: 8%" />
         <col style="width: 27%" />
         <col style="width: 24%" />
         <col style="width: 39%" />
         </colgroup>
         <thead>
         <tr>
         <th>Gain</th>
         <th>Measured Noise RMS</th>
         <th>Datasheet Noise</th>
         <th>Ratio (Measured/Datasheet)</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>0 dB</td>
         <td>_______ mV</td>
         <td>_______ mV</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>30 dB</td>
         <td>_______ mV</td>
         <td>_______ mV</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>50 dB</td>
         <td>_______ mV</td>
         <td>_______ mV</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>70 dB</td>
         <td>_______ mV</td>
         <td>_______ mV</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <p><strong>In-Lab Questions:</strong></p>
         <ol type="1">
         <li><p>How do your measured values compare to the datasheet? If
         they differ by more than 50%, identify possible reasons
         (ambient light leaks? ground loops? cable quality?).</p></li>
         <li><p>What noise ratio (70 dB / 0 dB) did you measure? How
         does this compare to the datasheet ratio you calculated
         earlier? What does this tell you about the dominant noise
         source?</p></li>
         </ol>
         <h2 data-number="6.3"
         id="part-2-signal-to-noise-measurement"><span
         class="header-section-number">6.3</span> Part 2:
         Signal-to-Noise Measurement</h2>
         <p>Now add a known optical signal and measure how SNR changes
         with gain.</p>
         <h3 data-number="6.3.1" id="setup"><span
         class="header-section-number">6.3.1</span> Setup</h3>
         <p>Use your Week 1 laser alignment. Insert a neutral density
         filter (ND 1.0 or ND 2.0) to attenuate the beam so you get a
         moderate signal (~0.5 V above offset at 30 dB).</p>
         <h3 data-number="6.3.2" id="prediction"><span
         class="header-section-number">6.3.2</span> Prediction</h3>
         <p>Before measuring, predict the SNR at each gain setting. Use
         your prelab calculations and Week 1 calibration data.</p>
         <table>
         <thead>
         <tr>
         <th>Gain</th>
         <th>Predicted Signal (V)</th>
         <th>Predicted Noise (mV)</th>
         <th>Predicted SNR</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>0 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>30 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>50 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>70 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <h3 data-number="6.3.3" id="measurement"><span
         class="header-section-number">6.3.3</span> Measurement</h3>
         <p>Now measure and compare to your predictions:</p>
         <table>
         <colgroup>
         <col style="width: 7%" />
         <col style="width: 24%" />
         <col style="width: 24%" />
         <col style="width: 17%" />
         <col style="width: 25%" />
         </colgroup>
         <thead>
         <tr>
         <th>Gain</th>
         <th>Measured Signal (V)</th>
         <th>Measured Noise (mV)</th>
         <th>Measured SNR</th>
         <th>Prediction Correct?</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>0 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>30 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>50 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>70 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <p><strong>Important:</strong> If your predictions and
         measurements disagree, do NOT adjust your analysis to force
         agreement. Discrepancies are scientifically valuable—they
         reveal either a gap in your understanding or an uncontrolled
         variable in your experiment. Report your actual measurements
         honestly and investigate the cause of any disagreement.</p>
         <p><strong>In-Lab Questions:</strong></p>
         <ol type="1">
         <li><p>At which gain setting did you measure the highest SNR?
         Does this match your prediction?</p></li>
         <li><p>Did any measurements saturate (signal &gt; 4.5 V)? How
         does saturation affect your gain choice?</p></li>
         <li><p>If your predictions were wrong, identify the source of
         the discrepancy.</p></li>
         </ol>
         <h2 data-number="6.4"
         id="part-3-automating-noise-measurements"><span
         class="header-section-number">6.4</span> Part 3: Automating
         Noise Measurements</h2>
         <p>You will write Python code to automate noise measurements
         using the DAQ. This uses the same DAQ you will use in Week 4,
         so your noise characterization will directly apply.</p>
         <h3 data-number="6.4.1" id="design-decisions"><span
         class="header-section-number">6.4.1</span> Design
         Decisions</h3>
         <p>Before writing code, answer these questions:</p>
         <ol type="1">
         <li><p><strong>Sampling parameters:</strong> How many samples
         do you need to get a reliable RMS estimate? What sample rate
         should you use? (Hint: consider the Nyquist criterion and the
         noise frequencies you want to capture.)</p></li>
         <li><p><strong>Measurement statistics:</strong> If you take N
         samples, what is the uncertainty in your RMS estimate? How does
         this scale with N?</p></li>
         <li><p><strong>What to measure:</strong> The DAQ returns raw
         voltage samples. How will you compute: (a) the DC level, and
         (b) the RMS noise?</p></li>
         </ol>
         <h3 data-number="6.4.2" id="code-framework"><span
         class="header-section-number">6.4.2</span> Code Framework</h3>
         <p>Write a function that measures noise using the DAQ. You may
         use AI assistance to help write the code, but you must answer
         the Design Decisions questions (above) BEFORE generating code,
         and you must be able to explain your implementation.</p>
         <div class="sourceCode" id="cb23"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_noise(channel<span class="op">=</span><span class="st">&quot;Dev1/ai0&quot;</span>, num_samples<span class="op">=</span>???, sample_rate<span class="op">=</span>???):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Measure DC level and RMS noise from the photodetector.</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">        channel: DAQ channel connected to photodetector</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">        num_samples: Number of samples to acquire (you decide)</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">        sample_rate: Sampling rate in Hz (you decide)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">        dc_level: Mean voltage (V)</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co">        noise_rms: RMS noise (V)</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Your implementation here</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">#</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hints:</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Use nidaqmx.Task() context manager</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Configure with task.ai_channels.add_ai_voltage_chan()</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Set timing with task.timing.cfg_samp_clk_timing()</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Read data with task.read()</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Compute statistics with numpy</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div>
         <p><strong>Implementation Questions:</strong></p>
         <ol type="1">
         <li><p>What values did you choose for <code>num_samples</code>
         and <code>sample_rate</code>? Justify your choices based on
         your answers to the Design Decisions questions.</p></li>
         <li><p>Run your function with the photodetector dark (capped).
         Compare the DAQ noise measurement to your oscilloscope
         measurement from Part 1. Do they agree? If not, why might they
         differ?</p></li>
         <li><p><strong>Measure the DAQ’s intrinsic noise
         floor:</strong> Disconnect the photodetector and short the DAQ
         input (connect the signal wire to ground). Measure the RMS
         noise. This is the DAQ’s contribution, independent of the
         photodetector. At which photodetector gain settings does this
         DAQ noise become significant compared to the photodetector
         noise?</p></li>
         </ol>
         <h3 data-number="6.4.3"
         id="understanding-your-code-required"><span
         class="header-section-number">6.4.3</span> Understanding Your
         Code (Required)</h3>
         <p>Whether you wrote the code yourself or with AI assistance,
         answer these questions in your notebook:</p>
         <ol type="1">
         <li><p><strong>Parameter justification:</strong> Explain in 2-3
         sentences why your chosen <code>sample_rate</code> is
         appropriate. What would happen if you used 100 Hz instead? What
         about 100 kHz?</p></li>
         <li><p><strong>Verification test:</strong> Describe a simple
         test you could run to verify your function is working
         correctly. (Hint: you could compare to oscilloscope
         measurements, or test with a known signal.)</p></li>
         <li><p><strong>Extension:</strong> How would you modify this
         function to automatically measure noise at multiple gain
         settings? (You don’t need to implement this—just describe the
         approach.)</p></li>
         </ol>
         <h3 data-number="6.4.4"
         id="debugging-exercise-find-the-bugs"><span
         class="header-section-number">6.4.4</span> Debugging Exercise:
         Find the Bugs</h3>
         <p>The following code was generated by an AI assistant to
         measure noise, but it contains THREE bugs. Find and fix each
         one, then explain what was wrong.</p>
         <div class="sourceCode" id="cb24"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_noise_buggy(channel<span class="op">=</span><span class="st">&quot;Dev1/ai0&quot;</span>, num_samples<span class="op">=</span><span class="dv">1000</span>, sample_rate<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Measure DC level and RMS noise. Contains 3 bugs!&quot;&quot;&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(channel)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span><span class="dv">100</span>)  <span class="co"># Bug #1</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        dc_level <span class="op">=</span> np.mean(data)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        noise_rms <span class="op">=</span> np.mean((data <span class="op">-</span> dc_level)<span class="op">**</span><span class="dv">2</span>)  <span class="co"># Bug #2</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dc_level, noise_rms  <span class="co"># Bug #3</span></span></code></pre></div>
         <p><strong>Hints:</strong> - Bug #1 is a mismatch between what
         you asked for and what you read - Bug #2 is a mathematical
         error in computing RMS - Bug #3 is a subtle issue with
         units/interpretation</p>
         <p><strong>In your notebook:</strong> 1. Identify each bug and
         explain what’s wrong 2. Write the corrected line of code for
         each 3. Explain how you would detect each bug if you didn’t
         know it was there (what test would reveal the problem?)</p>
         <p>This exercise tests your understanding of the code, not just
         your ability to run it. Being able to debug code—whether
         AI-generated or your own—is an essential skill.</p>
         <h2 data-number="6.5"
         id="part-4-choosing-your-week-4-gain-setting"><span
         class="header-section-number">6.5</span> Part 4: Choosing Your
         Week 4 Gain Setting</h2>
         <p>In Week 4, you will measure beam profiles where signal
         varies from near-zero (beam blocked) to maximum (full beam).
         You need to choose a gain setting that works across this entire
         range.</p>
         <h3 data-number="6.5.1" id="your-signal-range"><span
         class="header-section-number">6.5.1</span> Your Signal
         Range</h3>
         <p>From your Week 1 measurements (without ND filter):</p>
         <ul>
         <li>Maximum signal (full beam): _______ V at 0 dB gain</li>
         <li>This corresponds to: _______ V at 30 dB, _______ V at 50
         dB, _______ V at 70 dB</li>
         </ul>
         <h3 data-number="6.5.2" id="the-constraints"><span
         class="header-section-number">6.5.2</span> The Constraints</h3>
         <p>You face two competing constraints:</p>
         <ol type="1">
         <li><strong>Saturation limit:</strong> Signal must stay below
         ~4.5 V</li>
         <li><strong>Noise floor:</strong> Signal must be detectable
         above noise (SNR &gt; 10)</li>
         </ol>
         <h3 data-number="6.5.3" id="analysis"><span
         class="header-section-number">6.5.3</span> Analysis</h3>
         <p>Answer these questions to determine your optimal gain:</p>
         <ol type="1">
         <li><p><strong>Saturation:</strong> At which gain settings
         would your maximum signal saturate? (Show
         calculation.)</p></li>
         <li><p><strong>Noise floor:</strong> During a beam profile
         scan, the minimum signal occurs when the beam is nearly
         blocked. Estimate the smallest signal you need to measure
         (hint: think about the Gaussian tail at 2-3 beam widths from
         center). At each gain setting, would this minimum signal have
         SNR &gt; 10?</p></li>
         <li><p><strong>The tradeoff:</strong> Based on your answers,
         which gain setting(s) satisfy both constraints? If multiple
         settings work, which would you choose and why?</p></li>
         <li><p><strong>Propagation to beam width:</strong> This is the
         critical connection. Your beam width <span
         class="math inline">\(w\)</span> is extracted from fitting the
         error function to your profile data. If your voltage
         measurements have uncertainty <span
         class="math inline">\(\sigma_V\)</span> due to noise, this
         propagates to uncertainty <span
         class="math inline">\(\sigma_w\)</span> in beam width.</p>
         <p>For an error function fit, the uncertainty in the width
         parameter scales approximately as:</p>
         <p><span class="math display">\[\sigma_w \approx
         \frac{\sigma_V}{|dV/dx|_{\text{max}}}\]</span></p>
         <p>where <span
         class="math inline">\(|dV/dx|_{\text{max}}\)</span> is the
         maximum slope of your profile (at the beam center).</p>
         <p><em>Note: This approximation captures the dominant effect of
         noise on fit precision. A rigorous treatment would use the full
         covariance matrix from the least-squares fit, which accounts
         for the number of data points and correlations between
         parameters. You will encounter this in Week 3’s curve fitting
         analysis.</em></p>
         <p>Using your Week 1 beam width measurement (~0.5 mm) and the
         voltage swing across the profile, estimate <span
         class="math inline">\(\sigma_w\)</span> for your chosen gain
         setting. Is this acceptable for your Week 4
         measurements?</p></li>
         </ol>
         <h3 data-number="6.5.4" id="your-decision"><span
         class="header-section-number">6.5.4</span> Your Decision</h3>
         <p><strong>Selected gain setting for Week 4:</strong> _______
         dB</p>
         <p><strong>Justification (2-3 sentences):</strong></p>
         <hr />
         <hr />
         <h2 data-number="6.6"
         id="peer-comparison-gain-setting-choices"><span
         class="header-section-number">6.6</span> Peer Comparison: Gain
         Setting Choices</h2>
         <p>Compare your gain setting decision with another group. This
         discussion builds scientific argumentation skills—in research,
         different groups often make different but equally valid
         experimental choices.</p>
         <ol type="1">
         <li><p><strong>Share your selected gain setting</strong> and
         the key reasoning behind your choice.</p></li>
         <li><p><strong>Compare approaches:</strong> Did they weight the
         tradeoffs (saturation vs. noise floor) differently? Did they
         consider factors you overlooked?</p></li>
         <li><p><strong>Explore disagreements:</strong> If you chose
         different settings, discuss whether both choices can be valid.
         What measurement conditions favor one choice over the
         other?</p></li>
         <li><p><strong>Document briefly</strong> in your notebook:</p>
         <ul>
         <li>The other group’s chosen gain setting: _______ dB</li>
         <li>Their primary justification (1 sentence):
         _______________________</li>
         <li>One insight from the discussion that changed or confirmed
         your thinking: _______________________</li>
         </ul></li>
         </ol>
         <p><em>In science, disagreements are productive when they are
         grounded in evidence. Your goal is not to determine who is
         “right” but to understand why reasonable approaches can
         differ.</em></p>
         <h2 data-number="6.7"
         id="part-5-week-4-validation-to-complete-in-week-4"><span
         class="header-section-number">6.7</span> Part 5: Week 4
         Validation (To Complete in Week 4)</h2>
         <p>Before your first automated beam profile scan, validate your
         gain choice:</p>
         <ol type="1">
         <li><p>With the beam fully blocked, acquire 100 samples. Record
         the mean and RMS.</p></li>
         <li><p>With the beam fully exposed, acquire 100 samples. Record
         the mean and RMS.</p></li>
         <li><p>Calculate your actual SNR at maximum signal. Does it
         match your Week 2 prediction?</p></li>
         <li><p>If your SNR is significantly different from predicted,
         identify why and decide whether to adjust your gain
         setting.</p></li>
         </ol>
         <table>
         <thead>
         <tr>
         <th>Measurement</th>
         <th>Week 2 Prediction</th>
         <th>Week 4 Actual</th>
         <th>Agreement?</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>Dark noise RMS</td>
         <td>_______ mV</td>
         <td>_______ mV</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>Max signal</td>
         <td>_______ V</td>
         <td>_______ V</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>SNR at max</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         </tbody>
         </table>
         <p><strong>Reflection Question:</strong> What did you learn
         from this predict-measure-compare cycle? Consider: Was your
         Week 2 prediction useful for Week 4? What would you do
         differently if characterizing a new piece of equipment in the
         future?</p>
         <hr />
         <hr />
         <p>This validation step closes the loop on your experimental
         decision-making process.</p>
         <h2 data-number="6.8"
         id="looking-ahead-connecting-noise-to-uncertainty"><span
         class="header-section-number">6.8</span> Looking Ahead:
         Connecting Noise to Uncertainty</h2>
         <p>The noise measurements you made today will directly inform
         your Week 4 analysis. Here’s how the pieces connect:</p>
         <ol type="1">
         <li><strong>Week 2 (today):</strong> You measured RMS noise at
         your chosen gain setting</li>
         <li><strong>Week 3 (next week):</strong> You’ll learn error
         propagation—how uncertainties in measurements become
         uncertainties in derived quantities</li>
         <li><strong>Week 4:</strong> The noise you measured here
         determines the uncertainty in each beam profile point, which
         propagates through your curve fit to give uncertainty in beam
         width <span class="math inline">\(w\)</span> and waist position
         <span class="math inline">\(z_w\)</span></li>
         </ol>
         <p>Keep your noise characterization data accessible—you’ll need
         it when propagating uncertainties in Week 3’s prelab
         exercises.</p>
         <h2 data-number="6.9"
         id="noise-characterization-troubleshooting"><span
         class="header-section-number">6.9</span> Noise Characterization
         Troubleshooting</h2>
         <p><strong>Noise much higher than datasheet:</strong></p>
         <ul>
         <li>Check for ambient light leaks (cap the aperture
         completely)</li>
         <li>Verify BNC cables are properly shielded</li>
         <li>Check for ground loops (try different USB ports, isolate
         equipment)</li>
         </ul>
         <p><strong>DAQ and oscilloscope give different noise
         values:</strong></p>
         <ul>
         <li>Different input impedances (oscilloscope 1 MΩ vs DAQ
         variable)</li>
         <li>Different sampling rates capture different noise
         frequencies</li>
         <li>DAQ has its own noise floor (you measured this in Part
         3)</li>
         </ul>
         <p><strong>SNR doesn’t improve at higher gain:</strong></p>
         <ul>
         <li>You may be in the shot-noise-limited regime
         (signal-dominated noise)</li>
         <li>This is actually good—it means the signal is strong</li>
         </ul>
         <p><strong>Predictions don’t match measurements:</strong></p>
         <ul>
         <li>Check that signal isn’t saturating</li>
         <li>Verify ND filter is properly positioned</li>
         <li>Account for any changes in laser alignment from Week 1</li>
         </ul>
         <h1 data-number="7"
         id="saving-data-and-additional-daq-features"><span
         class="header-section-number">7</span> Saving Data and
         Additional DAQ Features</h1>
         <h2 data-number="7.1" id="saving-data-to-a-file"><span
         class="header-section-number">7.1</span> Saving Data to a
         File</h2>
         <p>Save your acquired data to a CSV file for later
         analysis:</p>
         <div class="sourceCode" id="cb25"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># After acquiring data...</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a timestamp for the filename</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>timestamp <span class="op">=</span> datetime.now().strftime(<span class="st">&quot;%Y%m</span><span class="sc">%d</span><span class="st">_%H%M%S&quot;</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> <span class="ss">f&quot;data_</span><span class="sc">{</span>timestamp<span class="sc">}</span><span class="ss">.csv&quot;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create time array</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(<span class="bu">len</span>(data)) <span class="op">/</span> sample_rate</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Save to CSV</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>np.savetxt(</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    filename,</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    np.column_stack([time, data]),</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>,</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    header<span class="op">=</span><span class="st">&#39;Time (s), Voltage (V)&#39;</span>,</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    comments<span class="op">=</span><span class="st">&#39;&#39;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Data saved to </span><span class="sc">{</span>filename<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <h3 data-number="7.1.1"
         id="exercise-save-and-reload-data"><span
         class="header-section-number">7.1.1</span> Exercise: Save and
         Reload Data</h3>
         <ol type="1">
         <li><p>Acquire a waveform and save it to a CSV file.</p></li>
         <li><p>Load the data back and plot it:</p>
         <div class="sourceCode" id="cb26"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>loaded_data <span class="op">=</span> np.loadtxt(filename, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>time_loaded <span class="op">=</span> loaded_data[:, <span class="dv">0</span>]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>voltage_loaded <span class="op">=</span> loaded_data[:, <span class="dv">1</span>]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>plt.plot(time_loaded <span class="op">*</span> <span class="dv">1000</span>, voltage_loaded)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Loaded Data&#39;</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Verify the loaded data matches your original
         acquisition.</p></li>
         </ol>
         <h2 data-number="7.2" id="generating-an-analog-output"><span
         class="header-section-number">7.2</span> Generating an Analog
         Output</h2>
         <p>The USB-6009 can also generate analog voltages (though at a
         limited rate of 150 S/s). Note that the USB-6009’s analog
         outputs have a range of 0-5V only, so we must specify this
         range explicitly:</p>
         <div class="sourceCode" id="cb27"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Output a DC voltage</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    task.ao_channels.add_ao_voltage_chan(<span class="st">&quot;Dev1/ao0&quot;</span>, min_val<span class="op">=</span><span class="fl">0.0</span>, max_val<span class="op">=</span><span class="fl">5.0</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    task.write(<span class="fl">2.5</span>, auto_start<span class="op">=</span><span class="va">True</span>)  <span class="co"># Output 2.5 V</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Outputting 2.5 V on AO0&quot;</span>)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">input</span>(<span class="st">&quot;Press Enter to stop...&quot;</span>)</span></code></pre></div>
         <h3 data-number="7.2.1" id="exercise-test-analog-output"><span
         class="header-section-number">7.2.1</span> Exercise: Test
         Analog Output</h3>
         <ol type="1">
         <li>Configure your DAQ to output a voltage on
         <code>AO0</code>.</li>
         <li>Connect <code>AO0</code> to <code>AI0</code> (loopback
         test).</li>
         <li>Write a script that:
         <ul>
         <li>Outputs a voltage on <code>AO0</code></li>
         <li>Reads the voltage on <code>AI0</code></li>
         <li>Verifies they match</li>
         </ul></li>
         </ol>
         <h2 data-number="7.3" id="error-handling"><span
         class="header-section-number">7.3</span> Error Handling</h2>
         <p>Always include error handling in your data acquisition
         code:</p>
         <div class="sourceCode" id="cb28"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.errors <span class="im">import</span> DaqError</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        voltage <span class="op">=</span> task.read()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> DaqError <span class="im">as</span> e:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;DAQ Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Check that:&quot;</span>)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - The DAQ device is connected&quot;</span>)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - The device name is correct (try &#39;Dev1&#39;, &#39;Dev2&#39;, etc.)&quot;</span>)</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  - NI-DAQmx drivers are installed&quot;</span>)</span></code></pre></div>
         <h1 data-number="8" id="summary"><span
         class="header-section-number">8</span> Summary</h1>
         <p>In this lab, you learned to:</p>
         <ol type="1">
         <li>Connect and verify a USB DAQ device</li>
         <li>Read single and multiple voltage samples</li>
         <li>Configure sample rate and acquisition timing</li>
         <li>Explain Nyquist’s theorem and recognize aliasing</li>
         <li>Choose appropriate sample rates for your signals</li>
         <li>Characterize the photodetector’s noise floor at different
         gain settings</li>
         <li>Calculate and measure signal-to-noise ratio</li>
         <li>Make a quantitative decision about optimal gain for Week 4
         measurements</li>
         <li>Save data to CSV files</li>
         <li>Generate analog output voltages</li>
         <li>Handle common errors</li>
         </ol>
         <p>These skills form the foundation for the automated
         measurements you’ll perform in Week 4. Your gain setting
         decision, based on your noise characterization, will directly
         impact the quality of your beam profile data. See the <a
         href="/PHYS-4430/python-resources">Python Resources</a> page
         and the example scripts in the <code>python/</code> folder for
         more detailed examples.</p>
         <h1 data-number="9" id="deliverables-and-assessment"><span
         class="header-section-number">9</span> Deliverables and
         Assessment</h1>
         <p>Your lab notebook should include the following for this
         week:</p>
         <h2 data-number="9.1" id="prelab-complete-before-lab"><span
         class="header-section-number">9.1</span> Prelab (complete
         before lab)</h2>
         <ol type="1">
         <li><strong>Least-squares fitting exercises</strong>: contour
         plot of <span class="math inline">\(\chi^2\)</span>, graphical
         minimization results</li>
         <li><strong>Residuals analysis</strong>: plot of residuals,
         answers to goodness-of-fit questions</li>
         <li><strong>Weighted fit</strong>: results using data with
         uncertainties, <span class="math inline">\(\chi^2\)</span> test
         calculation</li>
         <li><strong>Error bars plot</strong>: reproduction of the
         example plot with error bars</li>
         </ol>
         <h2 data-number="9.2" id="in-lab-documentation"><span
         class="header-section-number">9.2</span> In-Lab
         Documentation</h2>
         <ol type="1">
         <li><strong>DAQ verification</strong>: screenshot or plot
         showing successful voltage reading</li>
         <li><strong>Waveform capture</strong>: comparison of Python
         plot vs. oscilloscope display</li>
         <li><strong>Aliasing exercises</strong>: completed
         prediction-observation-explanation for all frequency cases</li>
         <li><strong>Noise characterization tables</strong> (Parts 1-4):
         <ul>
         <li>Dark noise measurements at each gain setting</li>
         <li>Signal-to-noise predictions AND measurements</li>
         <li>DAQ intrinsic noise measurement</li>
         </ul></li>
         <li><strong>Gain setting decision</strong>: your selected gain
         with written justification</li>
         </ol>
         <h2 data-number="9.3" id="key-data-tables"><span
         class="header-section-number">9.3</span> Key Data Tables</h2>
         <p>Make sure these tables are completed in your notebook:</p>
         <table>
         <thead>
         <tr>
         <th>Gain</th>
         <th>Datasheet Noise</th>
         <th>Measured Noise</th>
         <th>Ratio</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>0 dB</td>
         <td>_______</td>
         <td>_______</td>
         <td>_______</td>
         </tr>
         <tr>
         <td>…</td>
         <td>…</td>
         <td>…</td>
         <td>…</td>
         </tr>
         </tbody>
         </table>
         <table>
         <thead>
         <tr>
         <th>Gain</th>
         <th>Predicted SNR</th>
         <th>Measured SNR</th>
         <th>Agreement?</th>
         </tr>
         </thead>
         <tbody>
         <tr>
         <td>…</td>
         <td>…</td>
         <td>…</td>
         <td>…</td>
         </tr>
         </tbody>
         </table>
         <h2 data-number="9.4" id="code-deliverables"><span
         class="header-section-number">9.4</span> Code Deliverables</h2>
         <ol type="1">
         <li>Working <code>measure_noise()</code> function with your
         chosen parameters</li>
         <li>Python script for waveform acquisition and plotting</li>
         </ol>
         <h2 data-number="9.5" id="reflection-questions"><span
         class="header-section-number">9.5</span> Reflection
         Questions</h2>
         <ol type="1">
         <li><p>Your measured noise at 70 dB is 2× higher than the
         datasheet value. List two possible causes and describe how you
         would test each hypothesis.</p></li>
         <li><p>Based on your noise characterization, at what light
         level (in mV at 0 dB) would you switch from 0 dB to 30 dB gain
         to maintain SNR &gt; 100?</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
