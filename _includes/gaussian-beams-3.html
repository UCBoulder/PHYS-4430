<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 3</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#where-we-are-in-the-sequence"><span
            class="toc-section-number">1</span> Where We Are in the
            Sequence</a></li>
            <li><a href="#overview"><span
            class="toc-section-number">2</span> Overview</a></li>
            <li><a href="#learning-goals"><span
            class="toc-section-number">3</span> Learning Goals</a></li>
            <li><a href="#overview-of-your-work"><span
            class="toc-section-number">4</span> Overview of Your
            Work</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">5</span> Prelab</a>
            <ul>
            <li><a href="#gaussian-beam-theory"><span
            class="toc-section-number">5.1</span> Gaussian beam
            theory</a></li>
            <li><a href="#sec:wave-eqn"><span
            class="toc-section-number">5.2</span> Paraxial wave
            equation</a></li>
            <li><a href="#physical-intuition-check"><span
            class="toc-section-number">5.3</span> Physical Intuition
            Check</a></li>
            <li><a href="#trying-out-the-gaussian-beam-model"><span
            class="toc-section-number">5.4</span> Trying out the
            Gaussian beam model</a></li>
            <li><a
            href="#beyond-beam-width-the-unmeasured-parameters"><span
            class="toc-section-number">5.5</span> Beyond Beam Width: The
            Unmeasured Parameters</a>
            <ul>
            <li><a
            href="#what-we-can-and-cannot-measure-with-a-knife-edge"><span
            class="toc-section-number">5.5.1</span> What we can and
            cannot measure with a knife edge</a></li>
            <li><a href="#how-would-you-measure-rz"><span
            class="toc-section-number">5.5.2</span> How would you
            measure R(z)?</a></li>
            <li><a href="#how-would-you-measure-ζz"><span
            class="toc-section-number">5.5.3</span> How would you
            measure ζ(z)?</a></li>
            <li><a href="#why-does-wz-suffice-for-this-lab"><span
            class="toc-section-number">5.5.4</span> Why does w(z)
            suffice for this lab?</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#setting-up-the-motor-controller"><span
            class="toc-section-number">6</span> Setting Up the Motor
            Controller</a>
            <ul>
            <li><a href="#hardware-overview"><span
            class="toc-section-number">6.1</span> Hardware
            Overview</a></li>
            <li><a href="#software-prerequisites"><span
            class="toc-section-number">6.2</span> Software
            Prerequisites</a>
            <ul>
            <li><a href="#thorlabs-kinesis-sdk"><span
            class="toc-section-number">6.2.1</span> 1. Thorlabs Kinesis
            SDK</a></li>
            <li><a href="#python-packages"><span
            class="toc-section-number">6.2.2</span> 2. Python
            Packages</a></li>
            </ul></li>
            <li><a href="#verifying-the-motor-connection"><span
            class="toc-section-number">6.3</span> Verifying the Motor
            Connection</a>
            <ul>
            <li><a href="#test-that-windows-recognizes-the-device"><span
            class="toc-section-number">6.3.1</span> Test that Windows
            Recognizes the Device</a></li>
            <li><a href="#test-basic-motor-communication"><span
            class="toc-section-number">6.3.2</span> Test Basic Motor
            Communication</a></li>
            <li><a href="#test-motor-movement"><span
            class="toc-section-number">6.3.3</span> Test Motor
            Movement</a></li>
            </ul></li>
            <li><a href="#motor-controller-troubleshooting"><span
            class="toc-section-number">6.4</span> Motor Controller
            Troubleshooting</a></li>
            <li><a href="#exercise-verify-your-setup"><span
            class="toc-section-number">6.5</span> Exercise: Verify Your
            Setup</a></li>
            <li><a href="#troubleshooting-reflection"><span
            class="toc-section-number">6.6</span> Troubleshooting
            Reflection</a></li>
            </ul></li>
            <li><a
            href="#taking-your-first-automated-beam-profile"><span
            class="toc-section-number">7</span> Taking Your First
            Automated Beam Profile</a>
            <ul>
            <li><a href="#measurement-procedure"><span
            class="toc-section-number">7.1</span> Measurement
            Procedure</a></li>
            <li><a href="#quick-check"><span
            class="toc-section-number">7.2</span> Quick Check</a></li>
            </ul></li>
            <li><a href="#applying-theory-to-your-measurements"><span
            class="toc-section-number">8</span> Applying Theory to Your
            Measurements</a>
            <ul>
            <li><a
            href="#error-propagation-from-measured-to-derived-quantities"><span
            class="toc-section-number">8.1</span> Error Propagation:
            From Measured to Derived Quantities</a>
            <ul>
            <li><a href="#the-general-formula"><span
            class="toc-section-number">8.1.1</span> The General
            Formula</a></li>
            <li><a href="#error-propagation-in-python"><span
            class="toc-section-number">8.1.2</span> Error Propagation in
            Python</a></li>
            </ul></li>
            <li><a href="#fitting-your-beam-profile-data"><span
            class="toc-section-number">8.2</span> Fitting Your Beam
            Profile Data</a>
            <ul>
            <li><a href="#step-1-load-and-plot-your-data"><span
            class="toc-section-number">8.2.1</span> Step 1: Load and
            Plot Your Data</a></li>
            <li><a
            href="#step-2-define-and-fit-the-error-function-model"><span
            class="toc-section-number">8.2.2</span> Step 2: Define and
            Fit the Error Function Model</a></li>
            <li><a href="#step-3-plot-the-fit"><span
            class="toc-section-number">8.2.3</span> Step 3: Plot the
            Fit</a></li>
            </ul></li>
            <li><a href="#predicting-week-4-results"><span
            class="toc-section-number">8.3</span> Predicting Week 4
            Results</a>
            <ul>
            <li><a
            href="#step-1-estimate-beam-waist-from-your-measurement"><span
            class="toc-section-number">8.3.1</span> Step 1: Estimate
            Beam Waist from Your Measurement</a></li>
            <li><a
            href="#step-2-predict-beam-widths-at-other-positions"><span
            class="toc-section-number">8.3.2</span> Step 2: Predict Beam
            Widths at Other Positions</a></li>
            <li><a href="#step-3-record-your-predictions"><span
            class="toc-section-number">8.3.3</span> Step 3: Record Your
            Predictions</a></li>
            </ul></li>
            <li><a
            href="#comparing-manual-vs.-motor-controlled-measurements"><span
            class="toc-section-number">8.4</span> Comparing Manual
            vs. Motor-Controlled Measurements</a></li>
            </ul></li>
            <li><a href="#deliverables-and-assessment"><span
            class="toc-section-number">9</span> Deliverables and
            Assessment</a>
            <ul>
            <li><a href="#prelab-complete-before-lab-75-min"><span
            class="toc-section-number">9.1</span> Prelab (complete
            before lab, ~75 min)</a></li>
            <li><a href="#in-lab-documentation"><span
            class="toc-section-number">9.2</span> In-Lab
            Documentation</a>
            <ul>
            <li><a href="#phase-2-measurement-60-min"><span
            class="toc-section-number">9.2.1</span> Phase 2: Measurement
            (~60 min)</a></li>
            <li><a href="#phase-3-analysis-60-min"><span
            class="toc-section-number">9.2.2</span> Phase 3: Analysis
            (~60 min)</a></li>
            </ul></li>
            <li><a href="#code-deliverables"><span
            class="toc-section-number">9.3</span> Code
            Deliverables</a></li>
            <li><a href="#reflection-questions"><span
            class="toc-section-number">9.4</span> Reflection
            Questions</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="where-we-are-in-the-sequence"><span
         class="header-section-number">1</span> Where We Are in the
         Sequence</h1>
         <p><strong>Week 3 of 4: Theory, First Automated Measurement,
         and Analysis</strong></p>
         <p>Last week you characterized your photodetector’s noise and
         chose an optimal gain setting. This week you’ll learn the
         theoretical foundation for Gaussian beams, set up the motor
         controller, take your first automated beam profile, and apply
         error propagation to your real data.</p>
         <p><strong>Last week:</strong> Learned DAQ programming,
         characterized noise, chose gain setting</p>
         <p><strong>This week:</strong> Learn Gaussian beam theory → Set
         up motor → Take beam profile → Analyze with error
         propagation</p>
         <p><strong>Next week:</strong> Multiple beam profiles → Test
         Gaussian beam model → Investigate lens effects</p>
         <h1 data-number="2" id="overview"><span
         class="header-section-number">2</span> Overview</h1>
         <p>This week connects theory to practice. In the prelab, you’ll
         derive the Gaussian beam equations from Maxwell’s equations and
         develop physical intuition for beam propagation. In lab, you’ll
         set up the motor controller and take your first
         motor-controlled beam profile. Then you’ll apply error
         propagation to your actual data—not abstract examples—to
         predict uncertainties in your Week 4 measurements. By the end
         of this week, you’ll have tested your entire measurement system
         and made quantitative predictions for next week.</p>
         <h1 data-number="3" id="learning-goals"><span
         class="header-section-number">3</span> Learning Goals</h1>
         <p>After completing the prelab, you will be able to:</p>
         <ol type="1">
         <li>Derive the paraxial wave equation from Maxwell’s equations
         by applying the slowly-varying envelope approximation.</li>
         <li>Explain the physical meaning of Gaussian beam parameters
         (<span class="math inline">\(w_0\)</span>, <span
         class="math inline">\(w(z)\)</span>, <span
         class="math inline">\(R(z)\)</span>, <span
         class="math inline">\(\zeta(z)\)</span>) and how they relate to
         observable properties.</li>
         <li>Predict how beam width changes with position using the
         Gaussian beam equations.</li>
         </ol>
         <p>After completing the lab, you will be able to:</p>
         <ol type="1">
         <li>Set up and operate the motor controller for automated
         measurements.</li>
         <li>Take a complete beam profile using motor-controlled
         positioning.</li>
         <li>Fit beam profile data to extract beam width with
         uncertainty.</li>
         <li>Propagate uncertainties from measured quantities to derived
         quantities.</li>
         <li>Make quantitative predictions for Week 4 measurements based
         on your data.</li>
         </ol>
         <h1 data-number="4" id="overview-of-your-work"><span
         class="header-section-number">4</span> Overview of Your
         Work</h1>
         <p>This week has three phases:</p>
         <p><strong>Phase 1 - Theory (Prelab, ~75 min):</strong> Derive
         the Gaussian beam equations from Maxwell’s equations and build
         physical intuition. You’ll understand <em>why</em> beams have
         the shape they do.</p>
         <p><strong>Phase 2 - Measurement (Lab, ~60 min):</strong> Set
         up the motor controller and take a complete beam profile. This
         is your first automated measurement—a trial run before Week 4’s
         systematic data collection.</p>
         <p><strong>Phase 3 - Analysis (Lab, ~60 min):</strong> Apply
         error propagation to your actual beam width measurement. Fit
         your data, calculate uncertainties, and make predictions for
         Week 4. This is where theory meets your measurements.</p>
         <p><em>See the detailed deliverables checklist at the end of
         this guide.</em></p>
         <h1 data-number="5" id="prelab"><span
         class="header-section-number">5</span> Prelab</h1>
         <p>This week’s prelab focuses on the theoretical foundation for
         Gaussian laser beams. You’ll derive the equations that describe
         how laser beams propagate and develop physical intuition for
         the key parameters. Error propagation will be covered in lab,
         where you’ll apply it directly to your measurements.</p>
         <h2 data-number="5.1" id="gaussian-beam-theory"><span
         class="header-section-number">5.1</span> Gaussian beam
         theory</h2>
         <p>Light is a propagating oscillation of the electromagnetic
         field. The general principles which govern electromagnetic
         waves are Maxwell’s equations. From these general relations, a
         vector wave equation can be derived.</p>
         <p><span id="eq:1" class="eqnos"><span class="math display">\[
         \nabla^2\vec{E}=\mu_0\epsilon_0
         \frac{\partial^2\vec{E}}{\partial
         t^2}\text{.}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>One of the simplest solutions is that of a plane wave
         propagating in the <span class="math inline">\(\hat{z}\)</span>
         direction:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=E_x\hat{x}cos(kz-\omega
         t+\phi_x)+E_y\hat{y}cos(kz-\omega
         t+\phi_y)\text{.}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>But as the measurements from the first week showed, our
         laser beams are commonly well approximated by a beam shape with
         a Gaussian intensity profile. Apparently, since these Gaussian
         profile beams exist, they must be solutions of the wave
         equation. The next section will discuss how we derive the
         Gaussian beam electric field, and give a few key results.</p>
         <h2 data-number="5.2" id="sec:wave-eqn"><span
         class="header-section-number">5.2</span> Paraxial wave
         equation</h2>
         <p>One important thing to note about the beam output from most
         lasers is that the width of the beam changes very slowly
         compared to the wavelength of light. Assume a complex solution,
         where the beam is propagating in the <span
         class="math inline">\(\hat{z}\)</span>-direction, with the
         electric field polarization in the <span
         class="math inline">\(\hat{x}\)</span>-direction:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=\hat{x}A(x,y,z)e^{i(kz-\omega
         t)}\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The basic idea is that the spatial pattern of the beam,
         described by the function <span
         class="math inline">\(A(x,y,z)\)</span>, does not change much
         over a wavelength. In the case of the He-Ne laser output, the
         function <span class="math inline">\(A(x,y,z)\)</span> is a
         Gaussian profile that changes its width as a function of <span
         class="math inline">\(z\)</span>. If we substitute the trial
         solution in Equation <a href="#eq:3">3</a> into the wave
         equation in Equation <a href="#eq:1">1</a> we get</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\hat{x} \left[
         \left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial z} - k^2A
         \right]e^{i(kz-\omega
         t)}=\hat{x}\mu_0\epsilon_oA(-\omega^2)e^{i(kz-\omega
         t)}\text{.}\quad\quad\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>This can be simplified recognizing that <span
         class="math inline">\(k^2=\omega^2/c^2=\mu_0\epsilon_0\omega^2\)</span>,
         where the speed of light is related to the permeability and
         permittivity of free space by <span
         class="math inline">\(c=(\mu_0\epsilon_0)^{-1/2}\)</span>.
         Also, the <span class="math inline">\(\hat{x}e^{i(kz-\omega
         t)}\)</span> term is common to both sides and can be dropped,
         which results in</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial
         z}=0\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So far, we have made no approximation to the solution or the
         wave equation, but now we apply the assumption that <span
         class="math inline">\(\partial{A}(x,y,z)/\partial{z}\)</span>
         changes slowly over a wavelength <span
         class="math inline">\(\lambda = 2\pi /k\)</span>, so we neglect
         the term</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\left| \frac{\partial^2A}{\partial z^2}
         \right| \ll \left|2k\frac{\partial A}{\partial
         z}\right|\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <p>Finally, we get the paraxial wave equation,</p>
         <p><span id="eq:7" class="eqnos"><span
         class="math display">\[\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} + 2ik\frac{\partial
         A}{\partial
         z}=0\text{.}\]</span><span class="eqnos-number">(7)</span></span>
         </p>
         <p>One set of solutions to the paraxial wave equation are
         Gauss-Hermite beams, which have an intensity profiles like
         those shown in Figure <a href="#fig:gauss-hermite">1</a>. These
         are the same solutions as for the quantum simple harmonic
         oscillator, a topic that could be further explored as a final
         project.</p>
         <p>The simplest of these solutions is the Gaussian beam, which
         has an electric field given by</p>
         <p><span id="eq:8" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t) =
         \vec{E}_0\frac{w_0}{w(z)}exp\left(-\frac{x^2+y^2}{w^2(z)}\right)exp\left(ik\frac{x^2+y^2}{2R(z)}\right)e^{-i\zeta(z)}e^{i(kz-\omega
         t)}\text{,}\quad\quad\]</span><span class="eqnos-number">(8)</span></span>
         </p>
         <p>where <span class="math inline">\(\vec{E_0}\)</span> is a
         time-independent vector (orthogonal to propagation direction
         <span class="math inline">\(\hat{z}\)</span>) whose magnitude
         denotes the amplitude of the laser’s electric field and the
         direction denotes the direction of polarization. The beam
         radius <span class="math inline">\(w(z)\)</span> is given
         by</p>
         <p><span id="eq:9" class="eqnos"><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi
         w_0^2}\right)^2}\text{.}\]</span><span class="eqnos-number">(9)</span></span>
         </p>
         <p><span class="math inline">\(R(z)\)</span>,the radius of
         curvature of the wavefront, is given by</p>
         <p><span id="eq:10" class="eqnos"><span
         class="math display">\[R(z)=z\left(1+\left(\frac{\pi
         w_0^2}{\lambda
         z}\right)^2\right)\text{,}\]</span><span class="eqnos-number">(10)</span></span>
         </p>
         <p>and the Gouy phase is given by</p>
         <p><span id="eq:11" class="eqnos"><span
         class="math display">\[\zeta(z)=arctan\frac{\pi w_0^2}{\lambda
         z}\text{.}\]</span><span class="eqnos-number">(11)</span></span>
         </p>
         <p>The remarkable thing about all these equations is that only
         two parameters need to be specified to give the whole beam
         profile: the wavelength <span
         class="math inline">\(\lambda\)</span> and the beam waist <span
         class="math inline">\(w_0\)</span>, which is the narrowest
         point in the beam profile. There is a more general set of
         Hermite Gaussian modes which are shown in Figure <a
         href="#fig:gauss-hermite">1</a>. The laser cavity typically
         produces the (0,0) mode shown in the upper left corner, but an
         optical cavity can also be used to create these other modes – a
         topic that can be explored in the final projects.</p>
         <div id="fig:gauss-hermite" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-hermite.png"
         style="width:20cm"
         alt="Figure 1: Intensity distributions for the lowest order Gauss-Hermite solutions to the paraxial wave equation. The axes are in units of the beam width, w." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Intensity
         distributions for the lowest order Gauss-Hermite solutions to
         the paraxial wave equation. The axes are in units of the beam
         width, <span class="math inline">\(w\)</span>.</figcaption>
         </figure>
         </div>
         <h2 data-number="5.3" id="physical-intuition-check"><span
         class="header-section-number">5.3</span> Physical Intuition
         Check</h2>
         <p>Before applying these equations, test your physical
         understanding. Answer each question without looking at the
         equations, then verify with a calculation.</p>
         <ol type="1">
         <li><p><strong>Scaling the waist:</strong> If you double the
         beam waist <span class="math inline">\(w_0\)</span>, what
         happens to:</p>
         <ul>
         <li>The divergence angle <span class="math inline">\(\theta =
         \lambda / (\pi w_0)\)</span> in the far field?</li>
         <li>The Rayleigh range <span class="math inline">\(z_R = \pi
         w_0^2 / \lambda\)</span>?</li>
         </ul>
         <p><em>Intuition check:</em> A wider waist means the beam is
         more collimated (less divergent). Does your answer reflect
         this?</p></li>
         <li><p><strong>Distance to double:</strong> At what distance
         from the waist does the beam width double (i.e., <span
         class="math inline">\(w(z) = 2w_0\)</span>)?</p>
         <p><em>Hint:</em> Set up the equation and solve for <span
         class="math inline">\(z\)</span> in terms of <span
         class="math inline">\(z_R\)</span>. The answer is a simple
         multiple of the Rayleigh range.</p></li>
         <li><p><strong>Wavelength dependence:</strong> Two lasers have
         identical beam waists <span class="math inline">\(w_0\)</span>,
         but one is red (633 nm) and one is blue (450 nm). Which beam
         diverges more rapidly? Why?</p></li>
         <li><p><strong>Conservation of energy:</strong> As the beam
         expands, the width increases but the total power stays
         constant. What must happen to the peak intensity <span
         class="math inline">\(I_{max}\)</span> as <span
         class="math inline">\(z\)</span> increases? Write a
         proportionality relationship.</p></li>
         <li><p><strong>Beam quality check:</strong> You measure a beam
         width of 0.8 mm at <span class="math inline">\(z = 1\)</span> m
         from the laser. Assuming <span class="math inline">\(\lambda =
         633\)</span> nm, what is the minimum possible beam waist?
         (Hint: The waist could be inside or outside the laser
         cavity.)</p></li>
         </ol>
         <p><em>Record your answers in your notebook. Getting physical
         intuition wrong is valuable—it reveals gaps in understanding
         that equations alone can hide.</em></p>
         <h2 data-number="5.4"
         id="trying-out-the-gaussian-beam-model"><span
         class="header-section-number">5.4</span> Trying out the
         Gaussian beam model</h2>
         <p>In the first week of the lab, we assumed the intensity
         profile of the Gaussian beam was given by <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>.
         The equation for the electric field of the Gaussian Beam in
         Equation <a href="#eq:8">8</a> looks substantially more
         complicated.</p>
         <ol type="1">
         <li>How are the expressions for electric field and intensity
         related?</li>
         <li>Is Equation <a href="#eq:8">8</a> consistent with the
         simple expression for intensity <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>?</li>
         </ol>
         <p>The Gaussian beam equations given in Equations <a
         href="#eq:8">8</a> -<a href="#eq:11">11</a> assume the beam
         comes to its narrowest width (called the beam waist, <span
         class="math inline">\(w_0\)</span>) at <span
         class="math inline">\(z=0\)</span>.</p>
         <ol start="3" type="1">
         <li>How would you rewrite these four equations assuming the
         beam waist occurs at a different position <span
         class="math inline">\(z=z_w\)</span>?</li>
         <li>One way to check your answer is to make sure the equations
         simplify to Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a> in the special case of <span
         class="math inline">\(z_w=0\)</span>.</li>
         </ol>
         <p><em>You will fit actual beam width data in lab today using
         these modified equations.</em></p>
         <h2 data-number="5.5"
         id="beyond-beam-width-the-unmeasured-parameters"><span
         class="header-section-number">5.5</span> Beyond Beam Width: The
         Unmeasured Parameters</h2>
         <p>The Gaussian beam solution contains four key quantities: the
         beam width <span class="math inline">\(w(z)\)</span>, the
         wavefront radius of curvature <span
         class="math inline">\(R(z)\)</span>, the Gouy phase <span
         class="math inline">\(\zeta(z)\)</span>, and the peak
         amplitude. In Week 4, you will measure only <span
         class="math inline">\(w(z)\)</span> using the knife-edge
         technique. What about the others?</p>
         <h3 data-number="5.5.1"
         id="what-we-can-and-cannot-measure-with-a-knife-edge"><span
         class="header-section-number">5.5.1</span> What we can and
         cannot measure with a knife edge</h3>
         <p>The knife-edge profiler measures <strong>intensity</strong>
         as a function of position. This directly gives you <span
         class="math inline">\(w(z)\)</span>, the beam width.
         However:</p>
         <ul>
         <li><p><strong><span class="math inline">\(R(z)\)</span>
         (radius of curvature):</strong> This describes how the
         wavefronts are curved—flat at the waist, increasingly curved
         far away. A knife edge only sees intensity, not phase, so it
         cannot measure <span class="math inline">\(R(z)\)</span>
         directly.</p></li>
         <li><p><strong><span class="math inline">\(\zeta(z)\)</span>
         (Gouy phase):</strong> This is a phase shift that accumulates
         as the beam passes through its waist. Like <span
         class="math inline">\(R(z)\)</span>, it requires
         phase-sensitive measurements.</p></li>
         </ul>
         <h3 data-number="5.5.2" id="how-would-you-measure-rz"><span
         class="header-section-number">5.5.2</span> How would you
         measure R(z)?</h3>
         <p>If you wanted to measure the wavefront curvature, you would
         need <strong>interferometry</strong>—combining your beam with a
         reference beam and analyzing the interference pattern. The
         spacing and curvature of interference fringes reveals <span
         class="math inline">\(R(z)\)</span>.</p>
         <p><strong>Think about it:</strong> Near the waist, <span
         class="math inline">\(R(z) \to \infty\)</span> (flat
         wavefronts). Far from the waist, <span
         class="math inline">\(R(z) \approx z\)</span> (spherical
         wavefronts centered on the waist). What does this tell you
         about how the beam’s wavefronts evolve?</p>
         <h3 data-number="5.5.3" id="how-would-you-measure-ζz"><span
         class="header-section-number">5.5.3</span> How would you
         measure ζ(z)?</h3>
         <p>The Gouy phase shift is subtle—it’s a <span
         class="math inline">\(\pi\)</span> total phase change as the
         beam goes from <span class="math inline">\(z = -\infty\)</span>
         to <span class="math inline">\(z = +\infty\)</span> through the
         waist. Detecting it requires:</p>
         <ol type="1">
         <li><strong>Interferometry with a reference beam</strong> that
         bypasses the focus</li>
         <li><strong>Mode-matching experiments</strong> where the Gouy
         phase affects coupling efficiency</li>
         </ol>
         <p>The Gouy phase has practical consequences: it affects the
         resonant frequencies of laser cavities and the focal properties
         of lens systems.</p>
         <h3 data-number="5.5.4"
         id="why-does-wz-suffice-for-this-lab"><span
         class="header-section-number">5.5.4</span> Why does w(z)
         suffice for this lab?</h3>
         <p>For characterizing a laser beam’s propagation, <span
         class="math inline">\(w(z)\)</span> is often the most
         practically important parameter because:</p>
         <ol type="1">
         <li>It determines the spot size for any application (machining,
         microscopy, communications)</li>
         <li>Combined with the wavelength <span
         class="math inline">\(\lambda\)</span>, it uniquely determines
         the waist <span class="math inline">\(w_0\)</span> and waist
         position <span class="math inline">\(z_w\)</span></li>
         <li>Once you know <span class="math inline">\(w_0\)</span>, you
         can <em>calculate</em> <span
         class="math inline">\(R(z)\)</span> and <span
         class="math inline">\(\zeta(z)\)</span> from the equations—you
         don’t need to measure them separately</li>
         </ol>
         <p><strong>Reflection:</strong> In what applications might you
         actually need to measure <span
         class="math inline">\(R(z)\)</span> or <span
         class="math inline">\(\zeta(z)\)</span> rather than just
         calculating them from <span class="math inline">\(w_0\)</span>?
         (Hint: When might the theoretical relationship break down?)</p>
         <h1 data-number="6" id="setting-up-the-motor-controller"><span
         class="header-section-number">6</span> Setting Up the Motor
         Controller</h1>
         <p>In Week 4, you will use Python to automate beam profile
         measurements by controlling a motorized translation stage. This
         section guides you through setting up and verifying the motor
         controller hardware. Getting this working now will save
         significant time later.</p>
         <h2 data-number="6.1" id="hardware-overview"><span
         class="header-section-number">6.1</span> Hardware Overview</h2>
         <p>The Thorlabs KST101 is a stepper motor controller that can
         precisely position a translation stage. You will use it to move
         a razor blade across the laser beam while the DAQ records the
         photodetector signal.</p>
         <p>The physical connections are:</p>
         <ol type="1">
         <li><strong>Motor Controller (KST101)</strong>:
         <ul>
         <li>Connect the USB cable from the KST101 cube to your
         computer</li>
         <li>Connect the power supply to the KST101</li>
         <li>The motor should already be mechanically connected to the
         translation stage with the razor</li>
         </ul></li>
         <li><strong>Optical Setup</strong> (for testing):
         <ul>
         <li>Position the photodetector after the knife-edge in the beam
         path</li>
         <li>Ensure the beam passes cleanly through when the razor is
         fully retracted</li>
         </ul></li>
         </ol>
         <h2 data-number="6.2" id="software-prerequisites"><span
         class="header-section-number">6.2</span> Software
         Prerequisites</h2>
         <h3 data-number="6.2.1" id="thorlabs-kinesis-sdk"><span
         class="header-section-number">6.2.1</span> 1. Thorlabs Kinesis
         SDK</h3>
         <p>Download and install from the Thorlabs website: <a
         href="https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control">https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control</a></p>
         <p><strong>Important</strong>: Choose the correct version: - If
         you have 32-bit Python: Install the 32-bit Kinesis software -
         If you have 64-bit Python: Install the 64-bit Kinesis
         software</p>
         <p>To check your Python version, run:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys.maxsize <span class="op">&gt;</span> <span class="dv">2</span><span class="op">**</span><span class="dv">32</span>)  <span class="co"># True = 64-bit, False = 32-bit</span></span></code></pre></div>
         <h3 data-number="6.2.2" id="python-packages"><span
         class="header-section-number">6.2.2</span> 2. Python
         Packages</h3>
         <p>Install the required packages:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pythonnet uncertainties</span></code></pre></div>
         <ul>
         <li><code>pythonnet</code>: Required for interfacing with
         Thorlabs Kinesis motor control</li>
         <li><code>uncertainties</code>: Required for error propagation
         calculations in the analysis section</li>
         </ul>
         <p>(You should already have <code>nidaqmx</code>,
         <code>numpy</code>, <code>scipy</code>, and
         <code>matplotlib</code> from Week 2.)</p>
         <h2 data-number="6.3" id="verifying-the-motor-connection"><span
         class="header-section-number">6.3</span> Verifying the Motor
         Connection</h2>
         <h3 data-number="6.3.1"
         id="test-that-windows-recognizes-the-device"><span
         class="header-section-number">6.3.1</span> Test that Windows
         Recognizes the Device</h3>
         <ol type="1">
         <li>Connect the USB to the KST101, then turn on power</li>
         <li>Open <strong>Device Manager</strong> and look for the
         device under “USB devices” or “Thorlabs APT Device”</li>
         <li>Note the serial number (displayed on the KST101
         screen)</li>
         </ol>
         <p>If you get a driver error, you may need to disable Memory
         Integrity in Windows Security (ask technical staff for help if
         this occurs on a lab computer).</p>
         <h3 data-number="6.3.2"
         id="test-basic-motor-communication"><span
         class="header-section-number">6.3.2</span> Test Basic Motor
         Communication</h3>
         <p>Run this test script to verify Python can communicate with
         the motor:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Add Kinesis .NET assemblies</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Build device list</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Get list of connected devices</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>device_list <span class="op">=</span> DeviceManagerCLI.GetDeviceList()</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Found </span><span class="sc">{</span><span class="bu">len</span>(device_list)<span class="sc">}</span><span class="ss"> device(s):&quot;</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> serial <span class="kw">in</span> device_list:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Serial: </span><span class="sc">{</span>serial<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <p>If this shows your device serial number, the connection is
         working.</p>
         <h3 data-number="6.3.3" id="test-motor-movement"><span
         class="header-section-number">6.3.3</span> Test Motor
         Movement</h3>
         <p><strong>Caution</strong>: Make sure the translation stage
         has room to move before running this test. Check that nothing
         is blocking the stage mechanically.</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> decimal <span class="im">import</span> Decimal</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.GenericMotorCLI&quot;</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace with your serial number</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>SERIAL_NUMBER <span class="op">=</span> <span class="st">&quot;26004813&quot;</span>  <span class="co"># Check the display on your KST101</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> KCubeStepper.CreateKCubeStepper(SERIAL_NUMBER)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    device.Connect(SERIAL_NUMBER)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Connected!&quot;</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Wait for settings to initialize</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    device.WaitForSettingsInitialized(<span class="dv">5000</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    device.StartPolling(<span class="dv">50</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    device.EnableDevice()</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Load motor configuration</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    config <span class="op">=</span> device.LoadMotorConfiguration(SERIAL_NUMBER)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get current position</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> device.Position</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Current position: </span><span class="sc">{</span>pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move relative (small test movement)</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Moving 0.5 mm...&quot;</span>)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    device.SetMoveRelativeDistance(Decimal(<span class="fl">0.5</span>))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    device.MoveRelative(<span class="dv">60000</span>)  <span class="co"># 60 second timeout</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    new_pos <span class="op">=</span> device.Position</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;New position: </span><span class="sc">{</span>new_pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="cf">finally</span>:</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    device.StopPolling()</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    device.Disconnect()</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Disconnected&quot;</span>)</span></code></pre></div>
         <h2 data-number="6.4"
         id="motor-controller-troubleshooting"><span
         class="header-section-number">6.4</span> Motor Controller
         Troubleshooting</h2>
         <p><strong>“Device not found” Error:</strong> - Check USB
         connection - Verify serial number matches the display on the
         KST101 - Make sure no other software (APT User, Kinesis) is
         using the motor</p>
         <p><strong>Motor Doesn’t Move:</strong> - Ensure power is
         connected to the KST101 - Check that the stage isn’t at a
         travel limit - Verify the stage type is configured correctly in
         Kinesis (ZST225B)</p>
         <p><strong>Python Import Errors:</strong> - Ensure Kinesis SDK
         is installed and matches Python architecture (32/64-bit) -
         Check that the path to Kinesis DLLs is correct</p>
         <h2 data-number="6.5" id="exercise-verify-your-setup"><span
         class="header-section-number">6.5</span> Exercise: Verify Your
         Setup</h2>
         <p>Before leaving lab today, verify that:</p>
         <ol type="1">
         <li><input type="checkbox" disabled="" />
         The DAQ can read voltages from the photodetector</li>
         <li><input type="checkbox" disabled="" />
         Python can connect to the motor controller</li>
         <li><input type="checkbox" disabled="" />
         The motor moves when commanded</li>
         <li><input type="checkbox" disabled="" />
         You have noted your motor’s serial number: ____________</li>
         </ol>
         <p>This setup will be essential for the automated measurements
         in Week 4.</p>
         <p><strong>Note on AI assistance:</strong> The motor control
         code involves interfacing with hardware libraries that have
         specific requirements (correct DLL paths, serial numbers,
         initialization sequences). You may use AI to help generate this
         boilerplate code. What matters is that you can (1) verify the
         hardware is responding correctly, (2) diagnose common
         connection failures, and (3) modify parameters like movement
         distance and velocity. The Troubleshooting Reflection below
         tests these skills.</p>
         <h2 data-number="6.6" id="troubleshooting-reflection"><span
         class="header-section-number">6.6</span> Troubleshooting
         Reflection</h2>
         <p>Developing systematic troubleshooting skills is essential
         for experimental physics. Answer this question in your
         notebook:</p>
         <p><strong>If the motor doesn’t respond to Python commands,
         what troubleshooting steps would you take?</strong></p>
         <p>List at least three things you would check, <em>in order of
         likelihood</em>, and explain your reasoning. Consider: - What
         are the most common failure modes? - What’s the quickest way to
         isolate hardware vs. software issues? - How would you determine
         if the problem is with Python, the USB connection, or the motor
         itself?</p>
         <p>This systematic approach to troubleshooting will serve you
         well in Week 4 and beyond.</p>
         <h1 data-number="7"
         id="taking-your-first-automated-beam-profile"><span
         class="header-section-number">7</span> Taking Your First
         Automated Beam Profile</h1>
         <p>Now that you have the motor controller working, take a
         complete beam profile measurement. This serves two purposes:
         (1) verify your entire measurement system works end-to-end, and
         (2) generate real data for the analysis section.</p>
         <h2 data-number="7.1" id="measurement-procedure"><span
         class="header-section-number">7.1</span> Measurement
         Procedure</h2>
         <ol type="1">
         <li><p><strong>Position the knife-edge assembly</strong> at a
         known distance from the laser (measure and record this
         distance—you’ll need it for analysis).</p></li>
         <li><p><strong>Set up the measurement:</strong></p>
         <ul>
         <li>Ensure the photodetector is receiving the full beam when
         the knife-edge is retracted</li>
         <li>Use the gain setting you determined in Week 2</li>
         <li>Verify DAQ is reading reasonable voltages</li>
         </ul></li>
         <li><p><strong>Take the beam profile:</strong></p>
         <ul>
         <li>Move the knife-edge across the beam in steps of 0.05-0.1
         mm</li>
         <li>At each position, record the motor position and
         photodetector voltage</li>
         <li>Continue until the beam is fully blocked (voltage reaches
         dark level)</li>
         <li>Aim for 20-30 data points across the transition</li>
         </ul></li>
         <li><p><strong>Save your data</strong> with a descriptive
         filename including the date and z-position.</p></li>
         </ol>
         <p><strong>Tip:</strong> If using manual motor commands, you
         can automate data collection with a simple loop:</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">3</span>, <span class="fl">0.1</span>)  <span class="co"># 0 to 3 mm in 0.1 mm steps</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pos <span class="kw">in</span> positions:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move motor to position (use your motor control code)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># motor.MoveTo(pos)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.3</span>)  <span class="co"># Wait for motor to settle</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read voltage</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        voltage <span class="op">=</span> np.mean(task.read(number_of_samples_per_channel<span class="op">=</span><span class="dv">100</span>))</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    data.append([pos, voltage])</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Position: </span><span class="sc">{</span>pos<span class="sc">:.2f}</span><span class="ss"> mm, Voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Save data</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>np.savetxt(<span class="st">&#39;beam_profile_week3.csv&#39;</span>, data, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>,</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>           header<span class="op">=</span><span class="st">&#39;Position (mm), Voltage (V)&#39;</span>, comments<span class="op">=</span><span class="st">&#39;&#39;</span>)</span></code></pre></div>
         <h2 data-number="7.2" id="quick-check"><span
         class="header-section-number">7.2</span> Quick Check</h2>
         <p>Before proceeding to analysis, verify your data looks
         reasonable: - Does the voltage transition smoothly from high to
         low? - Is the transition region clearly visible? - Do you have
         enough points in the transition region (where the voltage
         changes)?</p>
         <p>If the data looks noisy or the transition is unclear, retake
         the measurement with smaller step sizes or more averaging.</p>
         <h1 data-number="8"
         id="applying-theory-to-your-measurements"><span
         class="header-section-number">8</span> Applying Theory to Your
         Measurements</h1>
         <p>This section connects the Gaussian beam theory from your
         prelab to your actual measurements. You’ll learn error
         propagation by applying it to your own data—not abstract
         examples.</p>
         <h2 data-number="8.1"
         id="error-propagation-from-measured-to-derived-quantities"><span
         class="header-section-number">8.1</span> Error Propagation:
         From Measured to Derived Quantities</h2>
         <p>The quantity of interest in an experiment is often derived
         from other measured quantities. For example, you’ll derive beam
         width <span class="math inline">\(w\)</span> from your
         knife-edge data, then use <span
         class="math inline">\(w\)</span> at multiple positions to
         determine the beam waist <span
         class="math inline">\(w_0\)</span>.</p>
         <h3 data-number="8.1.1" id="the-general-formula"><span
         class="header-section-number">8.1.1</span> The General
         Formula</h3>
         <p>Suppose you want to derive a quantity <span
         class="math inline">\(z\)</span> from measured quantities <span
         class="math inline">\(a, b, c, ...\)</span>. The mathematical
         function is <span class="math inline">\(z = z(a, b, c,
         ...)\)</span>. The propagated uncertainty in <span
         class="math inline">\(z\)</span> is:</p>
         <p><span class="math display">\[\sigma_z^2 = \left(
         \frac{\partial z}{\partial a}\right)^2\sigma_a^2+\left(
         \frac{\partial z}{\partial b}\right)^2\sigma_b^2+\left(
         \frac{\partial z}{\partial c}\right)^2\sigma_c^2+ \
         ...\text{.}\]</span></p>
         <p>This comes directly from calculus—it’s the linear
         approximation of how fluctuations in inputs cause fluctuations
         in outputs.</p>
         <h3 data-number="8.1.2" id="error-propagation-in-python"><span
         class="header-section-number">8.1.2</span> Error Propagation in
         Python</h3>
         <p>For complex calculations, the <code>uncertainties</code>
         package automatically tracks error propagation:</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define values with uncertainties</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> ufloat(<span class="fl">5.0</span>, <span class="fl">0.1</span>)   <span class="co"># 5.0 ± 0.1 V</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> ufloat(<span class="fl">0.5</span>, <span class="fl">0.02</span>)  <span class="co"># 0.5 ± 0.02 A</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate - uncertainty propagates automatically</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">}</span><span class="ss">&quot;</span>)  <span class="co"># Shows value ± uncertainty</span></span></code></pre></div>
         <h2 data-number="8.2" id="fitting-your-beam-profile-data"><span
         class="header-section-number">8.2</span> Fitting Your Beam
         Profile Data</h2>
         <p>Now fit your beam profile data to extract the beam
         width.</p>
         <h3 data-number="8.2.1"
         id="step-1-load-and-plot-your-data"><span
         class="header-section-number">8.2.1</span> Step 1: Load and
         Plot Your Data</h3>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load your data</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;beam_profile_week3.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> data[:, <span class="dv">0</span>]  <span class="co"># mm</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>voltage <span class="op">=</span> data[:, <span class="dv">1</span>]   <span class="co"># V</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot raw data</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>plt.plot(position, voltage, <span class="st">&#39;bo&#39;</span>, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (mm)&#39;</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Beam Profile - Week 3&#39;</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="8.2.2"
         id="step-2-define-and-fit-the-error-function-model"><span
         class="header-section-number">8.2.2</span> Step 2: Define and
         Fit the Error Function Model</h3>
         <p>The knife-edge measurement gives an integrated Gaussian,
         which is the error function:</p>
         <p><span class="math display">\[V(x) = \frac{V_{max} -
         V_{min}}{2} \left[1 - \text{erf}\left(\frac{\sqrt{2}(x -
         x_0)}{w}\right)\right] + V_{min}\]</span></p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beam_profile(x, V_max, V_min, center, width):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">        x: position (mm)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">        V_max: maximum voltage when beam is unblocked (V)</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">        V_min: minimum voltage when beam is blocked (V)</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">        center: beam center position (mm)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">        width: beam width w (mm)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Note: This form uses V_max/V_min instead of amplitude/offset</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">    for physical clarity. The forms are equivalent:</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">        amplitude = (V_max - V_min) / 2</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">        offset = (V_max + V_min) / 2</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (V_max <span class="op">-</span> V_min) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> (x <span class="op">-</span> center) <span class="op">/</span> width)) <span class="op">+</span> V_min</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>V_max_guess <span class="op">=</span> np.<span class="bu">max</span>(voltage)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>V_min_guess <span class="op">=</span> np.<span class="bu">min</span>(voltage)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>center_guess <span class="op">=</span> position[<span class="bu">len</span>(position)<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>width_guess <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># mm</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [V_max_guess, V_min_guess, center_guess, width_guess]</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit the data</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(beam_profile, position, voltage, p0<span class="op">=</span>p0)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract results</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>V_max, V_min, center, width <span class="op">=</span> popt</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>V_max_err, V_min_err, center_err, width_err <span class="op">=</span> perr</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam width: w = </span><span class="sc">{</span>width<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>width_err<span class="sc">:.4f}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam center: x0 = </span><span class="sc">{</span>center<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>center_err<span class="sc">:.4f}</span><span class="ss"> mm&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.2.3" id="step-3-plot-the-fit"><span
         class="header-section-number">8.2.3</span> Step 3: Plot the
         Fit</h3>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate smooth curve for plotting</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>x_fit <span class="op">=</span> np.linspace(position.<span class="bu">min</span>(), position.<span class="bu">max</span>(), <span class="dv">200</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>v_fit <span class="op">=</span> beam_profile(x_fit, <span class="op">*</span>popt)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>plt.plot(position, voltage, <span class="st">&#39;bo&#39;</span>, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x_fit, v_fit, <span class="st">&#39;r-&#39;</span>, label<span class="op">=</span><span class="ss">f&#39;Fit: w = </span><span class="sc">{</span>width<span class="sc">:.3f}</span><span class="ss"> ± </span><span class="sc">{</span>width_err<span class="sc">:.3f}</span><span class="ss"> mm&#39;</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (mm)&#39;</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Beam Profile with Error Function Fit&#39;</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;beam_profile_fit.png&#39;</span>, dpi<span class="op">=</span><span class="dv">150</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <p><strong>Record in your notebook:</strong> - Beam width: $w =
         $ _______ <span class="math inline">\(\pm\)</span> _______ mm -
         Measurement position: $z = $ _______ m from laser</p>
         <p><strong>Connection to Week 2:</strong> The uncertainty in
         your fit parameters depends on the noise level in your voltage
         measurements. Your Week 2 noise characterization tells you what
         σ_V to expect at your gain setting. Look at the residuals (data
         minus fit)—does their scatter match your predicted noise level?
         If the residuals are much larger than expected, you may have
         additional noise sources (vibration, beam drift) affecting your
         measurement.</p>
         <h2 data-number="8.3" id="predicting-week-4-results"><span
         class="header-section-number">8.3</span> Predicting Week 4
         Results</h2>
         <p>Now use your measured beam width to make predictions for
         Week 4. This is where error propagation becomes practical.</p>
         <h3 data-number="8.3.1"
         id="step-1-estimate-beam-waist-from-your-measurement"><span
         class="header-section-number">8.3.1</span> Step 1: Estimate
         Beam Waist from Your Measurement</h3>
         <p>Using the Gaussian beam equation:</p>
         <p><span class="math display">\[w(z) =
         w_0\sqrt{1+\left(\frac{\lambda (z - z_w)}{\pi
         w_0^2}\right)^2}\]</span></p>
         <p>If we assume <span class="math inline">\(z_w \approx
         0\)</span> (beam waist at laser output), we can estimate <span
         class="math inline">\(w_0\)</span> from a single measurement.
         Rearranging:</p>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Your measured values (replace with your actual data)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>w_measured <span class="op">=</span> ufloat(<span class="fl">0.52</span>, <span class="fl">0.03</span>)  <span class="co"># mm - USE YOUR VALUE</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>z_measured <span class="op">=</span> ufloat(<span class="fl">1.5</span>, <span class="fl">0.01</span>)   <span class="co"># m - USE YOUR VALUE</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>wavelength <span class="op">=</span> <span class="fl">632.8e-9</span>  <span class="co"># m (He-Ne laser)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert w to meters</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>w_m <span class="op">=</span> w_measured <span class="op">*</span> <span class="fl">1e-3</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># For a beam at distance z from waist, we can estimate w0</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># This is approximate - assumes z &gt;&gt; z_R (far from waist)</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co"># w ≈ w0 * z * λ / (π * w0²) = z * λ / (π * w0)</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co"># So w0 ≈ z * λ / (π * w)</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>w0_approx <span class="op">=</span> z_measured <span class="op">*</span> wavelength <span class="op">/</span> (np.pi <span class="op">*</span> w_m)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Approximate beam waist: w0 ≈ </span><span class="sc">{</span>w0_approx<span class="op">*</span><span class="fl">1e6</span><span class="sc">:.1f}</span><span class="ss"> μm&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.3.2"
         id="step-2-predict-beam-widths-at-other-positions"><span
         class="header-section-number">8.3.2</span> Step 2: Predict Beam
         Widths at Other Positions</h3>
         <p>Use error propagation to predict what you’ll measure in Week
         4:</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict beam width at different positions</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>, <span class="fl">2.0</span>]  <span class="co"># meters</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Predicted beam widths for Week 4:&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;-&quot;</span> <span class="op">*</span> <span class="dv">40</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> z <span class="kw">in</span> positions:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    z_val <span class="op">=</span> ufloat(z, <span class="fl">0.01</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    z_R <span class="op">=</span> np.pi <span class="op">*</span> w0_approx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> wavelength</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    w_pred <span class="op">=</span> w0_approx <span class="op">*</span> sqrt(<span class="dv">1</span> <span class="op">+</span> (z_val <span class="op">/</span> z_R)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;z = </span><span class="sc">{</span>z<span class="sc">:.1f}</span><span class="ss"> m:  w = </span><span class="sc">{</span>w_pred<span class="op">*</span><span class="fl">1e3</span><span class="sc">:.3f}</span><span class="ss"> mm&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.3.3"
         id="step-3-record-your-predictions"><span
         class="header-section-number">8.3.3</span> Step 3: Record Your
         Predictions</h3>
         <p>Fill in this table in your notebook:</p>
         <table>
         <thead>
         <tr class="header">
         <th>Position <span class="math inline">\(z\)</span></th>
         <th>Predicted <span class="math inline">\(w(z)\)</span></th>
         <th>Predicted uncertainty</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>0.5 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="even">
         <td>1.0 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="odd">
         <td>1.5 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="even">
         <td>2.0 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         </tbody>
         </table>
         <p><strong>Prediction reflection:</strong> If your Week 4
         measurements differ significantly from these predictions, what
         are the most likely causes? List at least two possibilities,
         and for each one, describe what signature in your Week 4 data
         would distinguish that cause from the others. (For example:
         Would the discrepancy be systematic across all positions? Would
         it affect near-field and far-field measurements
         differently?)</p>
         <h2 data-number="8.4"
         id="comparing-manual-vs.-motor-controlled-measurements"><span
         class="header-section-number">8.4</span> Comparing Manual
         vs. Motor-Controlled Measurements</h2>
         <p>If you took beam width measurements manually in Week 1,
         compare them to today’s motor-controlled measurement:</p>
         <table>
         <thead>
         <tr class="header">
         <th>Method</th>
         <th>Beam width</th>
         <th>Uncertainty</th>
         <th>Notes</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>Week 1 (manual)</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         <td></td>
         </tr>
         <tr class="even">
         <td>Week 3 (motor)</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         <td></td>
         </tr>
         </tbody>
         </table>
         <p>Are they consistent within uncertainties? If not, what might
         explain the difference?</p>
         <h1 data-number="9" id="deliverables-and-assessment"><span
         class="header-section-number">9</span> Deliverables and
         Assessment</h1>
         <p>Your lab notebook should include the following for this
         week:</p>
         <h2 data-number="9.1"
         id="prelab-complete-before-lab-75-min"><span
         class="header-section-number">9.1</span> Prelab (complete
         before lab, ~75 min)</h2>
         <ol type="1">
         <li><strong>Paraxial wave equation derivation</strong>: show
         the key steps from Maxwell’s equations to Equation 7</li>
         <li><strong>Physical Intuition Check</strong>: answers to all 5
         questions</li>
         <li><strong>Gaussian beam model questions</strong>: answers to
         questions 1-4 in “Trying out the Gaussian beam model”</li>
         <li><strong>Beyond Beam Width reflection</strong>: when might
         you need to measure <span class="math inline">\(R(z)\)</span>
         or <span class="math inline">\(\zeta(z)\)</span> directly?</li>
         </ol>
         <h2 data-number="9.2" id="in-lab-documentation"><span
         class="header-section-number">9.2</span> In-Lab
         Documentation</h2>
         <h3 data-number="9.2.1" id="phase-2-measurement-60-min"><span
         class="header-section-number">9.2.1</span> Phase 2: Measurement
         (~60 min)</h3>
         <ol type="1">
         <li><strong>Motor controller verification</strong>:
         <ul>
         <li>Completed setup checklist (DAQ, motor connection, movement
         test)</li>
         <li>Motor serial number recorded</li>
         <li>Troubleshooting reflection</li>
         </ul></li>
         <li><strong>Beam profile data</strong>:
         <ul>
         <li>Raw data file saved</li>
         <li>Position of measurement from laser: $z = $ _______ m</li>
         <li>Quick check: does data show clean transition?</li>
         </ul></li>
         </ol>
         <h3 data-number="9.2.2" id="phase-3-analysis-60-min"><span
         class="header-section-number">9.2.2</span> Phase 3: Analysis
         (~60 min)</h3>
         <ol start="3" type="1">
         <li><strong>Beam profile fit</strong>:
         <ul>
         <li>Fit plot showing data and error function model</li>
         <li>Extracted beam width: $w = $ _______ <span
         class="math inline">\(\pm\)</span> _______ mm</li>
         </ul></li>
         <li><strong>Error propagation and predictions</strong>:
         <ul>
         <li>Estimated beam waist <span
         class="math inline">\(w_0\)</span></li>
         <li>Predicted beam widths at 4 positions for Week 4</li>
         <li>Prediction reflection (what could cause disagreement?)</li>
         </ul></li>
         <li><strong>Comparison</strong> (if Week 1 data available):
         <ul>
         <li>Manual vs. motor-controlled beam width comparison</li>
         </ul></li>
         </ol>
         <h2 data-number="9.3" id="code-deliverables"><span
         class="header-section-number">9.3</span> Code Deliverables</h2>
         <ol type="1">
         <li>Motor communication test script</li>
         <li>Beam profile fitting script</li>
         </ol>
         <h2 data-number="9.4" id="reflection-questions"><span
         class="header-section-number">9.4</span> Reflection
         Questions</h2>
         <ol type="1">
         <li><p>What was the dominant source of uncertainty in your beam
         width measurement? How could you reduce it?</p></li>
         <li><p>Based on your motor controller setup experience, what
         was the most challenging part? How would you help a classmate
         who encountered the same issue?</p></li>
         <li><p>Look at your predicted beam widths for Week 4. Which
         measurement position will have the largest <em>relative</em>
         uncertainty (σ_w / w)? Why?</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
