<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 3</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#where-we-are-in-the-sequence"><span
            class="toc-section-number">1</span> Where We Are in the
            Sequence</a></li>
            <li><a href="#overview"><span
            class="toc-section-number">2</span> Overview</a></li>
            <li><a href="#learning-goals"><span
            class="toc-section-number">3</span> Learning Goals</a></li>
            <li><a href="#overview-of-your-work"><span
            class="toc-section-number">4</span> Overview of Your
            Work</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">5</span> Prelab</a>
            <ul>
            <li><a href="#gaussian-beam-theory"><span
            class="toc-section-number">5.1</span> Gaussian beam
            theory</a></li>
            <li><a href="#sec:wave-eqn"><span
            class="toc-section-number">5.2</span> Paraxial wave
            equation</a></li>
            <li><a href="#physical-intuition-check"><span
            class="toc-section-number">5.3</span> Physical Intuition
            Check</a></li>
            <li><a href="#trying-out-the-gaussian-beam-model"><span
            class="toc-section-number">5.4</span> Trying out the
            Gaussian beam model</a></li>
            <li><a
            href="#beyond-beam-radius-the-unmeasured-parameters"><span
            class="toc-section-number">5.5</span> Beyond Beam Radius:
            The Unmeasured Parameters</a>
            <ul>
            <li><a
            href="#what-we-can-and-cannot-measure-with-a-knife-edge"><span
            class="toc-section-number">5.5.1</span> What we can and
            cannot measure with a knife edge</a></li>
            <li><a href="#how-would-you-measure-rz"><span
            class="toc-section-number">5.5.2</span> How would you
            measure <span class="math inline">\(R(z)\)</span>?</a></li>
            <li><a href="#how-would-you-measure-zetaz"><span
            class="toc-section-number">5.5.3</span> How would you
            measure <span
            class="math inline">\(\zeta(z)\)</span>?</a></li>
            <li><a
            href="#why-does-the-beam-radius-wz-suffice-for-this-lab"><span
            class="toc-section-number">5.5.4</span> Why does the beam
            radius <span class="math inline">\(w(z)\)</span> suffice for
            this lab?</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#setting-up-the-motor-controller"><span
            class="toc-section-number">6</span> Setting Up the Motor
            Controller</a>
            <ul>
            <li><a href="#hardware-overview"><span
            class="toc-section-number">6.1</span> Hardware
            Overview</a></li>
            <li><a href="#software-prerequisites"><span
            class="toc-section-number">6.2</span> Software
            Prerequisites</a>
            <ul>
            <li><a href="#thorlabs-kinesis-sdk"><span
            class="toc-section-number">6.2.1</span> 1. Thorlabs Kinesis
            SDK</a></li>
            <li><a href="#python-packages"><span
            class="toc-section-number">6.2.2</span> 2. Python
            Packages</a></li>
            </ul></li>
            <li><a href="#verifying-the-motor-connection"><span
            class="toc-section-number">6.3</span> Verifying the Motor
            Connection</a>
            <ul>
            <li><a href="#test-that-windows-recognizes-the-device"><span
            class="toc-section-number">6.3.1</span> Test that Windows
            Recognizes the Device</a></li>
            <li><a href="#test-basic-motor-communication"><span
            class="toc-section-number">6.3.2</span> Test Basic Motor
            Communication</a></li>
            <li><a href="#test-motor-movement"><span
            class="toc-section-number">6.3.3</span> Test Motor
            Movement</a></li>
            <li><a href="#homing-the-stage"><span
            class="toc-section-number">6.3.4</span> Homing the
            Stage</a></li>
            </ul></li>
            <li><a href="#motor-controller-troubleshooting"><span
            class="toc-section-number">6.4</span> Motor Controller
            Troubleshooting</a></li>
            <li><a href="#exercise-verify-your-setup"><span
            class="toc-section-number">6.5</span> Exercise: Verify Your
            Setup</a></li>
            <li><a href="#troubleshooting-reflection"><span
            class="toc-section-number">6.6</span> Troubleshooting
            Reflection</a></li>
            </ul></li>
            <li><a
            href="#taking-your-first-automated-beam-profile"><span
            class="toc-section-number">7</span> Taking Your First
            Automated Beam Profile</a>
            <ul>
            <li><a href="#measurement-procedure"><span
            class="toc-section-number">7.1</span> Measurement
            Procedure</a></li>
            <li><a href="#integrating-motor-and-daq"><span
            class="toc-section-number">7.2</span> Integrating Motor and
            DAQ</a></li>
            <li><a href="#quick-check"><span
            class="toc-section-number">7.3</span> Quick Check</a></li>
            </ul></li>
            <li><a href="#applying-theory-to-your-measurements"><span
            class="toc-section-number">8</span> Applying Theory to Your
            Measurements</a>
            <ul>
            <li><a
            href="#error-propagation-from-measured-to-derived-quantities"><span
            class="toc-section-number">8.1</span> Error Propagation:
            From Measured to Derived Quantities</a>
            <ul>
            <li><a href="#the-general-equation"><span
            class="toc-section-number">8.1.1</span> The General
            Equation</a></li>
            <li><a href="#error-propagation-in-python"><span
            class="toc-section-number">8.1.2</span> Error Propagation in
            Python</a></li>
            </ul></li>
            <li><a href="#fitting-your-beam-profile-data"><span
            class="toc-section-number">8.2</span> Fitting Your Beam
            Profile Data</a>
            <ul>
            <li><a href="#step-1-load-and-plot-your-data"><span
            class="toc-section-number">8.2.1</span> Step 1: Load and
            Plot Your Data</a></li>
            <li><a
            href="#step-2-define-and-fit-the-error-function-model"><span
            class="toc-section-number">8.2.2</span> Step 2: Define and
            Fit the Error Function Model</a></li>
            <li><a href="#step-3-plot-the-fit"><span
            class="toc-section-number">8.2.3</span> Step 3: Plot the
            Fit</a></li>
            </ul></li>
            <li><a href="#predicting-week-4-results"><span
            class="toc-section-number">8.3</span> Predicting Week 4
            Results</a>
            <ul>
            <li><a
            href="#step-1-estimate-beam-waist-from-your-measurement"><span
            class="toc-section-number">8.3.1</span> Step 1: Estimate
            Beam Waist from Your Measurement</a></li>
            <li><a
            href="#step-2-predict-beam-radii-at-other-positions"><span
            class="toc-section-number">8.3.2</span> Step 2: Predict Beam
            Radii at Other Positions</a></li>
            <li><a href="#step-3-record-your-predictions"><span
            class="toc-section-number">8.3.3</span> Step 3: Record Your
            Predictions</a></li>
            </ul></li>
            <li><a
            href="#comparing-manual-vs.-motor-controlled-measurements"><span
            class="toc-section-number">8.4</span> Comparing Manual
            vs. Motor-Controlled Measurements</a></li>
            </ul></li>
            <li><a href="#deliverables-and-assessment"><span
            class="toc-section-number">9</span> Deliverables and
            Assessment</a>
            <ul>
            <li><a href="#prelab-complete-before-lab-75-min"><span
            class="toc-section-number">9.1</span> Prelab (complete
            before lab, ~75 min)</a></li>
            <li><a href="#in-lab-documentation"><span
            class="toc-section-number">9.2</span> In-Lab
            Documentation</a>
            <ul>
            <li><a href="#phase-2-measurement-60-min"><span
            class="toc-section-number">9.2.1</span> Phase 2: Measurement
            (~60 min)</a></li>
            <li><a href="#phase-3-analysis-60-min"><span
            class="toc-section-number">9.2.2</span> Phase 3: Analysis
            (~60 min)</a></li>
            </ul></li>
            <li><a href="#code-deliverables"><span
            class="toc-section-number">9.3</span> Code
            Deliverables</a></li>
            <li><a href="#reflection-questions"><span
            class="toc-section-number">9.4</span> Reflection
            Questions</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="where-we-are-in-the-sequence"><span
         class="header-section-number">1</span> Where We Are in the
         Sequence</h1>
         <p><strong>Week 3 of 4: Theory, First Automated Measurement,
         and Analysis</strong></p>
         <p>Last week you characterized your photodetector’s noise and
         chose an optimal gain setting. This week you’ll learn the
         theoretical foundation for Gaussian beams, set up the motor
         controller, take your first automated beam profile, and apply
         error propagation to your real data.</p>
         <p><strong>Last week:</strong> Learned DAQ programming,
         characterized noise, chose gain setting</p>
         <p><strong>This week:</strong> Learn Gaussian beam theory → Set
         up motor → Take beam profile → Analyze with error
         propagation</p>
         <p><strong>Next week:</strong> Multiple beam profiles → Test
         Gaussian beam model → Investigate lens effects</p>
         <h1 data-number="2" id="overview"><span
         class="header-section-number">2</span> Overview</h1>
         <p>This week connects theory to practice. In the prelab, you’ll
         derive the Gaussian beam equations from Maxwell’s equations and
         develop physical intuition for beam propagation. In lab, you’ll
         set up the motor controller and take your first
         motor-controlled beam profile. Then you’ll apply error
         propagation to your actual data—not abstract examples—to
         predict uncertainties in your Week 4 measurements. By the end
         of this week, you’ll have tested your entire measurement system
         and made quantitative predictions for next week.</p>
         <h1 data-number="3" id="learning-goals"><span
         class="header-section-number">3</span> Learning Goals</h1>
         <p>After completing the prelab, you will be able to:</p>
         <ol type="1">
         <li>Derive the paraxial wave equation from Maxwell’s equations
         by applying the slowly-varying envelope approximation.</li>
         <li>Explain the physical meaning of Gaussian beam parameters
         (<span class="math inline">\(w_0\)</span>, <span
         class="math inline">\(w(z)\)</span>, <span
         class="math inline">\(R(z)\)</span>, <span
         class="math inline">\(\zeta(z)\)</span>) and how they relate to
         observable properties.</li>
         <li>Predict how beam radius changes with position using the
         Gaussian beam equations.</li>
         </ol>
         <p>After completing the lab, you will be able to:</p>
         <ol type="1">
         <li>Set up and operate the motor controller for automated
         measurements.</li>
         <li>Take a complete beam profile using motor-controlled
         positioning.</li>
         <li>Fit beam profile data to extract beam radius with
         uncertainty.</li>
         <li>Propagate uncertainties from measured quantities to derived
         quantities.</li>
         <li>Make quantitative predictions for Week 4 measurements based
         on your data.</li>
         </ol>
         <h1 data-number="4" id="overview-of-your-work"><span
         class="header-section-number">4</span> Overview of Your
         Work</h1>
         <p>This week has three phases:</p>
         <p><strong>Phase 1 - Theory (Prelab, ~75 min):</strong> Derive
         the Gaussian beam equations from Maxwell’s equations and build
         physical intuition. You’ll understand <em>why</em> beams have
         the shape they do.</p>
         <p><strong>Phase 2 - Measurement (Lab, ~60 min):</strong> Set
         up the motor controller and take a complete beam profile. This
         is your first automated measurement—a trial run before Week 4’s
         systematic data collection.</p>
         <p><strong>Phase 3 - Analysis (Lab, ~60 min):</strong> Apply
         error propagation to your actual beam radius measurement. Fit
         your data, calculate uncertainties, and make predictions for
         Week 4. This is where theory meets your measurements.</p>
         <p><em>See the detailed deliverables checklist at the end of
         this guide.</em></p>
         <h1 data-number="5" id="prelab"><span
         class="header-section-number">5</span> Prelab</h1>
         <p>This week’s prelab focuses on the theoretical foundation for
         Gaussian laser beams. You’ll derive the equations that describe
         how laser beams propagate and develop physical intuition for
         the key parameters. Error propagation will be covered in lab,
         where you’ll apply it directly to your measurements.</p>
         <h2 data-number="5.1" id="gaussian-beam-theory"><span
         class="header-section-number">5.1</span> Gaussian beam
         theory</h2>
         <p>Light is a propagating oscillation of the electromagnetic
         field. The general principles which govern electromagnetic
         waves are Maxwell’s equations. From these general relations, a
         vector wave equation can be derived.</p>
         <p><span id="eq:1" class="eqnos"><span class="math display">\[
         \nabla^2\vec{E}=\mu_0\epsilon_0
         \frac{\partial^2\vec{E}}{\partial
         t^2}\text{.}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>One of the simplest solutions is that of a plane wave
         propagating in the <span class="math inline">\(\hat{z}\)</span>
         direction:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=E_x\hat{x}cos(kz-\omega
         t+\phi_x)+E_y\hat{y}cos(kz-\omega
         t+\phi_y)\text{.}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>But as the measurements from the first week showed, our
         laser beams are commonly well approximated by a beam shape with
         a Gaussian intensity profile. Apparently, since these Gaussian
         profile beams exist, they must be solutions of the wave
         equation. The next section will discuss how we derive the
         Gaussian beam electric field, and give a few key results.</p>
         <h2 data-number="5.2" id="sec:wave-eqn"><span
         class="header-section-number">5.2</span> Paraxial wave
         equation</h2>
         <p>One important thing to note about the beam output from most
         lasers is that the width of the beam changes very slowly
         compared to the wavelength of light. Assume a complex solution,
         where the beam is propagating in the <span
         class="math inline">\(\hat{z}\)</span>-direction, with the
         electric field polarization in the <span
         class="math inline">\(\hat{x}\)</span>-direction:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=\hat{x}A(x,y,z)e^{i(kz-\omega
         t)}\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The basic idea is that the spatial pattern of the beam,
         described by the function <span
         class="math inline">\(A(x,y,z)\)</span>, does not change much
         over a wavelength. In the case of the He-Ne laser output, the
         function <span class="math inline">\(A(x,y,z)\)</span> is a
         Gaussian profile that changes its width as a function of <span
         class="math inline">\(z\)</span>. If we substitute the trial
         solution in Equation <a href="#eq:3">3</a> into the wave
         equation in Equation <a href="#eq:1">1</a> we get</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\hat{x} \left[
         \left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial z} - k^2A
         \right]e^{i(kz-\omega
         t)}=\hat{x}\mu_0\epsilon_oA(-\omega^2)e^{i(kz-\omega
         t)}\text{.}\quad\quad\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>This can be simplified recognizing that <span
         class="math inline">\(k^2=\omega^2/c^2=\mu_0\epsilon_0\omega^2\)</span>,
         where the speed of light is related to the permeability and
         permittivity of free space by <span
         class="math inline">\(c=(\mu_0\epsilon_0)^{-1/2}\)</span>.
         Also, the <span class="math inline">\(\hat{x}e^{i(kz-\omega
         t)}\)</span> term is common to both sides and can be dropped,
         which results in</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial
         z}=0\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So far, we have made no approximation to the solution or the
         wave equation, but now we apply the assumption that <span
         class="math inline">\(\partial{A}(x,y,z)/\partial{z}\)</span>
         changes slowly over a wavelength <span
         class="math inline">\(\lambda = 2\pi /k\)</span>, so we neglect
         the term</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\left| \frac{\partial^2A}{\partial z^2}
         \right| \ll \left|2ik\frac{\partial A}{\partial
         z}\right|\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <p>Finally, we get the paraxial wave equation,</p>
         <p><span id="eq:7" class="eqnos"><span
         class="math display">\[\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} + 2ik\frac{\partial
         A}{\partial
         z}=0\text{.}\]</span><span class="eqnos-number">(7)</span></span>
         </p>
         <p>One set of solutions to the paraxial wave equation are
         Gauss-Hermite beams, which have an intensity profiles like
         those shown in Figure <a href="#fig:gauss-hermite">2</a>. These
         are the same solutions as for the quantum simple harmonic
         oscillator, a topic that could be further explored as a final
         project.</p>
         <p>The simplest of these solutions is the Gaussian beam, which
         has an electric field given by</p>
         <p><span id="eq:8" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t) =
         \vec{E}_0\frac{w_0}{w(z)}exp\left(-\frac{x^2+y^2}{w^2(z)}\right)exp\left(ik\frac{x^2+y^2}{2R(z)}\right)e^{-i\zeta(z)}e^{i(kz-\omega
         t)}\text{,}\quad\quad\]</span><span class="eqnos-number">(8)</span></span>
         </p>
         <p>where <span class="math inline">\(\vec{E_0}\)</span> is a
         time-independent vector (orthogonal to propagation direction
         <span class="math inline">\(\hat{z}\)</span>) whose magnitude
         denotes the amplitude of the laser’s electric field and the
         direction denotes the direction of polarization. The beam
         radius <span class="math inline">\(w(z)\)</span> is given
         by</p>
         <p><span id="eq:9" class="eqnos"><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi
         w_0^2}\right)^2}\text{.}\]</span><span class="eqnos-number">(9)</span></span>
         </p>
         <blockquote>
         <p><strong>Terminology note:</strong> The parameter <span
         class="math inline">\(w\)</span> is called the <strong>beam
         radius</strong>—the distance from the beam axis to where the
         intensity falls to <span class="math inline">\(1/e^2\)</span>
         of its peak value. This follows from the Gaussian intensity
         profile <span class="math inline">\(I \propto
         e^{-2r^2/w^2}\)</span>: at <span class="math inline">\(r =
         w\)</span>, the intensity is <span class="math inline">\(e^{-2}
         = 1/e^2\)</span> of the maximum. You’ll explore this connection
         further below. The <strong>beam diameter</strong> would be
         <span class="math inline">\(2w\)</span>. Some texts use “beam
         width” for <span class="math inline">\(w\)</span>, but we use
         “beam radius” consistently in this lab to avoid confusion with
         the everyday meaning of “width” as a full extent.</p>
         </blockquote>
         <p><span class="math inline">\(R(z)\)</span>, the radius of
         curvature of the wavefront, is given by</p>
         <p><span id="eq:10" class="eqnos"><span
         class="math display">\[R(z)=z\left(1+\left(\frac{\pi
         w_0^2}{\lambda
         z}\right)^2\right)\text{,}\]</span><span class="eqnos-number">(10)</span></span>
         </p>
         <p>and the Gouy phase is given by</p>
         <p><span id="eq:11" class="eqnos"><span
         class="math display">\[\zeta(z)=\arctan\frac{\lambda z}{\pi
         w_0^2}\text{.}\]</span><span class="eqnos-number">(11)</span></span>
         </p>
         <p>The remarkable thing about all these equations is that only
         two parameters need to be specified to give the whole beam
         profile: the wavelength <span
         class="math inline">\(\lambda\)</span> and the beam waist <span
         class="math inline">\(w_0\)</span>, which is the narrowest
         point in the beam profile.</p>
         <div id="fig:gaussian-beam" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gaussian_beam_diagram.png"
         alt="Figure 1: Gaussian beam propagation showing the beam waist w_0, Rayleigh range z_R, and divergence angle \theta. The wavefronts (dashed gray lines) are flat at the waist and curved in the far field." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Gaussian
         beam propagation showing the beam waist <span
         class="math inline">\(w_0\)</span>, Rayleigh range <span
         class="math inline">\(z_R\)</span>, and divergence angle <span
         class="math inline">\(\theta\)</span>. The wavefronts (dashed
         gray lines) are flat at the waist and curved in the far
         field.</figcaption>
         </figure>
         </div>
         <p>There is a more general set of Hermite Gaussian modes which
         are shown in Figure <a href="#fig:gauss-hermite">2</a>. The
         laser cavity typically produces the (0,0) mode shown in the
         upper left corner, but an optical cavity can also be used to
         create these other modes – a topic that can be explored in the
         final projects.</p>
         <div id="fig:gauss-hermite" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-hermite.png"
         style="width:20cm"
         alt="Figure 2: Intensity distributions for the lowest order Gauss-Hermite solutions to the paraxial wave equation. The axes are in units of the beam radius, w." />
         <figcaption aria-hidden="true"><span>Figure 2:</span> Intensity
         distributions for the lowest order Gauss-Hermite solutions to
         the paraxial wave equation. The axes are in units of the beam
         radius, <span class="math inline">\(w\)</span>.</figcaption>
         </figure>
         </div>
         <h2 data-number="5.3" id="physical-intuition-check"><span
         class="header-section-number">5.3</span> Physical Intuition
         Check</h2>
         <p>Before applying these equations, test your physical
         understanding. Answer each question without looking at the
         equations, then verify with a calculation.</p>
         <ol type="1">
         <li><p><strong>Scaling the waist:</strong> If you double the
         beam waist <span class="math inline">\(w_0\)</span>, what
         happens to:</p>
         <ul>
         <li>The divergence angle <span class="math inline">\(\theta =
         \lambda / (\pi w_0)\)</span> in the far field?</li>
         <li>The Rayleigh range <span class="math inline">\(z_R = \pi
         w_0^2 / \lambda\)</span>?</li>
         </ul>
         <p><em>Intuition check:</em> A wider waist means the beam is
         more collimated (less divergent). Does your answer reflect
         this?</p></li>
         <li><p><strong>Distance to double:</strong> At what distance
         from the waist does the beam radius double (i.e., <span
         class="math inline">\(w(z) = 2w_0\)</span>)?</p>
         <p><em>Hint:</em> Set up the equation and solve for <span
         class="math inline">\(z\)</span> in terms of <span
         class="math inline">\(z_R\)</span>. The answer is a simple
         multiple of the Rayleigh range.</p></li>
         <li><p><strong>Wavelength dependence:</strong> Two lasers have
         identical beam waists <span class="math inline">\(w_0\)</span>,
         but one is red (633 nm) and one is blue (450 nm). Which beam
         diverges more rapidly? Why?</p></li>
         <li><p><strong>Conservation of energy:</strong> As the beam
         expands, the width increases but the total power stays
         constant. What must happen to the peak intensity <span
         class="math inline">\(I_{max}\)</span> as <span
         class="math inline">\(z\)</span> increases? Write a
         proportionality relationship.</p></li>
         <li><p><strong>Beam quality check:</strong> You measure a beam
         radius of <span class="math inline">\(w = 0.8\)</span> mm at
         <span class="math inline">\(z = 1\)</span> m from the laser.
         Assuming <span class="math inline">\(\lambda = 633\)</span> nm,
         what is the minimum possible beam waist? (Hint: The waist could
         be inside or outside the laser cavity.)</p></li>
         </ol>
         <p><em>Record your answers in your notebook. Getting physical
         intuition wrong is valuable—it reveals gaps in understanding
         that equations alone can hide.</em></p>
         <h2 data-number="5.4"
         id="trying-out-the-gaussian-beam-model"><span
         class="header-section-number">5.4</span> Trying out the
         Gaussian beam model</h2>
         <p>In the first week of the lab, we assumed the intensity
         profile of the Gaussian beam was given by <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>.
         The equation for the electric field of the Gaussian Beam in
         Equation <a href="#eq:8">8</a> looks substantially more
         complicated.</p>
         <ol type="1">
         <li>How are the expressions for electric field and intensity
         related?</li>
         <li>Is Equation <a href="#eq:8">8</a> consistent with the
         simple expression for intensity <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>?</li>
         </ol>
         <p>The Gaussian beam equations given in Equations <a
         href="#eq:8">8</a> -<a href="#eq:11">11</a> assume the beam
         comes to its narrowest width (called the beam waist, <span
         class="math inline">\(w_0\)</span>) at <span
         class="math inline">\(z=0\)</span>.</p>
         <ol start="3" type="1">
         <li>How would you rewrite these four equations assuming the
         beam waist occurs at a different position <span
         class="math inline">\(z=z_w\)</span>?</li>
         <li>One way to check your answer is to make sure the equations
         simplify to Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a> in the special case of <span
         class="math inline">\(z_w=0\)</span>.</li>
         </ol>
         <p><em>You will fit actual beam radius data in lab today using
         these modified equations.</em></p>
         <h2 data-number="5.5"
         id="beyond-beam-radius-the-unmeasured-parameters"><span
         class="header-section-number">5.5</span> Beyond Beam Radius:
         The Unmeasured Parameters</h2>
         <p>The Gaussian beam solution contains three key z-dependent
         quantities: the beam radius <span
         class="math inline">\(w(z)\)</span>, the wavefront radius of
         curvature <span class="math inline">\(R(z)\)</span>, and the
         Gouy phase <span class="math inline">\(\zeta(z)\)</span>. In
         Week 4, you will measure only <span
         class="math inline">\(w(z)\)</span> using the knife-edge
         technique. What about the others?</p>
         <h3 data-number="5.5.1"
         id="what-we-can-and-cannot-measure-with-a-knife-edge"><span
         class="header-section-number">5.5.1</span> What we can and
         cannot measure with a knife edge</h3>
         <p>The knife-edge profiler measures <strong>intensity</strong>
         as a function of position. This directly gives you <span
         class="math inline">\(w(z)\)</span>, the beam radius.
         However:</p>
         <ul>
         <li><p><strong><span class="math inline">\(R(z)\)</span>
         (radius of curvature):</strong> This describes how the
         wavefronts are curved. Larger <span
         class="math inline">\(R\)</span> means flatter (less curved);
         <span class="math inline">\(R = \infty\)</span> is perfectly
         flat. The wavefronts are flattest at the waist, most curved at
         <span class="math inline">\(z = z_R\)</span>, then become
         flatter again far away. A knife edge only sees intensity, not
         phase, so it cannot measure <span
         class="math inline">\(R(z)\)</span> directly.</p></li>
         <li><p><strong><span class="math inline">\(\zeta(z)\)</span>
         (Gouy phase):</strong> This is a phase shift that accumulates
         as the beam passes through its waist. Like <span
         class="math inline">\(R(z)\)</span>, it requires
         phase-sensitive measurements.</p></li>
         </ul>
         <h3 data-number="5.5.2" id="how-would-you-measure-rz"><span
         class="header-section-number">5.5.2</span> How would you
         measure <span class="math inline">\(R(z)\)</span>?</h3>
         <p>If you wanted to measure the wavefront curvature, you would
         need <strong>interferometry</strong>—combining your beam with a
         reference beam and analyzing the interference pattern. The
         spacing and curvature of interference fringes reveals <span
         class="math inline">\(R(z)\)</span>.</p>
         <p><strong>Think about it:</strong> Near the waist, <span
         class="math inline">\(R(z) \to \infty\)</span> (flat
         wavefronts). At <span class="math inline">\(z = z_R\)</span>,
         <span class="math inline">\(R\)</span> reaches its minimum
         value of <span class="math inline">\(2z_R\)</span> (maximum
         curvature). Far from the waist, <span
         class="math inline">\(R(z) \approx z\)</span>—the wavefronts
         are spherical surfaces centered on the waist, but with large
         radius (gentle curvature). This non-monotonic behavior means
         the wavefronts curve most strongly at one Rayleigh range from
         the waist, not at large distances.</p>
         <h3 data-number="5.5.3" id="how-would-you-measure-zetaz"><span
         class="header-section-number">5.5.3</span> How would you
         measure <span class="math inline">\(\zeta(z)\)</span>?</h3>
         <p>The Gouy phase shift is subtle—it’s a <span
         class="math inline">\(\pi\)</span> total phase change as the
         beam goes from <span class="math inline">\(z = -\infty\)</span>
         to <span class="math inline">\(z = +\infty\)</span> through the
         waist. Detecting it requires:</p>
         <ol type="1">
         <li><strong>Interferometry with a reference beam</strong> that
         bypasses the focus</li>
         <li><strong>Mode-matching experiments</strong> where the Gouy
         phase affects coupling efficiency</li>
         </ol>
         <p>The Gouy phase has practical consequences: it affects the
         resonant frequencies of laser cavities and the focal properties
         of lens systems.</p>
         <h3 data-number="5.5.4"
         id="why-does-the-beam-radius-wz-suffice-for-this-lab"><span
         class="header-section-number">5.5.4</span> Why does the beam
         radius <span class="math inline">\(w(z)\)</span> suffice for
         this lab?</h3>
         <p>For characterizing a laser beam’s propagation, <span
         class="math inline">\(w(z)\)</span> is often the most
         practically important parameter because:</p>
         <ol type="1">
         <li>It determines the spot size for any application (machining,
         microscopy, communications)</li>
         <li>Combined with the wavelength <span
         class="math inline">\(\lambda\)</span>, measurements of <span
         class="math inline">\(w(z)\)</span> at multiple positions
         uniquely determine the waist <span
         class="math inline">\(w_0\)</span> and waist position <span
         class="math inline">\(z_w\)</span></li>
         <li>Once you know <span class="math inline">\(w_0\)</span>, you
         can <em>calculate</em> <span
         class="math inline">\(R(z)\)</span> and <span
         class="math inline">\(\zeta(z)\)</span> from the equations—you
         don’t need to measure them separately</li>
         </ol>
         <p><strong>Reflection:</strong> In what applications might you
         actually need to measure <span
         class="math inline">\(R(z)\)</span> or <span
         class="math inline">\(\zeta(z)\)</span> rather than just
         calculating them from <span class="math inline">\(w_0\)</span>?
         (Hint: The theoretical equations assume a perfect Gaussian
         beam. Consider what happens with aberrated optics, higher-order
         modes, or beams of unknown origin.)</p>
         <h1 data-number="6" id="setting-up-the-motor-controller"><span
         class="header-section-number">6</span> Setting Up the Motor
         Controller</h1>
         <p>You will use Python to automate beam profile measurements by
         controlling a motorized translation stage. This section guides
         you through setting up and verifying the motor controller
         hardware this week, so you’re ready for systematic data
         collection in Week 4.</p>
         <p><strong>If you did not complete section 10 from week 1
         (manual data collection), you must do that now before
         proceeding as you will need to remove the micrometer installed
         in the translation stage in the next section.</strong></p>
         <h2 data-number="6.1" id="hardware-overview"><span
         class="header-section-number">6.1</span> Hardware Overview</h2>
         <p>The Thorlabs KST101 and ZST225B is a stepper motor
         controller and stepper motor actuator that can precisely
         position a translation stage. You will use it to move a razor
         blade across the laser beam while the DAQ records the
         photodetector signal.</p>
         <p>For detailed specifications and documentation, see the <a
         href="https://www.thorlabs.com/thorproduct.cfm?partnumber=KST101">KST101
         controller</a> and <a
         href="https://www.thorlabs.com/thorproduct.cfm?partnumber=ZST225B">ZST225B
         actuator</a> product pages on the Thorlabs website.</p>
         <p>The physical connections are:</p>
         <ol type="1">
         <li><strong>Motor Controller (KST101)</strong>:
         <ul>
         <li>Install the ZST225B actuator into the translation stage
         (removing the manual micrometer that was used in week 1)</li>
         <li>Connect the ZST225B actuator to the KST101 controller</li>
         <li>Connect the power supply to the KST101</li>
         <li><strong>Do not connect USB yet</strong> — you must first
         configure the stage type (see “Verifying the Motor Connection”
         below)</li>
         </ul></li>
         <li><strong>Optical Setup</strong> (for testing):
         <ul>
         <li>Position the photodetector after the knife-edge in the beam
         path</li>
         <li>Ensure the beam passes cleanly through when the razor is
         fully retracted</li>
         </ul></li>
         </ol>
         <h2 data-number="6.2" id="software-prerequisites"><span
         class="header-section-number">6.2</span> Software
         Prerequisites</h2>
         <p><strong>This section is for users who want to install the
         software on their personal devices. The lab laptops already
         have this installed.</strong></p>
         <h3 data-number="6.2.1" id="thorlabs-kinesis-sdk"><span
         class="header-section-number">6.2.1</span> 1. Thorlabs Kinesis
         SDK</h3>
         <p>Download and install from the Thorlabs website: <a
         href="https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control">https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control</a></p>
         <p><strong>Important</strong>: Choose the correct version:</p>
         <ul>
         <li>If you have 32-bit Python: Install the 32-bit Kinesis
         software</li>
         <li>If you have 64-bit Python: Install the 64-bit Kinesis
         software</li>
         </ul>
         <p>To check your Python version, run:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys.maxsize <span class="op">&gt;</span> <span class="dv">2</span><span class="op">**</span><span class="dv">32</span>)  <span class="co"># True = 64-bit, False = 32-bit</span></span></code></pre></div>
         <h3 data-number="6.2.2" id="python-packages"><span
         class="header-section-number">6.2.2</span> 2. Python
         Packages</h3>
         <p>Install the required packages:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pythonnet uncertainties</span></code></pre></div>
         <ul>
         <li><code>pythonnet</code>: Required for interfacing with
         Thorlabs Kinesis motor control</li>
         <li><code>uncertainties</code>: Required for error propagation
         calculations in the analysis section</li>
         </ul>
         <p>(You should already have <code>nidaqmx</code>,
         <code>numpy</code>, <code>scipy</code>, and
         <code>matplotlib</code> from Week 2.)</p>
         <h2 data-number="6.3" id="verifying-the-motor-connection"><span
         class="header-section-number">6.3</span> Verifying the Motor
         Connection</h2>
         <h3 data-number="6.3.1"
         id="test-that-windows-recognizes-the-device"><span
         class="header-section-number">6.3.1</span> Test that Windows
         Recognizes the Device</h3>
         <p><strong>Important:</strong> Before using Python, the KST101
         must be configured with the correct stage type. This is a
         one-time setup stored in the controller’s memory.</p>
         <ol type="1">
         <li><strong>Without</strong> connecting the USB cable from the
         KST101 to your PC, power on the KST101</li>
         <li>Press the Menu button</li>
         <li>Use the wheel to navigate to “10 Select Stage”</li>
         <li>Press the Menu button again</li>
         <li>Select your actuator type (ZST225) by using the wheel to
         navigate</li>
         <li>Press the Menu button again to save and exit</li>
         <li>Power cycle the controller using the power switch on the
         KST101 (unplugging it will not save the settings)</li>
         <li>After power cycling, plug the USB cable from the KST101
         into your PC</li>
         <li>Open the Kinesis app</li>
         <li>Connect to the KST101 from the Kinesis app if it’s not
         connected automatically</li>
         <li>Verify that the section in the bottom right corner of the
         <code>KCube Stepper Motor Controller</code> window indicates
         <code>Actuator: HS ZST225B</code> - if it’s listed as another
         type, click on this section to change it</li>
         <li>Close the Kinesis app</li>
         </ol>
         <p>After completing these steps, you should not need to do this
         again as long as you continue to use the same laptop and
         KST101.</p>
         <h3 data-number="6.3.2"
         id="test-basic-motor-communication"><span
         class="header-section-number">6.3.2</span> Test Basic Motor
         Communication</h3>
         <p>Run this test script to verify Python can communicate with
         the motor:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Add Kinesis .NET assemblies</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Build device list</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Get list of connected devices</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>device_list <span class="op">=</span> DeviceManagerCLI.GetDeviceList()</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Found </span><span class="sc">{</span><span class="bu">len</span>(device_list)<span class="sc">}</span><span class="ss"> device(s):&quot;</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> serial <span class="kw">in</span> device_list:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Serial: </span><span class="sc">{</span>serial<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <p>If this shows your device serial number, the connection is
         working.</p>
         <h3 data-number="6.3.3" id="test-motor-movement"><span
         class="header-section-number">6.3.3</span> Test Motor
         Movement</h3>
         <p><strong>Caution</strong>: Make sure the translation stage
         has room to move before running this test. Check that nothing
         is blocking the stage mechanically.</p>
         <p><strong>Note</strong>: This test uses relative movement, so
         you don’t need to home first. However, you should home the
         stage (see next section) before taking actual measurements.</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.GenericMotorCLI&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> System <span class="im">import</span> Decimal</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace with your serial number</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>SERIAL_NUMBER <span class="op">=</span> <span class="st">&quot;26004813&quot;</span>  <span class="co"># Check the display on your KST101</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> KCubeStepper.CreateKCubeStepper(SERIAL_NUMBER)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    device.Connect(SERIAL_NUMBER)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Connected!&quot;</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Wait for settings to initialize</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    device.WaitForSettingsInitialized(<span class="dv">5000</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    device.StartPolling(<span class="dv">50</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    device.EnableDevice()</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Load motor configuration</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    config <span class="op">=</span> device.LoadMotorConfiguration(SERIAL_NUMBER)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get current position</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> device.Position</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Current position: </span><span class="sc">{</span>pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move relative (small test movement)</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Moving 0.5 mm...&quot;</span>)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    device.SetMoveRelativeDistance(Decimal(<span class="fl">0.5</span>))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    device.MoveRelative(<span class="dv">60000</span>)  <span class="co"># 60 second timeout</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    new_pos <span class="op">=</span> device.Position</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;New position: </span><span class="sc">{</span>new_pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a><span class="cf">finally</span>:</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    device.StopPolling()</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    device.Disconnect()</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Disconnected&quot;</span>)</span></code></pre></div>
         <p>After you’ve successfully run the code above, verify that
         the position value reported from Python matches the position
         that is indicated on the screen of the KST101 - if these
         numbers disagree, please let your instructor or the technical
         staff know before proceeding.</p>
         <h3 data-number="6.3.4" id="homing-the-stage"><span
         class="header-section-number">6.3.4</span> Homing the
         Stage</h3>
         <p>When the motor controller is powered on, it doesn’t know the
         stage’s absolute position. <strong>Homing</strong> moves the
         stage to a known reference point (typically one end of travel),
         establishing a reliable zero position.</p>
         <p><strong>When to home:</strong></p>
         <ul>
         <li>Once at the start of each measurement session</li>
         <li>After the stage hits a travel limit</li>
         <li>If the reported position seems incorrect</li>
         </ul>
         <p><strong>To home the stage in Python:</strong></p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># After device.EnableDevice() and loading configuration:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Homing...&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>device.Home(<span class="dv">60000</span>)  <span class="co"># 60 second timeout</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Homed. Position: </span><span class="sc">{</span>device<span class="sc">.</span>Position<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span></code></pre></div>
         <p>The stage will move to its home position (near 0 mm). This
         may take several seconds. You can also home the stage using the
         front panel: press the Menu button and use the wheel to
         navigate to the Home option.</p>
         <h2 data-number="6.4"
         id="motor-controller-troubleshooting"><span
         class="header-section-number">6.4</span> Motor Controller
         Troubleshooting</h2>
         <p><strong>“Device not found” Error:</strong></p>
         <ul>
         <li>Check USB connection</li>
         <li>Verify serial number matches the display on the KST101</li>
         <li>Make sure no other software (APT User, Kinesis) is using
         the motor</li>
         </ul>
         <p><strong>Motor Doesn’t Move:</strong></p>
         <ul>
         <li>Ensure power is connected to the KST101</li>
         <li>Check that the stage isn’t at a travel limit</li>
         <li>Verify the stage type is configured correctly in Kinesis
         (ZST225B)</li>
         </ul>
         <p><strong>Python Import Errors:</strong></p>
         <ul>
         <li>Ensure Kinesis SDK is installed and matches Python
         architecture (32/64-bit)</li>
         <li>Check that the path to Kinesis DLLs is correct</li>
         </ul>
         <h2 data-number="6.5" id="exercise-verify-your-setup"><span
         class="header-section-number">6.5</span> Exercise: Verify Your
         Setup</h2>
         <p>Before leaving lab today, verify that:</p>
         <ol type="1">
         <li><input type="checkbox" disabled="" />
         The DAQ can read voltages from the photodetector</li>
         <li><input type="checkbox" disabled="" />
         Python can connect to the motor controller</li>
         <li><input type="checkbox" disabled="" />
         The motor moves when commanded</li>
         <li><input type="checkbox" disabled="" />
         The stage has been homed successfully</li>
         <li><input type="checkbox" disabled="" />
         You have noted your motor’s serial number: ____________</li>
         </ol>
         <p>This setup will be essential for the automated measurements
         in Week 4.</p>
         <p><strong>Note on AI assistance:</strong> The motor control
         code involves interfacing with hardware libraries that have
         specific requirements (correct DLL paths, serial numbers,
         initialization sequences). You may use AI to help generate this
         boilerplate code. What matters is that you can (1) verify the
         hardware is responding correctly, (2) diagnose common
         connection failures, and (3) modify parameters like movement
         distance and velocity. The Troubleshooting Reflection below
         tests these skills.</p>
         <h2 data-number="6.6" id="troubleshooting-reflection"><span
         class="header-section-number">6.6</span> Troubleshooting
         Reflection</h2>
         <p>Developing systematic troubleshooting skills is essential
         for experimental physics. Answer this question in your
         notebook:</p>
         <p><strong>If the motor doesn’t respond to Python commands,
         what troubleshooting steps would you take?</strong></p>
         <p>List at least three things you would check, <em>in order of
         likelihood</em>, and explain your reasoning. Consider:</p>
         <ul>
         <li>What are the most common failure modes?</li>
         <li>What’s the quickest way to isolate hardware vs. software
         issues?</li>
         <li>How would you determine if the problem is with Python, the
         USB connection, or the motor itself?</li>
         </ul>
         <p>This systematic approach to troubleshooting will serve you
         well in Week 4 and beyond.</p>
         <h1 data-number="7"
         id="taking-your-first-automated-beam-profile"><span
         class="header-section-number">7</span> Taking Your First
         Automated Beam Profile</h1>
         <p>Now that you have the motor controller working, take a
         complete beam profile measurement. Think of this as a
         <strong>trial run</strong>—you’re getting the kinks out before
         Week 4’s systematic data collection. This serves two purposes:
         (1) verify your entire measurement system works end-to-end, and
         (2) generate real data for the error propagation analysis later
         in this lab session.</p>
         <p><strong>Before you start, make a prediction:</strong> Will
         your automated data be more or less noisy than your manual
         measurements from Week 1? Why? Record your prediction in your
         notebook—you’ll revisit this after taking data.</p>
         <h2 data-number="7.1" id="measurement-procedure"><span
         class="header-section-number">7.1</span> Measurement
         Procedure</h2>
         <p>Here is an overview of the measurement process. The sections
         that follow provide details on integrating your code and
         checking your data quality.</p>
         <ol type="1">
         <li><p><strong>Position the knife-edge assembly</strong> at a
         known distance from the laser (measure and record this
         distance—you’ll need it for analysis).</p></li>
         <li><p><strong>Set up the measurement:</strong></p>
         <ul>
         <li>Ensure the photodetector is receiving the full beam when
         the knife-edge is retracted</li>
         <li>Use the gain setting you determined in Week 2</li>
         <li>Verify DAQ is reading reasonable voltages</li>
         </ul></li>
         <li><p><strong>Choose your measurement parameters:</strong></p>
         <p>Think about what step size will give you good data:</p>
         <ul>
         <li>Recall your beam radius <span
         class="math inline">\(w\)</span> from your Week 1 manual
         measurement</li>
         <li>The transition region where voltage changes spans roughly
         <span class="math inline">\(2w\)</span></li>
         <li>You want at least 10-15 points in the transition region to
         constrain your fit</li>
         <li>What step size does this imply?</li>
         </ul>
         <p>In Week 4, you will revisit this choice more systematically
         based on your specific beam radius and measurement
         goals.</p></li>
         <li><p><strong>Take the beam profile:</strong></p>
         <ul>
         <li>Move the knife-edge across the beam using your chosen step
         size</li>
         <li>At each position, record the motor position and
         photodetector voltage</li>
         <li>Continue until the beam is fully blocked (voltage reaches
         dark level)</li>
         </ul></li>
         <li><p><strong>Save your data</strong> with a descriptive
         filename including the date and z-position (e.g.,
         <code>beam_profile_2026-01-27_z50cm.csv</code>). In Week 4,
         you’ll collect profiles at multiple z-positions, so systematic
         naming will help you keep track of which data came from
         where.</p></li>
         </ol>
         <h2 data-number="7.2" id="integrating-motor-and-daq"><span
         class="header-section-number">7.2</span> Integrating Motor and
         DAQ</h2>
         <p>To automate beam profiling, you need to combine motor
         positioning with voltage reading. The code below shows the DAQ
         portion, but the motor movement is commented out.</p>
         <p><strong>To complete this code, you need a
         <code>move_to()</code> function.</strong> You have two
         options:</p>
         <ol type="1">
         <li><p><strong>Adapt the relative movement code</strong> from
         the verification section above (hint: use
         <code>device.MoveTo(Decimal(position_mm), timeout_ms)</code>
         for absolute positioning)</p></li>
         <li><p><strong>Reference the complete motor control
         documentation</strong> at <a
         href="/PHYS-4430/python-thorlabs">Thorlabs Motor Control with
         Python</a>, which includes a working <code>move_to()</code>
         function and a complete <code>run_position_scan()</code>
         example.</p></li>
         </ol>
         <p>Some decisions you’ll need to make: How long should you wait
         for vibrations to settle after each move? What position range
         covers the full transition from unblocked to fully blocked? How
         many samples should you average at each position to reduce
         noise?</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> np.arange(<span class="dv">0</span>, <span class="dv">3</span>, <span class="fl">0.1</span>)  <span class="co"># 0 to 3 mm in 0.1 mm steps</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> pos <span class="kw">in</span> positions:</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move motor to position (use your motor control code)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># device.MoveTo(Decimal(pos), 60000)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.3</span>)  <span class="co"># Wait for motor to settle</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read voltage (change &quot;Dev1/ai0&quot; to match your DAQ channel if needed)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(<span class="st">&quot;Dev1/ai0&quot;</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        voltage <span class="op">=</span> np.mean(task.read(number_of_samples_per_channel<span class="op">=</span><span class="dv">100</span>))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    data.append([pos, voltage])</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Position: </span><span class="sc">{</span>pos<span class="sc">:.2f}</span><span class="ss"> mm, Voltage: </span><span class="sc">{</span>voltage<span class="sc">:.4f}</span><span class="ss"> V&quot;</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Save data</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>np.savetxt(<span class="st">&#39;beam_profile_week3.csv&#39;</span>, data, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>,</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>           header<span class="op">=</span><span class="st">&#39;Position (mm), Voltage (V)&#39;</span>, comments<span class="op">=</span><span class="st">&#39;&#39;</span>)</span></code></pre></div>
         <h2 data-number="7.3" id="quick-check"><span
         class="header-section-number">7.3</span> Quick Check</h2>
         <p>Before proceeding to the analysis section (where you’ll fit
         this data to extract beam radius <span
         class="math inline">\(w\)</span>), verify your data looks
         reasonable:</p>
         <ul>
         <li>Does the voltage transition smoothly from high to low?
         (Some scatter is normal, but the trend should be clear.)</li>
         <li>Does your data span the full range from maximum voltage
         (beam unblocked) to minimum voltage (beam fully blocked)?</li>
         <li>Do you have at least 10 points in the transition region
         where the voltage is changing?</li>
         </ul>
         <p>If the transition is unclear or you have too few points,
         retake the measurement with smaller step sizes or a different
         position range.</p>
         <p><strong>Revisit your prediction:</strong> Was your automated
         data more or less noisy than your Week 1 manual data? What
         might explain the difference?</p>
         <h1 data-number="8"
         id="applying-theory-to-your-measurements"><span
         class="header-section-number">8</span> Applying Theory to Your
         Measurements</h1>
         <p>This section connects the Gaussian beam theory from your
         prelab to your actual measurements. You’ll learn error
         propagation by applying it to your own data—not abstract
         examples.</p>
         <h2 data-number="8.1"
         id="error-propagation-from-measured-to-derived-quantities"><span
         class="header-section-number">8.1</span> Error Propagation:
         From Measured to Derived Quantities</h2>
         <p>The quantity of interest in an experiment is often derived
         from other measured quantities. For example, you’ll derive beam
         radius <span class="math inline">\(w\)</span> from your
         knife-edge data, then use <span
         class="math inline">\(w\)</span> at multiple positions to
         determine the beam waist <span
         class="math inline">\(w_0\)</span>.</p>
         <h3 data-number="8.1.1" id="the-general-equation"><span
         class="header-section-number">8.1.1</span> The General
         Equation</h3>
         <p>Suppose you want to derive a quantity <span
         class="math inline">\(z\)</span> from measured quantities <span
         class="math inline">\(a, b, c, ...\)</span>. The mathematical
         function is <span class="math inline">\(z = z(a, b, c,
         ...)\)</span>. The propagated uncertainty in <span
         class="math inline">\(z\)</span> is:</p>
         <p><span class="math display">\[\sigma_z^2 = \left(
         \frac{\partial z}{\partial a}\right)^2\sigma_a^2+\left(
         \frac{\partial z}{\partial b}\right)^2\sigma_b^2+\left(
         \frac{\partial z}{\partial c}\right)^2\sigma_c^2+ \
         ...\text{.}\]</span></p>
         <p>This comes directly from calculus—it’s the linear
         approximation of how fluctuations in inputs cause fluctuations
         in outputs.</p>
         <h3 data-number="8.1.2" id="error-propagation-in-python"><span
         class="header-section-number">8.1.2</span> Error Propagation in
         Python</h3>
         <p>For complex calculations, the <code>uncertainties</code>
         package automatically tracks error propagation:</p>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define values with uncertainties</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> ufloat(<span class="fl">5.0</span>, <span class="fl">0.1</span>)   <span class="co"># 5.0 ± 0.1 V</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> ufloat(<span class="fl">0.5</span>, <span class="fl">0.02</span>)  <span class="co"># 0.5 ± 0.02 A</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate - uncertainty propagates automatically</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">}</span><span class="ss">&quot;</span>)  <span class="co"># Shows value ± uncertainty</span></span></code></pre></div>
         <h2 data-number="8.2" id="fitting-your-beam-profile-data"><span
         class="header-section-number">8.2</span> Fitting Your Beam
         Profile Data</h2>
         <p>Now fit your beam profile data to extract the beam
         radius.</p>
         <h3 data-number="8.2.1"
         id="step-1-load-and-plot-your-data"><span
         class="header-section-number">8.2.1</span> Step 1: Load and
         Plot Your Data</h3>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> erf</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load your data</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;beam_profile_week3.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>position <span class="op">=</span> data[:, <span class="dv">0</span>]  <span class="co"># mm</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>voltage <span class="op">=</span> data[:, <span class="dv">1</span>]   <span class="co"># V</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot raw data</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.plot(position, voltage, <span class="st">&#39;bo&#39;</span>, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (mm)&#39;</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Beam Profile - Week 3&#39;</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="8.2.2"
         id="step-2-define-and-fit-the-error-function-model"><span
         class="header-section-number">8.2.2</span> Step 2: Define and
         Fit the Error Function Model</h3>
         <p>The knife-edge measurement gives an integrated Gaussian,
         which is the error function:</p>
         <p><span class="math display">\[V(x) = \frac{V_{max} -
         V_{min}}{2} \left[1 - \text{erf}\left(\frac{\sqrt{2}(x -
         x_0)}{w}\right)\right] + V_{min}\]</span></p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beam_profile(x, V_max, V_min, center, width):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Error function model for knife-edge beam profile.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">        x: position (mm)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">        V_max: maximum voltage when beam is unblocked (V)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">        V_min: minimum voltage when beam is blocked (V)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">        center: beam center position (mm)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">        width: beam radius w (mm)</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Note: This form uses V_max/V_min instead of amplitude/offset</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">    for physical clarity. The forms are equivalent:</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">        amplitude = (V_max - V_min) / 2</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co">        offset = (V_max + V_min) / 2</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (V_max <span class="op">-</span> V_min) <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> erf(np.sqrt(<span class="dv">2</span>) <span class="op">*</span> (x <span class="op">-</span> center) <span class="op">/</span> width)) <span class="op">+</span> V_min</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guesses</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>V_max_guess <span class="op">=</span> np.<span class="bu">max</span>(voltage)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>V_min_guess <span class="op">=</span> np.<span class="bu">min</span>(voltage)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>center_guess <span class="op">=</span> position[<span class="bu">len</span>(position)<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>width_guess <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># mm</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> [V_max_guess, V_min_guess, center_guess, width_guess]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit the data (bounds ensure width stays positive)</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>bounds <span class="op">=</span> ([<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span>np.inf, <span class="dv">0</span>], [np.inf, np.inf, np.inf, np.inf])</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>popt, pcov <span class="op">=</span> curve_fit(beam_profile, position, voltage, p0<span class="op">=</span>p0, bounds<span class="op">=</span>bounds)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>perr <span class="op">=</span> np.sqrt(np.diag(pcov))</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract results</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>V_max, V_min, center, width <span class="op">=</span> popt</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>V_max_err, V_min_err, center_err, width_err <span class="op">=</span> perr</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam radius: w = </span><span class="sc">{</span>width<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>width_err<span class="sc">:.4f}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Beam center: x0 = </span><span class="sc">{</span>center<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>center_err<span class="sc">:.4f}</span><span class="ss"> mm&quot;</span>)</span></code></pre></div>
         <p><strong>Troubleshooting fit issues:</strong></p>
         <ul>
         <li><strong>Fit doesn’t converge:</strong> Check that your
         initial guesses are reasonable. Try adjusting
         <code>width_guess</code> based on your data’s transition
         region.</li>
         <li><strong>Very large uncertainties:</strong> You may not have
         enough points in the transition region. Retake data with
         smaller step sizes.</li>
         <li><strong>Fit looks wrong:</strong> Plot your data first and
         verify it shows a clear S-curve transition. If the curve is
         inverted, check the sign in the error function model.</li>
         </ul>
         <h3 data-number="8.2.3" id="step-3-plot-the-fit"><span
         class="header-section-number">8.2.3</span> Step 3: Plot the
         Fit</h3>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate smooth curve for plotting</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>x_fit <span class="op">=</span> np.linspace(position.<span class="bu">min</span>(), position.<span class="bu">max</span>(), <span class="dv">200</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>v_fit <span class="op">=</span> beam_profile(x_fit, <span class="op">*</span>popt)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.plot(position, voltage, <span class="st">&#39;bo&#39;</span>, label<span class="op">=</span><span class="st">&#39;Data&#39;</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x_fit, v_fit, <span class="st">&#39;r-&#39;</span>, label<span class="op">=</span><span class="ss">f&#39;Fit: w = </span><span class="sc">{</span>width<span class="sc">:.3f}</span><span class="ss"> ± </span><span class="sc">{</span>width_err<span class="sc">:.3f}</span><span class="ss"> mm&#39;</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Position (mm)&#39;</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Beam Profile with Error Function Fit&#39;</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&#39;beam_profile_fit.png&#39;</span>, dpi<span class="op">=</span><span class="dv">150</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <p><strong>Record in your notebook:</strong></p>
         <ul>
         <li>Beam radius: $w = $ _______ <span
         class="math inline">\(\pm\)</span> _______ mm</li>
         <li>Measurement position: $z = $ _______ m from laser</li>
         </ul>
         <p><strong>Connection to Week 2:</strong> The uncertainty in
         your fit parameters depends on the noise level in your voltage
         measurements. Your Week 2 noise characterization tells you what
         σ_V to expect at your gain setting. Look at the residuals (data
         minus fit)—does their scatter match your predicted noise level?
         If the residuals are much larger than expected, you may have
         additional noise sources (vibration, beam drift) affecting your
         measurement.</p>
         <h2 data-number="8.3" id="predicting-week-4-results"><span
         class="header-section-number">8.3</span> Predicting Week 4
         Results</h2>
         <p>Now use your measured beam radius to make predictions for
         Week 4. This is where error propagation becomes practical.</p>
         <h3 data-number="8.3.1"
         id="step-1-estimate-beam-waist-from-your-measurement"><span
         class="header-section-number">8.3.1</span> Step 1: Estimate
         Beam Waist from Your Measurement</h3>
         <p>Using the Gaussian beam equation:</p>
         <p><span class="math display">\[w(z) =
         w_0\sqrt{1+\left(\frac{\lambda (z - z_w)}{\pi
         w_0^2}\right)^2}\]</span></p>
         <p>If we assume <span class="math inline">\(z_w \approx
         0\)</span> (beam waist at laser output), we can estimate <span
         class="math inline">\(w_0\)</span> from a single measurement.
         Rearranging:</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Your measured values (replace with your actual data)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>w_measured <span class="op">=</span> ufloat(<span class="fl">0.52</span>, <span class="fl">0.03</span>)  <span class="co"># mm - USE YOUR VALUE</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>z_measured <span class="op">=</span> ufloat(<span class="fl">1.5</span>, <span class="fl">0.01</span>)   <span class="co"># m - USE YOUR VALUE</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>wavelength <span class="op">=</span> <span class="fl">632.8e-9</span>  <span class="co"># m (He-Ne laser)</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert w to meters</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>w_m <span class="op">=</span> w_measured <span class="op">*</span> <span class="fl">1e-3</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co"># For a beam at distance z from waist, we can estimate w0</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># This is approximate - assumes z &gt;&gt; z_R (far from waist)</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># w ≈ w0 * z * λ / (π * w0²) = z * λ / (π * w0)</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co"># So w0 ≈ z * λ / (π * w)</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>w0_approx <span class="op">=</span> z_measured <span class="op">*</span> wavelength <span class="op">/</span> (np.pi <span class="op">*</span> w_m)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Approximate beam waist: w0 ≈ </span><span class="sc">{</span>w0_approx<span class="op">*</span><span class="fl">1e6</span><span class="sc">:.1f}</span><span class="ss"> μm&quot;</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if far-field approximation is valid (z &gt;&gt; z_R)</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>z_R_approx <span class="op">=</span> np.pi <span class="op">*</span> w0_approx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> wavelength</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Estimated Rayleigh range: z_R ≈ </span><span class="sc">{</span>z_R_approx<span class="sc">:.2f}</span><span class="ss"> m&quot;</span>)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;z / z_R = </span><span class="sc">{</span>z_measured<span class="sc">.</span>n <span class="op">/</span> z_R_approx<span class="sc">.</span>n<span class="sc">:.1f}</span><span class="ss"> (should be &gt;&gt; 1 for far-field)&quot;</span>)</span></code></pre></div>
         <p><strong>Note:</strong> If z/z_R is close to 1, you are
         <em>not</em> in the far field and this approximation may be
         inaccurate. This is expected—Week 4’s multi-position
         measurements and proper fitting will give a more reliable
         estimate of <span class="math inline">\(w_0\)</span>.</p>
         <h3 data-number="8.3.2"
         id="step-2-predict-beam-radii-at-other-positions"><span
         class="header-section-number">8.3.2</span> Step 2: Predict Beam
         Radii at Other Positions</h3>
         <p>Use error propagation to predict what you’ll measure in Week
         4:</p>
         <div class="sourceCode" id="cb12"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict beam radius at different positions</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>positions <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>, <span class="fl">2.0</span>]  <span class="co"># meters</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Predicted beam radii for Week 4:&quot;</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;-&quot;</span> <span class="op">*</span> <span class="dv">40</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> z <span class="kw">in</span> positions:</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    z_val <span class="op">=</span> ufloat(z, <span class="fl">0.01</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    z_R <span class="op">=</span> np.pi <span class="op">*</span> w0_approx<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> wavelength</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    w_pred <span class="op">=</span> w0_approx <span class="op">*</span> sqrt(<span class="dv">1</span> <span class="op">+</span> (z_val <span class="op">/</span> z_R)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;z = </span><span class="sc">{</span>z<span class="sc">:.1f}</span><span class="ss"> m:  w = </span><span class="sc">{</span>w_pred<span class="op">*</span><span class="fl">1e3</span><span class="sc">:.3f}</span><span class="ss"> mm&quot;</span>)</span></code></pre></div>
         <h3 data-number="8.3.3"
         id="step-3-record-your-predictions"><span
         class="header-section-number">8.3.3</span> Step 3: Record Your
         Predictions</h3>
         <p>Fill in this table in your notebook:</p>
         <table>
         <thead>
         <tr class="header">
         <th>Position <span class="math inline">\(z\)</span></th>
         <th>Predicted <span class="math inline">\(w(z)\)</span></th>
         <th>Predicted uncertainty</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>0.5 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="even">
         <td>1.0 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="odd">
         <td>1.5 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         <tr class="even">
         <td>2.0 m</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         </tr>
         </tbody>
         </table>
         <p><strong>Prediction reflection:</strong> If your Week 4
         measurements differ significantly from these predictions, what
         are the most likely causes? List at least two possibilities,
         and for each one, describe what signature in your Week 4 data
         would distinguish that cause from the others. (For example:
         Would the discrepancy be systematic across all positions? Would
         it affect near-field and far-field measurements
         differently?)</p>
         <h2 data-number="8.4"
         id="comparing-manual-vs.-motor-controlled-measurements"><span
         class="header-section-number">8.4</span> Comparing Manual
         vs. Motor-Controlled Measurements</h2>
         <p>If you took beam radius measurements manually in Week 1,
         compare them to today’s motor-controlled measurement:</p>
         <table>
         <thead>
         <tr class="header">
         <th>Method</th>
         <th>Beam radius</th>
         <th>Uncertainty</th>
         <th>Notes</th>
         </tr>
         </thead>
         <tbody>
         <tr class="odd">
         <td>Week 1 (manual)</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         <td></td>
         </tr>
         <tr class="even">
         <td>Week 3 (motor)</td>
         <td>_______ mm</td>
         <td>± _______ mm</td>
         <td></td>
         </tr>
         </tbody>
         </table>
         <p>Are they consistent within uncertainties? If not, what might
         explain the difference?</p>
         <h1 data-number="9" id="deliverables-and-assessment"><span
         class="header-section-number">9</span> Deliverables and
         Assessment</h1>
         <p>Your lab notebook should include the following for this
         week:</p>
         <h2 data-number="9.1"
         id="prelab-complete-before-lab-75-min"><span
         class="header-section-number">9.1</span> Prelab (complete
         before lab, ~75 min)</h2>
         <ol type="1">
         <li><strong>Paraxial wave equation derivation</strong>: show
         the key steps from Maxwell’s equations to Equation 7</li>
         <li><strong>Physical Intuition Check</strong>: answers to all 5
         questions</li>
         <li><strong>Gaussian beam model questions</strong>: answers to
         questions 1-4 in “Trying out the Gaussian beam model”</li>
         <li><strong>Beyond Beam Radius reflection</strong>: when might
         you need to measure <span class="math inline">\(R(z)\)</span>
         or <span class="math inline">\(\zeta(z)\)</span> directly?</li>
         </ol>
         <h2 data-number="9.2" id="in-lab-documentation"><span
         class="header-section-number">9.2</span> In-Lab
         Documentation</h2>
         <h3 data-number="9.2.1" id="phase-2-measurement-60-min"><span
         class="header-section-number">9.2.1</span> Phase 2: Measurement
         (~60 min)</h3>
         <ol type="1">
         <li><strong>Motor controller verification</strong>:
         <ul>
         <li>Completed setup checklist (DAQ, motor connection, movement
         test)</li>
         <li>Motor serial number recorded</li>
         <li>Troubleshooting reflection</li>
         </ul></li>
         <li><strong>Beam profile data</strong>:
         <ul>
         <li>Raw data file saved</li>
         <li>Position of measurement from laser: $z = $ _______ m</li>
         <li>Quick check: does data show clean transition?</li>
         </ul></li>
         </ol>
         <h3 data-number="9.2.2" id="phase-3-analysis-60-min"><span
         class="header-section-number">9.2.2</span> Phase 3: Analysis
         (~60 min)</h3>
         <ol start="3" type="1">
         <li><strong>Beam profile fit</strong>:
         <ul>
         <li>Fit plot showing data and error function model</li>
         <li>Extracted beam radius: $w = $ _______ <span
         class="math inline">\(\pm\)</span> _______ mm</li>
         </ul></li>
         <li><strong>Error propagation and predictions</strong>:
         <ul>
         <li>Estimated beam waist <span
         class="math inline">\(w_0\)</span></li>
         <li>Predicted beam radii at 4 positions for Week 4</li>
         <li>Prediction reflection (what could cause disagreement?)</li>
         </ul></li>
         <li><strong>Comparison</strong> (if Week 1 data available):
         <ul>
         <li>Manual vs. motor-controlled beam radius comparison</li>
         </ul></li>
         </ol>
         <h2 data-number="9.3" id="code-deliverables"><span
         class="header-section-number">9.3</span> Code Deliverables</h2>
         <ol type="1">
         <li>Motor communication test script</li>
         <li>Beam profile fitting script</li>
         </ol>
         <h2 data-number="9.4" id="reflection-questions"><span
         class="header-section-number">9.4</span> Reflection
         Questions</h2>
         <ol type="1">
         <li><p>What was the dominant source of uncertainty in your beam
         radius measurement? How could you reduce it?</p></li>
         <li><p>Based on your motor controller setup experience, what
         was the most challenging part? How would you help a classmate
         who encountered the same issue?</p></li>
         <li><p>Look at your predicted beam radii for Week 4. Which
         measurement position will have the largest <em>relative</em>
         uncertainty (σ_w / w)? Why?</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
