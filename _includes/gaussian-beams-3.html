<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 3</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#overview"><span
            class="toc-section-number">1</span> Overview</a></li>
            <li><a href="#goals"><span
            class="toc-section-number">2</span> Goals</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">3</span> Prelab</a>
            <ul>
            <li><a
            href="#error-propagation---from-measured-to-derived-quantities"><span
            class="toc-section-number">3.1</span> Error propagation -
            from measured to derived quantities</a></li>
            <li><a href="#error-propagation-in-python"><span
            class="toc-section-number">3.2</span> Error propagation in
            Python</a>
            <ul>
            <li><a href="#approach-1-manual-calculation"><span
            class="toc-section-number">3.2.1</span> Approach 1: Manual
            calculation</a></li>
            <li><a
            href="#approach-2-using-the-uncertainties-package"><span
            class="toc-section-number">3.2.2</span> Approach 2: Using
            the <code>uncertainties</code> package</a></li>
            <li><a href="#exercise-beam-width-uncertainty"><span
            class="toc-section-number">3.2.3</span> Exercise: Beam width
            uncertainty</a></li>
            </ul></li>
            <li><a href="#gaussian-beam-theory"><span
            class="toc-section-number">3.3</span> Gaussian beam
            theory</a></li>
            <li><a href="#sec:wave-eqn"><span
            class="toc-section-number">3.4</span> Paraxial wave
            equation</a></li>
            <li><a href="#trying-out-the-gaussian-beam-model"><span
            class="toc-section-number">3.5</span> Trying out the
            Gaussian beam model</a></li>
            </ul></li>
            <li><a href="#digital-sampling-of-data"><span
            class="toc-section-number">4</span> Digital Sampling of
            Data</a>
            <ul>
            <li><a
            href="#improving-your-python-data-acquisition-script"><span
            class="toc-section-number">4.1</span> Improving your Python
            data acquisition script</a></li>
            <li><a href="#initial-measurements"><span
            class="toc-section-number">4.2</span> Initial
            measurements</a></li>
            <li><a href="#enhanced-understanding"><span
            class="toc-section-number">4.3</span> Enhanced
            understanding</a></li>
            <li><a href="#nyquist-frequency"><span
            class="toc-section-number">4.4</span> Nyquist
            frequency</a></li>
            </ul></li>
            <li><a href="#fourier-analysis-techniques"><span
            class="toc-section-number">5</span> Fourier Analysis
            Techniques</a>
            <ul>
            <li><a href="#fourier-transforms"><span
            class="toc-section-number">5.1</span> Fourier Transforms</a>
            <ul>
            <li><a href="#sec:basic-fourier"><span
            class="toc-section-number">5.1.1</span> Basic Fourier
            concepts</a></li>
            </ul></li>
            <li><a
            href="#adding-spectral-analysis-to-your-python-script"><span
            class="toc-section-number">5.2</span> Adding Spectral
            Analysis to Your Python Script</a>
            <ul>
            <li><a href="#computing-the-power-spectrum"><span
            class="toc-section-number">5.2.1</span> Computing the Power
            Spectrum</a></li>
            <li><a href="#setting-up-real-time-spectral-analysis"><span
            class="toc-section-number">5.2.2</span> Setting up real-time
            spectral analysis</a></li>
            </ul></li>
            <li><a href="#using-your-spectral-analysis-script"><span
            class="toc-section-number">5.3</span> Using your spectral
            analysis script</a>
            <ul>
            <li><a href="#spectral-analysis-basics"><span
            class="toc-section-number">5.3.1</span> Spectral analysis
            basics</a></li>
            <li><a
            href="#real-time-spectral-analysis-of-different-waveforms"><span
            class="toc-section-number">5.3.2</span> Real-time spectral
            analysis of different waveforms</a></li>
            </ul></li>
            <li><a href="#fourier-analysis-of-saved-data"><span
            class="toc-section-number">5.4</span> Fourier Analysis of
            Saved Data</a>
            <ul>
            <li><a href="#exercises"><span
            class="toc-section-number">5.4.1</span> Exercises</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#revisit-measuring-the-beam-width"><span
            class="toc-section-number">6</span> Revisit Measuring the
            Beam Width</a></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="overview"><span
         class="header-section-number">1</span> Overview</h1>
         <p>The third week of the Gaussian Beams lab builds upon the
         Python data acquisition skills you developed last week. This
         week’s prelab covers error propagation (how uncertainties in
         measured quantities affect derived quantities) and introduces
         the theoretical foundation for Gaussian laser beams, deriving
         the equations you’ll use in Week 4’s experiments. In the lab
         portion, we will focus on understanding digital sampling and
         using spectral analysis tools to perform Fourier Transforms in
         real time. This will allow you to quickly vary parameters and
         observe how they affect the frequency spectrum. Be sure to
         document all of your work in your lab notebook.</p>
         <h1 data-number="2" id="goals"><span
         class="header-section-number">2</span> Goals</h1>
         <p>In this week’s prelab, you will…</p>
         <ol type="1">
         <li>…learn to propagate uncertainties from measured to derived
         quantities.</li>
         <li>…derive the paraxial wave equation from Maxwell’s
         equations.</li>
         <li>…understand the Gaussian beam solution and its key
         parameters (<span class="math inline">\(w_0\)</span>, <span
         class="math inline">\(w(z)\)</span>, <span
         class="math inline">\(R(z)\)</span>, <span
         class="math inline">\(\zeta(z)\)</span>).</li>
         <li>…fit Gaussian beam data to extract beam waist and
         position.</li>
         </ol>
         <p>In the first part of this week’s lab, you will…</p>
         <ol type="1">
         <li>…extend your previously developed Python script to add
         functionality.</li>
         <li>…be able to appropriately choose DAQ parameters like sample
         rate.</li>
         <li>…explain what the DAQ measures when the sample rate is
         chosen differently.</li>
         </ol>
         <p>The primary objectives of the second part of this week’s lab
         are to gain a conceptual and computational knowledge of Fourier
         Transforms. Python’s NumPy library provides efficient FFT (Fast
         Fourier Transform) functions for spectral analysis. This lab
         focuses on methods commonly used in research.</p>
         <p>You will gain an understanding of Fourier Transforms by…</p>
         <ol type="1">
         <li>…connecting mathematical formalism to basic concepts of
         Fourier Transforms.</li>
         <li>…adding spectral analysis to your Python script to compute
         Fourier Transforms in real time.</li>
         <li>…computing Fourier Transforms using NumPy’s FFT
         functions.</li>
         </ol>
         <h1 data-number="3" id="prelab"><span
         class="header-section-number">3</span> Prelab</h1>
         <p>This week’s prelab covers two topics: error propagation and
         the theoretical foundation for Gaussian laser beams.</p>
         <h2 data-number="3.1"
         id="error-propagation---from-measured-to-derived-quantities"><span
         class="header-section-number">3.1</span> Error propagation -
         from measured to derived quantities</h2>
         <p>The quantity of interest in an experiment is often derived
         from other measured quantities. An example is estimating the
         resistance of a circuit element from measurements of current
         and voltage, using Ohm’s law (<span
         class="math inline">\(R=V/I\)</span>) to convert our measured
         quantities (voltage and current) into a derived quantity
         (resistance).</p>
         <p>Error propagation comes in when we want to estimate the
         uncertainty in the derived quantity based on the uncertainties
         in the measured quantities. Keeping things general, suppose we
         want to derive a quantity <span
         class="math inline">\(z\)</span> from a set of measured
         quantities <span class="math inline">\(a,b,c, \ ... \
         \)</span>. The mathematical function which gives us <span
         class="math inline">\(z\)</span> is <span
         class="math inline">\(z=z(a,b,c, \ ... \ )\)</span>. In
         general, any fluctuation in the measured quantities <span
         class="math inline">\(a,b,c, \ ... \ \)</span> will cause a
         fluctuation in <span class="math inline">\(z\)</span> according
         to</p>
         <p><span class="math display">\[\delta z = \left(
         \frac{\partial z}{\partial a}\right)\delta a+\left(
         \frac{\partial z}{\partial b}\right)\delta b+\left(
         \frac{\partial z}{\partial c}\right)\delta c+ \
         ...\text{.}\quad\quad\]</span></p>
         <p>This equation comes straight from basic calculus. It’s like
         the first term in a Taylor series. It’s the linear
         approximation of <span class="math inline">\(z(a,b,c, \ ... \
         )\)</span> near <span class="math inline">\((a_0,b_0,c_0, \ ...
         \ )\)</span>. However, we don’t know the exact magnitude or
         sign of the fluctuations, rather we just can estimate the
         spread in <span class="math inline">\(\delta a, \delta b,
         \delta c, \ ... \ \)</span>, which we often use the standard
         deviations <span class="math inline">\(\sigma_a, \sigma_b,
         \sigma_c, \ ... \ \)</span> In this case, the propagated
         uncertainty in <span class="math inline">\(z\)</span> is:</p>
         <p><span class="math display">\[\sigma_z^2 = \left(
         \frac{\partial z}{\partial a}\right)^2\sigma_a^2+\left(
         \frac{\partial z}{\partial b}\right)^2\sigma_b^2+\left(
         \frac{\partial z}{\partial c}\right)^2\sigma_c^2+ \
         ...\text{.}\quad\quad\]</span></p>
         <p>There are standard equations provided in courses like the
         introductory physics lab for the error in the sum, difference,
         product, quotient. These are all easily derived from this
         general formula.</p>
         <h2 data-number="3.2" id="error-propagation-in-python"><span
         class="header-section-number">3.2</span> Error propagation in
         Python</h2>
         <p>There are two main approaches to error propagation in
         Python:</p>
         <h3 data-number="3.2.1"
         id="approach-1-manual-calculation"><span
         class="header-section-number">3.2.1</span> Approach 1: Manual
         calculation</h3>
         <p>For simple cases, you can compute partial derivatives
         manually:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: R = V / I</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Measured values and uncertainties</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="fl">5.0</span>      <span class="co"># Voltage (V)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>sigma_V <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># Uncertainty in V</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> <span class="fl">0.5</span>      <span class="co"># Current (A)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>sigma_I <span class="op">=</span> <span class="fl">0.02</span>  <span class="co"># Uncertainty in I</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate resistance</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Partial derivatives</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>dR_dV <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> I</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>dR_dI <span class="op">=</span> <span class="op">-</span>V <span class="op">/</span> I<span class="op">**</span><span class="dv">2</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Propagated uncertainty</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>sigma_R <span class="op">=</span> np.sqrt((dR_dV <span class="op">*</span> sigma_V)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (dR_dI <span class="op">*</span> sigma_I)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">:.2f}</span><span class="ss"> ± </span><span class="sc">{</span>sigma_R<span class="sc">:.2f}</span><span class="ss"> Ω&quot;</span>)</span></code></pre></div>
         <h3 data-number="3.2.2"
         id="approach-2-using-the-uncertainties-package"><span
         class="header-section-number">3.2.2</span> Approach 2: Using
         the <code>uncertainties</code> package</h3>
         <p>For more complex calculations, the
         <code>uncertainties</code> package automatically tracks error
         propagation:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt  <span class="co"># Use umath for math functions</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define values with uncertainties</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> ufloat(<span class="fl">5.0</span>, <span class="fl">0.1</span>)   <span class="co"># 5.0 ± 0.1 V</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> ufloat(<span class="fl">0.5</span>, <span class="fl">0.02</span>)  <span class="co"># 0.5 ± 0.02 A</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate - uncertainty propagates automatically</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">}</span><span class="ss">&quot;</span>)  <span class="co"># Shows value ± uncertainty</span></span></code></pre></div>
         <h3 data-number="3.2.3"
         id="exercise-beam-width-uncertainty"><span
         class="header-section-number">3.2.3</span> Exercise: Beam width
         uncertainty</h3>
         <p>Later in this prelab, we will model a Gaussian beam’s width
         <span class="math inline">\(w(z)\)</span> as:</p>
         <p><span class="math display">\[w(z) =
         w_0\sqrt{1+\left(\frac{z-z_0}{\pi
         w_0^2/\lambda}\right)^2}\text{.}\]</span></p>
         <p>For the output beam of one of the lasers in the lab, a fit
         of beam width versus position gave the following fit
         parameters:</p>
         <p><span class="math display">\[z_0 = -0.03 \pm 0.04 \
         m\]</span></p>
         <p><span class="math display">\[w_0=(1.90 \pm 0.09)\times
         10^{-6} \ m\]</span></p>
         <p>The wavelength is given by <span
         class="math inline">\(\lambda = 632.8 \pm 0.1 \
         nm\)</span>.</p>
         <ol type="1">
         <li><p>Use Python to estimate the uncertainty in the derived
         width <span class="math inline">\(w(z)\)</span> when <span
         class="math inline">\(z\)</span> is a distance of <span
         class="math inline">\(2.000 \pm 0.005 \ m\)</span> from the
         waist position.</p>
         <p>Using the <code>uncertainties</code> package:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define parameters with uncertainties</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>z0 <span class="op">=</span> ufloat(<span class="op">-</span><span class="fl">0.03</span>, <span class="fl">0.04</span>)           <span class="co"># m</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>w0 <span class="op">=</span> ufloat(<span class="fl">1.90e-6</span>, <span class="fl">0.09e-6</span>)      <span class="co"># m</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>wavelength <span class="op">=</span> ufloat(<span class="fl">632.8e-9</span>, <span class="fl">0.1e-9</span>)  <span class="co"># m</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> ufloat(<span class="fl">2.000</span>, <span class="fl">0.005</span>)           <span class="co"># m</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate beam width</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>z_R <span class="op">=</span> np.pi <span class="op">*</span> w0<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> wavelength  <span class="co"># Rayleigh range</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> w0 <span class="op">*</span> sqrt(<span class="dv">1</span> <span class="op">+</span> ((z <span class="op">-</span> z0) <span class="op">/</span> z_R)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;w(z) = </span><span class="sc">{</span>w<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="3.3" id="gaussian-beam-theory"><span
         class="header-section-number">3.3</span> Gaussian beam
         theory</h2>
         <p>Light is a propagating oscillation of the electromagnetic
         field. The general principles which govern electromagnetic
         waves are Maxwell’s equations. From these general relations, a
         vector wave equation can be derived.</p>
         <p><span id="eq:1" class="eqnos"><span class="math display">\[
         \nabla^2\vec{E}=\mu_0\epsilon_0
         \frac{\partial^2\vec{E}}{\partial
         t^2}\text{.}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>One of the simplest solutions is that of a plane wave
         propagating in the <span class="math inline">\(\hat{z}\)</span>
         direction:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=E_x\hat{x}cos(kz-\omega
         t+\phi_x)+E_y\hat{y}cos(kz-\omega
         t+\phi_y)\text{.}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>But as the measurements from the first week showed, our
         laser beams are commonly well approximated by a beam shape with
         a Gaussian intensity profile. Apparently, since these Gaussian
         profile beams exist, they must be solutions of the wave
         equation. The next section will discuss how we derive the
         Gaussian beam electric field, and give a few key results.</p>
         <h2 data-number="3.4" id="sec:wave-eqn"><span
         class="header-section-number">3.4</span> Paraxial wave
         equation</h2>
         <p>One important thing to note about the beam output from most
         lasers is that the width of the beam changes very slowly
         compared to the wavelength of light. Assume a complex solution,
         where the beam is propagating in the <span
         class="math inline">\(\hat{z}\)</span>-direction, with the
         electric field polarization in the <span
         class="math inline">\(\hat{x}\)</span>-direction:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=\hat{x}A(x,y,z)e^{kz-\omega
         t}\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The basic idea is that the spatial pattern of the beam,
         described by the function <span
         class="math inline">\(A(x,y,z)\)</span>, does not change much
         over a wavelength. In the case of the He-Ne laser output, the
         function <span class="math inline">\(A(x,y,z)\)</span> is a
         Gaussian profile that changes its width as a function of <span
         class="math inline">\(z\)</span>. If we substitute the trial
         solution in Equation <a href="#eq:3">3</a> into the wave
         equation in Equation <a href="#eq:1">1</a> we get</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\hat{x} \left[
         \left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial z} - k^2A
         \right]e^{i(kz-\omega
         t)}=\hat{x}\mu_0\epsilon_oA(-\omega^2)e^{i(kz-\omega
         t)}\text{.}\quad\quad\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>This can be simplified recognizing that <span
         class="math inline">\(k^2=\omega^2/c^2=\mu_0\epsilon_0\omega^2\)</span>,
         where the speed of light is related to the permeability and
         permittivity of free space by <span
         class="math inline">\(c=(\mu_0\epsilon_0)^{-1/2}\)</span>.
         Also, the <span class="math inline">\(\hat{x}e^{i(kz-\omega
         t)}\)</span> term is common to both sides and can be dropped,
         which results in</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial
         z}=0\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So far, we have made no approximation to the solution or the
         wave equation, but now we apply the assumption that <span
         class="math inline">\(\partial{A}(x,y,z)/\partial{z}\)</span>
         changes slowly over a wavelength <span
         class="math inline">\(\lambda = 2\pi /k\)</span>, so we neglect
         the term</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\left| \frac{\partial^2A}{\partial z^2}
         \right| \ll \left|2k\frac{\partial A}{\partial
         z}\right|\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <p>Finally, we get the paraxial wave equation,</p>
         <p><span id="eq:7" class="eqnos"><span
         class="math display">\[\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2}=0\text{.}\]</span><span class="eqnos-number">(7)</span></span>
         </p>
         <p>One set of solutions to the paraxial wave equation are
         Gauss-Hermite beams, which have an intensity profiles like
         those shown in Figure <a href="#fig:gauss-hermite">1</a>. These
         are the same solutions as for the quantum simple harmonic
         oscillator, a topic that could be further explored as a final
         project.</p>
         <p>The simplest of these solutions is the Gaussian beam, which
         has an electric field given by</p>
         <p><span id="eq:8" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t) =
         \vec{E}_0\frac{w_0}{w(z)}exp\left(-\frac{x^2+y^2}{w^2(z)}\right)exp\left(ik\frac{x^2+y^2}{2R(z)}\right)e^{-i\zeta(z)}e^{i(kz-\omega
         t)}\text{,}\quad\quad\]</span><span class="eqnos-number">(8)</span></span>
         </p>
         <p>where <span class="math inline">\(\vec{E_0}\)</span> is a
         time-independent vector (orthogonal to propagation direction
         <span class="math inline">\(\hat{z}\)</span>) whose magnitude
         denotes the amplitude of the laser’s electric field and the
         direction denotes the direction of polarization. The beam
         radius <span class="math inline">\(w(z)\)</span>is given by</p>
         <p><span id="eq:9" class="eqnos"><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi
         w_0^2}\right)^2}\text{.}\]</span><span class="eqnos-number">(9)</span></span>
         </p>
         <p><span class="math inline">\(R(z)\)</span>,the radius of
         curvature of the wavefront, is given by</p>
         <p><span id="eq:10" class="eqnos"><span
         class="math display">\[R(z)=z\left(1+\left(\frac{\pi
         w_0^2}{\lambda
         z}\right)^2\right)\text{,}\]</span><span class="eqnos-number">(10)</span></span>
         </p>
         <p>and the Gouy phase is given by</p>
         <p><span id="eq:11" class="eqnos"><span
         class="math display">\[\zeta(z)=arctan\frac{\pi w_0^2}{\lambda
         z}\text{.}\]</span><span class="eqnos-number">(11)</span></span>
         </p>
         <p>The remarkable thing about all these equations is that only
         two parameters need to be specified to give the whole beam
         profile: the wavelength <span
         class="math inline">\(\lambda\)</span> and the beam waist <span
         class="math inline">\(w_0\)</span>, which is the narrowest
         point in the beam profile. There is a more general set of
         Hermite Gaussian modes which are shown in Figure <a
         href="#fig:gauss-hermite">1</a>. The laser cavity typically
         produces the (0,0) mode shown in the upper left corner, but an
         optical cavity can also be used to create these other modes – a
         topic that can be explored in the final projects.</p>
         <div id="fig:gauss-hermite" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-hermite.png"
         style="width:20cm"
         alt="Figure 1: Intensity distributions for the lowest order Gauss-Hermite solutions to the paraxial wave equation. The axes are in units of the beam width, w." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Intensity
         distributions for the lowest order Gauss-Hermite solutions to
         the paraxial wave equation. The axes are in units of the beam
         width, <span class="math inline">\(w\)</span>.</figcaption>
         </figure>
         </div>
         <h2 data-number="3.5"
         id="trying-out-the-gaussian-beam-model"><span
         class="header-section-number">3.5</span> Trying out the
         Gaussian beam model</h2>
         <p>In the first week of the lab, we assumed the intensity
         profile of the Gaussian beam was given by <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>.
         The equation for the electric field of the Gaussian Beam in
         Equation <a href="#eq:8">8</a> looks substantially more
         complicated.</p>
         <ol type="1">
         <li>How are the expressions for electric field and intensity
         related?</li>
         <li>Is Equation <a href="#eq:8">8</a> consistent with the
         simple expression for intensity <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>?</li>
         </ol>
         <p>The Gaussian beam equations given in Equations <a
         href="#eq:8">8</a> -<a href="#eq:11">11</a> assume the beam
         comes to its narrowest width (called the beam waist, <span
         class="math inline">\(w_0\)</span>) at <span
         class="math inline">\(z=0\)</span>.</p>
         <ol start="3" type="1">
         <li>How would you rewrite these four equations assuming the
         beam waist occurs at a different position <span
         class="math inline">\(z=z_w\)</span>?</li>
         <li>One way to check your answer is to make sure the equations
         simplify to Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a> in the special case of <span
         class="math inline">\(z_w=0\)</span>.</li>
         <li>Write a Python function to fit <a
         href="../resources/lab-guides/gaussian-laser-beams/Test_beam_width_data.csv">this
         data set</a>. Assume the wavelength is <span
         class="math inline">\(\lambda=632.8\ nm\)</span>.
         <ol type="1">
         <li>What is the functional form for your fit function?</li>
         <li>What are the different fit parameters and what do they
         mean?</li>
         <li>Is it a linear or nonlinear fit function? Why?</li>
         </ol></li>
         <li>You should get that a beam waist of <span
         class="math inline">\(w_0=(93.9\pm0.1)\times10^{-6}\ m\)</span>
         and occurs at a position <span
         class="math inline">\(z_w=0.3396\pm0.0003\ m\)</span>.</li>
         </ol>
         <h1 data-number="4" id="digital-sampling-of-data"><span
         class="header-section-number">4</span> Digital Sampling of
         Data</h1>
         <h2 data-number="4.1"
         id="improving-your-python-data-acquisition-script"><span
         class="header-section-number">4.1</span> Improving your Python
         data acquisition script</h2>
         <ol type="1">
         <li><p>Modify the Python script you created last week so that
         the <em>Number of Samples</em> and <em>Sample Rate</em> are
         easily configurable variables at the top of your script (or as
         function parameters).</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration - easily adjustable</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>SAMPLE_RATE <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Samples per second</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>NUM_SAMPLES <span class="op">=</span> <span class="dv">500</span>     <span class="co"># Total samples (1 second of data)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>DAQ_CHANNEL <span class="op">=</span> <span class="st">&quot;Dev1/ai0&quot;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acquire_data(sample_rate, num_samples, channel):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Acquire data from DAQ with specified parameters.&quot;&quot;&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        task.ai_channels.add_ai_voltage_chan(channel)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        task.timing.cfg_samp_clk_timing(</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            rate<span class="op">=</span>sample_rate,</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            sample_mode<span class="op">=</span>AcquisitionType.FINITE,</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            samps_per_chan<span class="op">=</span>num_samples</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>num_samples)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(data)</span></code></pre></div></li>
         <li><p>Set up a function generator to produce a 1 kHz sine
         wave.</p></li>
         <li><p>Connect the function generator’s output to both the
         oscilloscope and the DAQ to record data.</p></li>
         </ol>
         <h2 data-number="4.2" id="initial-measurements"><span
         class="header-section-number">4.2</span> Initial
         measurements</h2>
         <ol type="1">
         <li><p>Set the sample rate in your Python script to 500 samples
         per second and the number of samples such that it records 1
         second of data.</p></li>
         <li><p>Record and plot a dataset with both the oscilloscope and
         the DAQ. Make sure that the time range on the oscilloscope is
         set such that it is on the same order as the data being
         recorded by the DAQ.</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Acquire and plot data</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> acquire_data(SAMPLE_RATE, NUM_SAMPLES, DAQ_CHANNEL)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.arange(NUM_SAMPLES) <span class="op">/</span> SAMPLE_RATE</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.plot(time, data)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Time (s)&#39;</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f&#39;Acquired Signal (</span><span class="sc">{</span>SAMPLE_RATE<span class="sc">}</span><span class="ss"> Hz sample rate)&#39;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Compare the two plots. What are the major differences
         between the two?</p></li>
         <li><p>Why might one or both of these plots be giving an
         incorrect result? Think about the wave you are measuring and
         the result you are getting. How do they relate?</p></li>
         </ol>
         <h2 data-number="4.3" id="enhanced-understanding"><span
         class="header-section-number">4.3</span> Enhanced
         understanding</h2>
         <p>This section will guide you to understanding of Nyquist’s
         theorem and a more appropriate sample rate for digital data
         collection.</p>
         <ol type="1">
         <li>Why do you think the data from the DAQ produced a wave of
         lower frequency?</li>
         <li>Adjust the sample rate in a way you think might provide a
         more accurate measurement of the wave. What do you think the
         measured waveform will look like this time?</li>
         <li>Take a dataset, record and plot it. Did it match your
         predictions?</li>
         <li>Now record another dataset with the function generator set
         to the same parameters but the sample rate set to 3000 samples
         per second and the number of samples set to record 1 second of
         data.</li>
         <li>Plot this new dataset. What is the frequency of the new
         dataset?</li>
         <li>What are the fundamental differences between the first,
         second, and third datasets?</li>
         </ol>
         <h2 data-number="4.4" id="nyquist-frequency"><span
         class="header-section-number">4.4</span> Nyquist frequency</h2>
         <p>The discrepancies between the sampled waveforms can be
         explained by Nyquist’s theorem. It states that to accurately
         measure a signal by discrete sampling methods (like the DAQ)
         the sampling rate must be at least twice that of the measured
         signal. If this were not the case, a measurement might not be
         taken at every interval of oscillation, a situation called
         “undersampling.” Sampling the signal at least twice as fast as
         the maximum frequency of interest ensures that at least two
         data points are recorded each period.</p>
         <p><strong>Definition:</strong></p>
         <p>The <em>Nyquist Frequency</em> is defined to be half the
         sample rate.</p>
         <ol type="1">
         <li><p><strong>Predict</strong> the <em>apparent</em> period
         (in Hz) of the signal recorded by the DAQ.
         <strong>Observe</strong> what really happens using your
         waveform generator, DAQ, and Python script.
         <strong>Explain</strong> the result. Suppose the DAQ is set to
         1 kS/s sample rate in all of the cases, while the waveform
         generator is set to:</p>
         <ol type="1">
         <li>1000 Hz</li>
         <li>998 Hz</li>
         <li>1004 Hz</li>
         <li>1500 Hz</li>
         <li>2000 Hz</li>
         <li>1997 Hz</li>
         <li>2005 Hz</li>
         </ol>
         <p>In understanding what is going on, it may help to draw a few
         periods of the wave and then indicate where the DAQ will sample
         the waveform.</p></li>
         <li><p>You <em>want</em> to measure the random fluctuations
         (noise) in a signal from 0-100 Hz.</p>
         <ol type="1">
         <li>If you set the sample rate at 200 Hz, what set of frequency
         ranges will contribute to the noise measurement?</li>
         <li>If you set the sample rate at 1000 Hz, what set of
         frequency ranges will contribute to the noise measurement?</li>
         <li>How could you help achieve the desired measurement in 2.1
         using a combination of changing the sample rate and adding
         filtering? Explain why your choice of sample rate and signal
         filter would work better.</li>
         </ol></li>
         <li><p><strong>Undersampling on the oscilloscope.</strong>
         Undersampling is an issue with any device that samples data at
         regular discrete time intervals. This question requires the use
         of a Rigol DS1052E oscilloscope and a waveform generator.</p>
         <ol type="1">
         <li>Figure <a href="#fig:scope-menu">2</a> is copied from the
         Rigol Oscilloscope manual. The Horizontal menu allows you to
         view the actual sample rate “Sa Rate” of the digital
         acquisition on the scope.</li>
         <li>Predict what should you observe if you set the waveform
         generator to the same frequency as the sample rate? Try it out,
         compare with your prediction, and explain your
         observations.</li>
         <li>What happens if you change the oscilloscope time scale? Or
         change the waveform generator frequency slightly? Try to
         explain what you observe.</li>
         </ol></li>
         </ol>
         <div id="fig:scope-menu" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/scope-menu.png"
         style="width:20cm"
         alt="Figure 2: The horizontal menu on the Rigol DS1052E Oscilloscope." />
         <figcaption aria-hidden="true"><span>Figure 2:</span> The
         horizontal menu on the Rigol DS1052E Oscilloscope.</figcaption>
         </figure>
         </div>
         <h1 data-number="5" id="fourier-analysis-techniques"><span
         class="header-section-number">5</span> Fourier Analysis
         Techniques</h1>
         <h2 data-number="5.1" id="fourier-transforms"><span
         class="header-section-number">5.1</span> Fourier
         Transforms</h2>
         <p>The discrete Fourier Transform of a set of data <span
         class="math inline">\(\{y_0,y_1, ... , y_{N-1}\}\)</span> is
         given by</p>
         <p><span class="math display">\[Y_m=\displaystyle
         \sum_{n=0}^{N-1}y_n\cdot e^{-2\pi i \frac{m}{N}n}\]</span></p>
         <p>The basic idea is that a Fourier Transform decomposes the
         data into a set of different frequency components, so the
         amplitude of <span class="math inline">\(Y_m\)</span> tells you
         how much of your signal was formed by an oscillation at the
         <span class="math inline">\(m\)</span>-th frequency.</p>
         <h3 data-number="5.1.1" id="sec:basic-fourier"><span
         class="header-section-number">5.1.1</span> Basic Fourier
         concepts</h3>
         <ol type="1">
         <li>How do the units of the Fourier Transform array <span
         class="math inline">\(Y_m\)</span> relate to the units of the
         data <span class="math inline">\(y_n\)</span>?</li>
         <li>Does the data <span class="math inline">\(y_n\)</span> have
         to be taken at equally spaced intervals?</li>
         <li>Is it possible for two different sets of data to have the
         same Fourier Transform?</li>
         <li>If data set has <span class="math inline">\(N\)</span>
         elements, how long is the discrete Fourier Transform?</li>
         </ol>
         <h2 data-number="5.2"
         id="adding-spectral-analysis-to-your-python-script"><span
         class="header-section-number">5.2</span> Adding Spectral
         Analysis to Your Python Script</h2>
         <p>Now we want to modify our Python script to provide real-time
         spectral analysis using NumPy’s FFT functions.</p>
         <h3 data-number="5.2.1" id="computing-the-power-spectrum"><span
         class="header-section-number">5.2.1</span> Computing the Power
         Spectrum</h3>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_spectrum(data, sample_rate):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the one-sided power spectrum of a signal.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        data: 1D array of signal values</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        sample_rate: Sample rate in Hz</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">        frequencies: Array of frequency values</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">        power: Power spectrum (magnitude squared)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(data)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute FFT</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    fft_result <span class="op">=</span> np.fft.fft(data)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get positive frequencies only (real signal has symmetric spectrum)</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)[:n_unique]</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.<span class="bu">abs</span>(frequencies)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Power spectrum (magnitude squared, normalized)</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> (np.<span class="bu">abs</span>(fft_result[:n_unique]) <span class="op">/</span> n) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    power[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">*=</span> <span class="dv">2</span>  <span class="co"># Double power for frequencies with both +/- components</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> frequencies, power</span></code></pre></div>
         <h3 data-number="5.2.2"
         id="setting-up-real-time-spectral-analysis"><span
         class="header-section-number">5.2.2</span> Setting up real-time
         spectral analysis</h3>
         <p>Create a script with the following functionality:</p>
         <ol type="1">
         <li>Takes N samples inside a loop (continuous acquisition)</li>
         <li>Has configurable sample rate and number of samples</li>
         <li>Performs spectral analysis on each acquired dataset</li>
         <li>Has keyboard interrupt (Ctrl+C) to stop</li>
         <li>Saves the last dataset after stopping</li>
         </ol>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>SAMPLE_RATE <span class="op">=</span> <span class="dv">10000</span>  <span class="co"># Hz</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>NUM_SAMPLES <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>DAQ_CHANNEL <span class="op">=</span> <span class="st">&quot;Dev1/ai0&quot;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_spectrum(data, sample_rate):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Compute one-sided power spectrum.&quot;&quot;&quot;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(data)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    fft_result <span class="op">=</span> np.fft.fft(data)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)[:n_unique])</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> (np.<span class="bu">abs</span>(fft_result[:n_unique]) <span class="op">/</span> n) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    power[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> frequencies, power</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up real-time plotting</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>plt.ion()</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Time domain plot</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>line1, <span class="op">=</span> ax1.plot([], [], <span class="st">&#39;b-&#39;</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">&#39;Time Domain&#39;</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Frequency domain plot</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>line2, <span class="op">=</span> ax2.plot([], [], <span class="st">&#39;r-&#39;</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">&#39;Power&#39;</span>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">&#39;Frequency Domain (Power Spectrum)&#39;</span>)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>ax2.set_xlim(<span class="dv">0</span>, SAMPLE_RATE <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>last_data <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(DAQ_CHANNEL)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    task.timing.cfg_samp_clk_timing(</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        rate<span class="op">=</span>SAMPLE_RATE,</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        sample_mode<span class="op">=</span>AcquisitionType.CONTINUOUS</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    task.start()</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Acquiring data... Press Ctrl+C to stop&quot;</span>)</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Acquire data</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>NUM_SAMPLES)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>            last_data <span class="op">=</span> np.array(data)</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update time domain plot</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>            time_ms <span class="op">=</span> np.arange(<span class="bu">len</span>(data)) <span class="op">/</span> SAMPLE_RATE <span class="op">*</span> <span class="dv">1000</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>            line1.set_data(time_ms, data)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>            ax1.set_xlim(<span class="dv">0</span>, time_ms[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>            ax1.set_ylim(np.<span class="bu">min</span>(data) <span class="op">-</span> <span class="fl">0.1</span>, np.<span class="bu">max</span>(data) <span class="op">+</span> <span class="fl">0.1</span>)</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update frequency domain plot</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>            frequencies, power <span class="op">=</span> compute_spectrum(np.array(data), SAMPLE_RATE)</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>            line2.set_data(frequencies, power)</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>            ax2.set_ylim(<span class="dv">0</span>, np.<span class="bu">max</span>(power) <span class="op">*</span> <span class="fl">1.1</span> <span class="op">+</span> <span class="fl">0.001</span>)</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>            plt.pause(<span class="fl">0.05</span>)</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Stopped by user&quot;</span>)</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>plt.ioff()</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Save last dataset</span></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> last_data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>    np.savetxt(<span class="st">&#39;last_acquisition.csv&#39;</span>,</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>               np.column_stack([np.arange(<span class="bu">len</span>(last_data))<span class="op">/</span>SAMPLE_RATE, last_data]),</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>               delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, header<span class="op">=</span><span class="st">&#39;Time (s), Voltage (V)&#39;</span>, comments<span class="op">=</span><span class="st">&#39;&#39;</span>)</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Last dataset saved to &#39;last_acquisition.csv&#39;&quot;</span>)</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h2 data-number="5.3"
         id="using-your-spectral-analysis-script"><span
         class="header-section-number">5.3</span> Using your spectral
         analysis script</h2>
         <p>This section will familiarize you with your script’s
         capabilities and help you understand how different parameters
         relate to the Fourier Transform.</p>
         <h3 data-number="5.3.1" id="spectral-analysis-basics"><span
         class="header-section-number">5.3.1</span> Spectral analysis
         basics</h3>
         <ol type="1">
         <li><p>Use a waveform generator to output a waveform of your
         choice at a frequency in the tens of Hz to kHz range and view
         the output on the oscilloscope and in your Python
         script.</p></li>
         <li><p>Look at the spectral analysis. How do the
         <strong>frequency resolution</strong> (frequency step size
         between data in the spectrum) and <strong>maximum
         frequency</strong> relate to the <strong>sample rate</strong>
         and <strong>number of samples</strong>? Try to find an
         algebraic relationship.</p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Frequency resolution and maximum frequency</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>freq_resolution <span class="op">=</span> sample_rate <span class="op">/</span> num_samples  <span class="co"># Hz per bin</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>max_frequency <span class="op">=</span> sample_rate <span class="op">/</span> <span class="dv">2</span>  <span class="co"># Nyquist frequency</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Frequency resolution: </span><span class="sc">{</span>freq_resolution<span class="sc">}</span><span class="ss"> Hz&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Maximum frequency: </span><span class="sc">{</span>max_frequency<span class="sc">}</span><span class="ss"> Hz&quot;</span>)</span></code></pre></div></li>
         <li><p>If the data is sampled for 2 seconds at 100 Hz sample
         rate, what frequency does the <span
         class="math inline">\(m\)</span>-th component of the Fourier
         Transform correspond to?</p></li>
         <li><p>How many points are shown in the spectral analysis plot?
         How does this compare to the number of points you expected in
         the Fourier transform (see Section <a
         href="#sec:basic-fourier">5.1.1</a>.4)? <strong>Note</strong>:
         The data acquired from the DAQ is always a sequence of real
         numbers <span class="math inline">\(\{y_n\}\)</span>. Under the
         condition that the signal is only real numbers, it can be
         proved that <span class="math inline">\(Y_m=Y_{N-M}^*\)</span>
         so <span class="math inline">\(|Y_M|=|Y_{N-m}|\)</span>,
         meaning the spectrum is symmetric about the <span
         class="math inline">\(N/2\)</span>-th data point, which
         corresponds to the Nyquist frequency. For this reason, we
         typically only plot the first half of the Fourier spectrum up
         to the Nyquist frequency.</p></li>
         </ol>
         <h3 data-number="5.3.2"
         id="real-time-spectral-analysis-of-different-waveforms"><span
         class="header-section-number">5.3.2</span> Real-time spectral
         analysis of different waveforms</h3>
         <ol type="1">
         <li>How do you expect the spectrum of a sine wave to look? How
         should it change as you vary the amplitude and frequency on the
         waveform generator? Try it.</li>
         <li>How do you expect the spectrum of a square wave to look?
         How should it change as you vary the amplitude and frequency on
         the waveform generator? Try it.</li>
         </ol>
         <p>(Hint: you can look up or calculate the Fourier Series of a
         square wave to see if the observed amplitudes agree with the
         mathematical prediction.)</p>
         <h2 data-number="5.4" id="fourier-analysis-of-saved-data"><span
         class="header-section-number">5.4</span> Fourier Analysis of
         Saved Data</h2>
         <p>While it is convenient to use real-time spectral analysis,
         sometimes you may want to analyze data after it is saved.
         Here’s how to compute the Fourier Transform of saved data:</p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load saved data</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;saved_waveform.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>signal <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine sample rate from time data</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (time[<span class="dv">1</span>] <span class="op">-</span> time[<span class="dv">0</span>])</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute FFT</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(signal)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>fft_result <span class="op">=</span> np.fft.fft(signal)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create frequency axis</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Get positive frequencies only</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>positive_mask <span class="op">=</span> frequencies <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>freq_positive <span class="op">=</span> frequencies[positive_mask]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.<span class="bu">abs</span>(fft_result[positive_mask]) <span class="op">/</span> n</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot spectrum</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>plt.plot(freq_positive, magnitude)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Magnitude&#39;</span>)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Fourier Transform of Saved Data&#39;</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="5.4.1" id="exercises"><span
         class="header-section-number">5.4.1</span> Exercises</h3>
         <ol type="1">
         <li><p>Import any saved data set of a periodic function saved
         from the DAQ or the oscilloscope.</p></li>
         <li><p>Use NumPy’s <code>fft</code> function to compute the
         discrete Fourier Transform of the signal.</p>
         <ol type="1">
         <li>Do you expect the FFT output to be real-valued or
         complex-valued?</li>
         </ol></li>
         <li><p>Plot the output of the FFT function. Since the output is
         complex-valued, plot <code>np.abs()</code> or
         <code>np.abs()**2</code>.</p>
         <ol type="1">
         <li>What is the x-axis range and step-size in the plot?</li>
         <li>What frequency range and step size should be displayed on
         the x-axis?</li>
         </ol></li>
         <li><p>Make sure to add the frequency column to create a proper
         plot of spectrum vs. frequency:</p>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Complete example</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(signal)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">10000</span>  <span class="co"># Adjust to your actual sample rate</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute FFT and frequencies</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>fft_result <span class="op">=</span> np.fft.fft(signal)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># One-sided spectrum (positive frequencies)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>n_half <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>freq_pos <span class="op">=</span> frequencies[:n_half]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.<span class="bu">abs</span>(fft_result[:n_half]) <span class="op">*</span> <span class="dv">2</span> <span class="op">/</span> n  <span class="co"># Normalize and account for one-sided</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>magnitude[<span class="dv">0</span>] <span class="op">/=</span> <span class="dv">2</span>  <span class="co"># DC component doesn&#39;t double</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>plt.plot(freq_pos, magnitude)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Magnitude&#39;</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, sample_rate<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Does the spectral analysis show the same spectrum at the
         same frequencies that you expect from the waveform generator
         settings?</p></li>
         <li><p>NumPy’s FFT uses specific conventions. You can check the
         documentation with:</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">help</span>(np.fft.fft)</span></code></pre></div>
         <p>The convention used is: <span class="math inline">\(Y_k =
         \sum_{n=0}^{N-1} y_n e^{-2\pi i k n / N}\)</span></p></li>
         </ol>
         <h1 data-number="6" id="revisit-measuring-the-beam-width"><span
         class="header-section-number">6</span> Revisit Measuring the
         Beam Width</h1>
         <p>Next week you will be implementing automation into measuring
         the beam width of He-Ne lasers. To be prepared for this
         endeavor, you now should go back and review (and complete) <a
         href="/PHYS-4430/lab-guides/gaussian-beams-1#measuring-the-beam-width">section
         7</a> from week 1.</p>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
