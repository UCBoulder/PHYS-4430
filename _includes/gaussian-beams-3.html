<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>PHYS 4430</title>
            
            <!-- pandoc-eqnos: equation style -->
            <style>
              .eqnos { display: inline-block; position: relative; width: 100%; }
              .eqnos br { display: none; }
              .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
            </style>
         </head>
   <body>
            <div>
         <style>
            .eqnos { display: inline-block; position: relative; width: 100%; }
            .eqnos br { display: none; }
            .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
         </style>
         <h1 class="title">Gaussian Beams - Week 3</h1>
                  <h1 class="title">Contents</h1>
        <nav id="TOC">
            <ul>
            <li><a href="#where-we-are-in-the-sequence"><span
            class="toc-section-number">1</span> Where We Are in the
            Sequence</a></li>
            <li><a href="#overview"><span
            class="toc-section-number">2</span> Overview</a></li>
            <li><a href="#learning-goals"><span
            class="toc-section-number">3</span> Learning Goals</a></li>
            <li><a href="#prelab"><span
            class="toc-section-number">4</span> Prelab</a>
            <ul>
            <li><a
            href="#error-propagation---from-measured-to-derived-quantities"><span
            class="toc-section-number">4.1</span> Error propagation -
            from measured to derived quantities</a></li>
            <li><a href="#error-propagation-in-python"><span
            class="toc-section-number">4.2</span> Error propagation in
            Python</a>
            <ul>
            <li><a href="#approach-1-manual-calculation"><span
            class="toc-section-number">4.2.1</span> Approach 1: Manual
            calculation</a></li>
            <li><a
            href="#approach-2-using-the-uncertainties-package"><span
            class="toc-section-number">4.2.2</span> Approach 2: Using
            the <code>uncertainties</code> package</a></li>
            <li><a href="#exercise-beam-width-uncertainty"><span
            class="toc-section-number">4.2.3</span> Exercise: Beam width
            uncertainty</a></li>
            </ul></li>
            <li><a href="#gaussian-beam-theory"><span
            class="toc-section-number">4.3</span> Gaussian beam
            theory</a></li>
            <li><a href="#sec:wave-eqn"><span
            class="toc-section-number">4.4</span> Paraxial wave
            equation</a></li>
            <li><a href="#trying-out-the-gaussian-beam-model"><span
            class="toc-section-number">4.5</span> Trying out the
            Gaussian beam model</a></li>
            </ul></li>
            <li><a href="#fourier-analysis-techniques"><span
            class="toc-section-number">5</span> Fourier Analysis
            Techniques</a>
            <ul>
            <li><a href="#introduction-to-fourier-transforms"><span
            class="toc-section-number">5.1</span> Introduction to
            Fourier Transforms</a>
            <ul>
            <li><a href="#sec:basic-fourier"><span
            class="toc-section-number">5.1.1</span> Basic Fourier
            Concepts</a></li>
            </ul></li>
            <li><a href="#computing-the-power-spectrum-in-python"><span
            class="toc-section-number">5.2</span> Computing the Power
            Spectrum in Python</a>
            <ul>
            <li><a
            href="#frequency-resolution-and-maximum-frequency"><span
            class="toc-section-number">5.2.1</span> Frequency Resolution
            and Maximum Frequency</a></li>
            </ul></li>
            <li><a href="#building-a-real-time-spectral-analyzer"><span
            class="toc-section-number">5.3</span> Building a Real-Time
            Spectral Analyzer</a></li>
            <li><a href="#exercises-spectral-analysis"><span
            class="toc-section-number">5.4</span> Exercises: Spectral
            Analysis</a>
            <ul>
            <li><a href="#understanding-frequency-resolution"><span
            class="toc-section-number">5.4.1</span> Understanding
            Frequency Resolution</a></li>
            <li><a href="#analyzing-different-waveforms"><span
            class="toc-section-number">5.4.2</span> Analyzing Different
            Waveforms</a></li>
            <li><a
            href="#connecting-fft-to-your-gaussian-beams-experiment"><span
            class="toc-section-number">5.4.3</span> Connecting FFT to
            Your Gaussian Beams Experiment</a></li>
            <li><a href="#analyzing-saved-data"><span
            class="toc-section-number">5.4.4</span> Analyzing Saved
            Data</a></li>
            <li><a href="#exercises-with-saved-data"><span
            class="toc-section-number">5.4.5</span> Exercises with Saved
            Data</a></li>
            </ul></li>
            </ul></li>
            <li><a href="#setting-up-the-motor-controller"><span
            class="toc-section-number">6</span> Setting Up the Motor
            Controller</a>
            <ul>
            <li><a href="#hardware-overview"><span
            class="toc-section-number">6.1</span> Hardware
            Overview</a></li>
            <li><a href="#software-prerequisites"><span
            class="toc-section-number">6.2</span> Software
            Prerequisites</a>
            <ul>
            <li><a href="#thorlabs-kinesis-sdk"><span
            class="toc-section-number">6.2.1</span> 1. Thorlabs Kinesis
            SDK</a></li>
            <li><a href="#python-packages"><span
            class="toc-section-number">6.2.2</span> 2. Python
            Packages</a></li>
            </ul></li>
            <li><a href="#verifying-the-motor-connection"><span
            class="toc-section-number">6.3</span> Verifying the Motor
            Connection</a>
            <ul>
            <li><a href="#test-that-windows-recognizes-the-device"><span
            class="toc-section-number">6.3.1</span> Test that Windows
            Recognizes the Device</a></li>
            <li><a href="#test-basic-motor-communication"><span
            class="toc-section-number">6.3.2</span> Test Basic Motor
            Communication</a></li>
            <li><a href="#test-motor-movement"><span
            class="toc-section-number">6.3.3</span> Test Motor
            Movement</a></li>
            </ul></li>
            <li><a href="#motor-controller-troubleshooting"><span
            class="toc-section-number">6.4</span> Motor Controller
            Troubleshooting</a></li>
            <li><a href="#exercise-verify-your-setup"><span
            class="toc-section-number">6.5</span> Exercise: Verify Your
            Setup</a></li>
            <li><a href="#troubleshooting-reflection"><span
            class="toc-section-number">6.6</span> Troubleshooting
            Reflection</a></li>
            </ul></li>
            <li><a href="#revisit-measuring-the-beam-width"><span
            class="toc-section-number">7</span> Revisit Measuring the
            Beam Width</a></li>
            <li><a href="#deliverables-and-assessment"><span
            class="toc-section-number">8</span> Deliverables and
            Assessment</a>
            <ul>
            <li><a href="#prelab-complete-before-lab"><span
            class="toc-section-number">8.1</span> Prelab (complete
            before lab)</a></li>
            <li><a href="#in-lab-documentation"><span
            class="toc-section-number">8.2</span> In-Lab
            Documentation</a></li>
            <li><a href="#code-deliverables"><span
            class="toc-section-number">8.3</span> Code
            Deliverables</a></li>
            <li><a href="#reflection-questions"><span
            class="toc-section-number">8.4</span> Reflection
            Questions</a></li>
            </ul></li>
            </ul>
        </nav>
        <hr/>
         <h1 data-number="1" id="where-we-are-in-the-sequence"><span
         class="header-section-number">1</span> Where We Are in the
         Sequence</h1>
         <p><strong>Week 3 of 4: Theory and Preparation for
         Automation</strong></p>
         <p>Last week you characterized your photodetector’s noise and
         chose an optimal gain setting. This week you’ll learn the
         theoretical foundation for Gaussian beams (which you’ll test
         next week), develop spectral analysis skills to understand
         noise sources, and set up the motor controller for automated
         measurements.</p>
         <p><strong>Last week:</strong> Learned DAQ programming,
         characterized noise, chose gain setting <strong>This
         week:</strong> Learn Gaussian beam theory → Analyze noise
         spectra → Set up motor controller <strong>Next week:</strong>
         Automated measurements → Test Gaussian beam model → Investigate
         lens effects</p>
         <h1 data-number="2" id="overview"><span
         class="header-section-number">2</span> Overview</h1>
         <p>The third week of the Gaussian Beams lab builds upon the
         Python data acquisition skills you developed last week. This
         week’s prelab covers error propagation (how uncertainties in
         measured quantities affect derived quantities) and introduces
         the theoretical foundation for Gaussian laser beams, deriving
         the equations you’ll use in Week 4’s experiments. In the lab
         portion, you will use spectral analysis tools to perform
         Fourier Transforms, set up the motor controller hardware for
         automated measurements, and revisit your beam width
         measurement. Be sure to document all of your work in your lab
         notebook.</p>
         <h1 data-number="3" id="learning-goals"><span
         class="header-section-number">3</span> Learning Goals</h1>
         <p>After completing the prelab, you will be able to:</p>
         <ol type="1">
         <li>Propagate uncertainties from measured quantities to derived
         quantities using partial derivatives.</li>
         <li>Derive the paraxial wave equation from Maxwell’s equations
         by applying the slowly-varying envelope approximation.</li>
         <li>Explain the physical meaning of Gaussian beam parameters
         (<span class="math inline">\(w_0\)</span>, <span
         class="math inline">\(w(z)\)</span>, <span
         class="math inline">\(R(z)\)</span>, <span
         class="math inline">\(\zeta(z)\)</span>) and how they relate to
         observable properties.</li>
         <li>Fit experimental beam width data to extract beam waist
         <span class="math inline">\(w_0\)</span> and waist position
         <span class="math inline">\(z_w\)</span> with
         uncertainties.</li>
         </ol>
         <p>After completing the lab, you will be able to:</p>
         <ol type="1">
         <li>Explain what a Fourier Transform reveals about a signal and
         interpret a power spectrum.</li>
         <li>Compute and plot the power spectrum of a measured signal
         using NumPy’s FFT functions.</li>
         <li>Identify frequency components in experimental data and
         relate them to physical sources.</li>
         <li>Set up and verify the motor controller for automated
         measurements.</li>
         <li>Measure beam width using the knife-edge technique and
         compare automated vs. manual methods.</li>
         </ol>
         <h1 data-number="4" id="prelab"><span
         class="header-section-number">4</span> Prelab</h1>
         <p>This week’s prelab covers two topics: error propagation and
         the theoretical foundation for Gaussian laser beams.</p>
         <h2 data-number="4.1"
         id="error-propagation---from-measured-to-derived-quantities"><span
         class="header-section-number">4.1</span> Error propagation -
         from measured to derived quantities</h2>
         <p>The quantity of interest in an experiment is often derived
         from other measured quantities. An example is estimating the
         resistance of a circuit element from measurements of current
         and voltage, using Ohm’s law (<span
         class="math inline">\(R=V/I\)</span>) to convert our measured
         quantities (voltage and current) into a derived quantity
         (resistance).</p>
         <p>Error propagation comes in when we want to estimate the
         uncertainty in the derived quantity based on the uncertainties
         in the measured quantities. Keeping things general, suppose we
         want to derive a quantity <span
         class="math inline">\(z\)</span> from a set of measured
         quantities <span class="math inline">\(a,b,c, \ ... \
         \)</span>. The mathematical function which gives us <span
         class="math inline">\(z\)</span> is <span
         class="math inline">\(z=z(a,b,c, \ ... \ )\)</span>. In
         general, any fluctuation in the measured quantities <span
         class="math inline">\(a,b,c, \ ... \ \)</span> will cause a
         fluctuation in <span class="math inline">\(z\)</span> according
         to</p>
         <p><span class="math display">\[\delta z = \left(
         \frac{\partial z}{\partial a}\right)\delta a+\left(
         \frac{\partial z}{\partial b}\right)\delta b+\left(
         \frac{\partial z}{\partial c}\right)\delta c+ \
         ...\text{.}\quad\quad\]</span></p>
         <p>This equation comes straight from basic calculus. It’s like
         the first term in a Taylor series. It’s the linear
         approximation of <span class="math inline">\(z(a,b,c, \ ... \
         )\)</span> near <span class="math inline">\((a_0,b_0,c_0, \ ...
         \ )\)</span>. However, we don’t know the exact magnitude or
         sign of the fluctuations, rather we just can estimate the
         spread in <span class="math inline">\(\delta a, \delta b,
         \delta c, \ ... \ \)</span>, which we often use the standard
         deviations <span class="math inline">\(\sigma_a, \sigma_b,
         \sigma_c, \ ... \ \)</span> In this case, the propagated
         uncertainty in <span class="math inline">\(z\)</span> is:</p>
         <p><span class="math display">\[\sigma_z^2 = \left(
         \frac{\partial z}{\partial a}\right)^2\sigma_a^2+\left(
         \frac{\partial z}{\partial b}\right)^2\sigma_b^2+\left(
         \frac{\partial z}{\partial c}\right)^2\sigma_c^2+ \
         ...\text{.}\quad\quad\]</span></p>
         <p>There are standard equations provided in courses like the
         introductory physics lab for the error in the sum, difference,
         product, quotient. These are all easily derived from this
         general formula.</p>
         <h2 data-number="4.2" id="error-propagation-in-python"><span
         class="header-section-number">4.2</span> Error propagation in
         Python</h2>
         <p>There are two main approaches to error propagation in
         Python:</p>
         <h3 data-number="4.2.1"
         id="approach-1-manual-calculation"><span
         class="header-section-number">4.2.1</span> Approach 1: Manual
         calculation</h3>
         <p>For simple cases, you can compute partial derivatives
         manually:</p>
         <div class="sourceCode" id="cb1"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: R = V / I</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Measured values and uncertainties</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="fl">5.0</span>      <span class="co"># Voltage (V)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>sigma_V <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># Uncertainty in V</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> <span class="fl">0.5</span>      <span class="co"># Current (A)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>sigma_I <span class="op">=</span> <span class="fl">0.02</span>  <span class="co"># Uncertainty in I</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate resistance</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Partial derivatives</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>dR_dV <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> I</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>dR_dI <span class="op">=</span> <span class="op">-</span>V <span class="op">/</span> I<span class="op">**</span><span class="dv">2</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Propagated uncertainty</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>sigma_R <span class="op">=</span> np.sqrt((dR_dV <span class="op">*</span> sigma_V)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (dR_dI <span class="op">*</span> sigma_I)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">:.2f}</span><span class="ss"> ± </span><span class="sc">{</span>sigma_R<span class="sc">:.2f}</span><span class="ss"> Ω&quot;</span>)</span></code></pre></div>
         <h3 data-number="4.2.2"
         id="approach-2-using-the-uncertainties-package"><span
         class="header-section-number">4.2.2</span> Approach 2: Using
         the <code>uncertainties</code> package</h3>
         <p>For more complex calculations, the
         <code>uncertainties</code> package automatically tracks error
         propagation:</p>
         <div class="sourceCode" id="cb2"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt  <span class="co"># Use umath for math functions</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define values with uncertainties</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> ufloat(<span class="fl">5.0</span>, <span class="fl">0.1</span>)   <span class="co"># 5.0 ± 0.1 V</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> ufloat(<span class="fl">0.5</span>, <span class="fl">0.02</span>)  <span class="co"># 0.5 ± 0.02 A</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate - uncertainty propagates automatically</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> V <span class="op">/</span> I</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;R = </span><span class="sc">{</span>R<span class="sc">}</span><span class="ss">&quot;</span>)  <span class="co"># Shows value ± uncertainty</span></span></code></pre></div>
         <h3 data-number="4.2.3"
         id="exercise-beam-width-uncertainty"><span
         class="header-section-number">4.2.3</span> Exercise: Beam width
         uncertainty</h3>
         <p>Later in this prelab, we will model a Gaussian beam’s width
         <span class="math inline">\(w(z)\)</span> as:</p>
         <p><span class="math display">\[w(z) =
         w_0\sqrt{1+\left(\frac{z-z_0}{\pi
         w_0^2/\lambda}\right)^2}\text{.}\]</span></p>
         <p>For the output beam of one of the lasers in the lab, a fit
         of beam width versus position gave the following fit
         parameters:</p>
         <p><span class="math display">\[z_0 = -0.03 \pm 0.04 \
         m\]</span></p>
         <p><span class="math display">\[w_0=(1.90 \pm 0.09)\times
         10^{-6} \ m\]</span></p>
         <p>The wavelength is given by <span
         class="math inline">\(\lambda = 632.8 \pm 0.1 \
         nm\)</span>.</p>
         <ol type="1">
         <li><p>Use Python to estimate the uncertainty in the derived
         width <span class="math inline">\(w(z)\)</span> when <span
         class="math inline">\(z\)</span> is a distance of <span
         class="math inline">\(2.000 \pm 0.005 \ m\)</span> from the
         waist position.</p>
         <p>Using the <code>uncertainties</code> package:</p>
         <div class="sourceCode" id="cb3"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties <span class="im">import</span> ufloat</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> uncertainties.umath <span class="im">import</span> sqrt</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define parameters with uncertainties</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>z0 <span class="op">=</span> ufloat(<span class="op">-</span><span class="fl">0.03</span>, <span class="fl">0.04</span>)           <span class="co"># m</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>w0 <span class="op">=</span> ufloat(<span class="fl">1.90e-6</span>, <span class="fl">0.09e-6</span>)      <span class="co"># m</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>wavelength <span class="op">=</span> ufloat(<span class="fl">632.8e-9</span>, <span class="fl">0.1e-9</span>)  <span class="co"># m</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> ufloat(<span class="fl">2.000</span>, <span class="fl">0.005</span>)           <span class="co"># m</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate beam width</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>z_R <span class="op">=</span> np.pi <span class="op">*</span> w0<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> wavelength  <span class="co"># Rayleigh range</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> w0 <span class="op">*</span> sqrt(<span class="dv">1</span> <span class="op">+</span> ((z <span class="op">-</span> z0) <span class="op">/</span> z_R)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;w(z) = </span><span class="sc">{</span>w<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div></li>
         </ol>
         <h2 data-number="4.3" id="gaussian-beam-theory"><span
         class="header-section-number">4.3</span> Gaussian beam
         theory</h2>
         <p>Light is a propagating oscillation of the electromagnetic
         field. The general principles which govern electromagnetic
         waves are Maxwell’s equations. From these general relations, a
         vector wave equation can be derived.</p>
         <p><span id="eq:1" class="eqnos"><span class="math display">\[
         \nabla^2\vec{E}=\mu_0\epsilon_0
         \frac{\partial^2\vec{E}}{\partial
         t^2}\text{.}\]</span><span class="eqnos-number">(1)</span></span>
         </p>
         <p>One of the simplest solutions is that of a plane wave
         propagating in the <span class="math inline">\(\hat{z}\)</span>
         direction:</p>
         <p><span id="eq:2" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=E_x\hat{x}cos(kz-\omega
         t+\phi_x)+E_y\hat{y}cos(kz-\omega
         t+\phi_y)\text{.}\quad\quad\]</span><span class="eqnos-number">(2)</span></span>
         </p>
         <p>But as the measurements from the first week showed, our
         laser beams are commonly well approximated by a beam shape with
         a Gaussian intensity profile. Apparently, since these Gaussian
         profile beams exist, they must be solutions of the wave
         equation. The next section will discuss how we derive the
         Gaussian beam electric field, and give a few key results.</p>
         <h2 data-number="4.4" id="sec:wave-eqn"><span
         class="header-section-number">4.4</span> Paraxial wave
         equation</h2>
         <p>One important thing to note about the beam output from most
         lasers is that the width of the beam changes very slowly
         compared to the wavelength of light. Assume a complex solution,
         where the beam is propagating in the <span
         class="math inline">\(\hat{z}\)</span>-direction, with the
         electric field polarization in the <span
         class="math inline">\(\hat{x}\)</span>-direction:</p>
         <p><span id="eq:3" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t)=\hat{x}A(x,y,z)e^{kz-\omega
         t}\text{.}\]</span><span class="eqnos-number">(3)</span></span>
         </p>
         <p>The basic idea is that the spatial pattern of the beam,
         described by the function <span
         class="math inline">\(A(x,y,z)\)</span>, does not change much
         over a wavelength. In the case of the He-Ne laser output, the
         function <span class="math inline">\(A(x,y,z)\)</span> is a
         Gaussian profile that changes its width as a function of <span
         class="math inline">\(z\)</span>. If we substitute the trial
         solution in Equation <a href="#eq:3">3</a> into the wave
         equation in Equation <a href="#eq:1">1</a> we get</p>
         <p><span id="eq:4" class="eqnos"><span
         class="math display">\[\hat{x} \left[
         \left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial z} - k^2A
         \right]e^{i(kz-\omega
         t)}=\hat{x}\mu_0\epsilon_oA(-\omega^2)e^{i(kz-\omega
         t)}\text{.}\quad\quad\]</span><span class="eqnos-number">(4)</span></span>
         </p>
         <p>This can be simplified recognizing that <span
         class="math inline">\(k^2=\omega^2/c^2=\mu_0\epsilon_0\omega^2\)</span>,
         where the speed of light is related to the permeability and
         permittivity of free space by <span
         class="math inline">\(c=(\mu_0\epsilon_0)^{-1/2}\)</span>.
         Also, the <span class="math inline">\(\hat{x}e^{i(kz-\omega
         t)}\)</span> term is common to both sides and can be dropped,
         which results in</p>
         <p><span id="eq:5" class="eqnos"><span
         class="math display">\[\left(\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2} \right) +2ik\frac{\partial A}{\partial
         z}=0\text{.}\quad\quad\]</span><span class="eqnos-number">(5)</span></span>
         </p>
         <p>So far, we have made no approximation to the solution or the
         wave equation, but now we apply the assumption that <span
         class="math inline">\(\partial{A}(x,y,z)/\partial{z}\)</span>
         changes slowly over a wavelength <span
         class="math inline">\(\lambda = 2\pi /k\)</span>, so we neglect
         the term</p>
         <p><span id="eq:6" class="eqnos"><span
         class="math display">\[\left| \frac{\partial^2A}{\partial z^2}
         \right| \ll \left|2k\frac{\partial A}{\partial
         z}\right|\text{.}\]</span><span class="eqnos-number">(6)</span></span>
         </p>
         <p>Finally, we get the paraxial wave equation,</p>
         <p><span id="eq:7" class="eqnos"><span
         class="math display">\[\frac{\partial^2A}{\partial x^2}
         +\frac{\partial^2A}{\partial y^2} +\frac{\partial^2A}{\partial
         z^2}=0\text{.}\]</span><span class="eqnos-number">(7)</span></span>
         </p>
         <p>One set of solutions to the paraxial wave equation are
         Gauss-Hermite beams, which have an intensity profiles like
         those shown in Figure <a href="#fig:gauss-hermite">1</a>. These
         are the same solutions as for the quantum simple harmonic
         oscillator, a topic that could be further explored as a final
         project.</p>
         <p>The simplest of these solutions is the Gaussian beam, which
         has an electric field given by</p>
         <p><span id="eq:8" class="eqnos"><span
         class="math display">\[\vec{E}(x,y,z,t) =
         \vec{E}_0\frac{w_0}{w(z)}exp\left(-\frac{x^2+y^2}{w^2(z)}\right)exp\left(ik\frac{x^2+y^2}{2R(z)}\right)e^{-i\zeta(z)}e^{i(kz-\omega
         t)}\text{,}\quad\quad\]</span><span class="eqnos-number">(8)</span></span>
         </p>
         <p>where <span class="math inline">\(\vec{E_0}\)</span> is a
         time-independent vector (orthogonal to propagation direction
         <span class="math inline">\(\hat{z}\)</span>) whose magnitude
         denotes the amplitude of the laser’s electric field and the
         direction denotes the direction of polarization. The beam
         radius <span class="math inline">\(w(z)\)</span>is given by</p>
         <p><span id="eq:9" class="eqnos"><span
         class="math display">\[w(z)=w_0\sqrt{1+\left(\frac{\lambda
         z}{\pi
         w_0^2}\right)^2}\text{.}\]</span><span class="eqnos-number">(9)</span></span>
         </p>
         <p><span class="math inline">\(R(z)\)</span>,the radius of
         curvature of the wavefront, is given by</p>
         <p><span id="eq:10" class="eqnos"><span
         class="math display">\[R(z)=z\left(1+\left(\frac{\pi
         w_0^2}{\lambda
         z}\right)^2\right)\text{,}\]</span><span class="eqnos-number">(10)</span></span>
         </p>
         <p>and the Gouy phase is given by</p>
         <p><span id="eq:11" class="eqnos"><span
         class="math display">\[\zeta(z)=arctan\frac{\pi w_0^2}{\lambda
         z}\text{.}\]</span><span class="eqnos-number">(11)</span></span>
         </p>
         <p>The remarkable thing about all these equations is that only
         two parameters need to be specified to give the whole beam
         profile: the wavelength <span
         class="math inline">\(\lambda\)</span> and the beam waist <span
         class="math inline">\(w_0\)</span>, which is the narrowest
         point in the beam profile. There is a more general set of
         Hermite Gaussian modes which are shown in Figure <a
         href="#fig:gauss-hermite">1</a>. The laser cavity typically
         produces the (0,0) mode shown in the upper left corner, but an
         optical cavity can also be used to create these other modes – a
         topic that can be explored in the final projects.</p>
         <div id="fig:gauss-hermite" class="fignos">
         <figure>
         <img
         src="../resources/lab-guides/gaussian-laser-beams/gauss-hermite.png"
         style="width:20cm"
         alt="Figure 1: Intensity distributions for the lowest order Gauss-Hermite solutions to the paraxial wave equation. The axes are in units of the beam width, w." />
         <figcaption aria-hidden="true"><span>Figure 1:</span> Intensity
         distributions for the lowest order Gauss-Hermite solutions to
         the paraxial wave equation. The axes are in units of the beam
         width, <span class="math inline">\(w\)</span>.</figcaption>
         </figure>
         </div>
         <h2 data-number="4.5"
         id="trying-out-the-gaussian-beam-model"><span
         class="header-section-number">4.5</span> Trying out the
         Gaussian beam model</h2>
         <p>In the first week of the lab, we assumed the intensity
         profile of the Gaussian beam was given by <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>.
         The equation for the electric field of the Gaussian Beam in
         Equation <a href="#eq:8">8</a> looks substantially more
         complicated.</p>
         <ol type="1">
         <li>How are the expressions for electric field and intensity
         related?</li>
         <li>Is Equation <a href="#eq:8">8</a> consistent with the
         simple expression for intensity <span
         class="math inline">\(I(x,y)=I_{max}e^{-2(x^2+y^2)/w^2}\)</span>?</li>
         </ol>
         <p>The Gaussian beam equations given in Equations <a
         href="#eq:8">8</a> -<a href="#eq:11">11</a> assume the beam
         comes to its narrowest width (called the beam waist, <span
         class="math inline">\(w_0\)</span>) at <span
         class="math inline">\(z=0\)</span>.</p>
         <ol start="3" type="1">
         <li>How would you rewrite these four equations assuming the
         beam waist occurs at a different position <span
         class="math inline">\(z=z_w\)</span>?</li>
         <li>One way to check your answer is to make sure the equations
         simplify to Equations <a href="#eq:8">8</a> -<a
         href="#eq:11">11</a> in the special case of <span
         class="math inline">\(z_w=0\)</span>.</li>
         <li>Write a Python function to fit <a
         href="../resources/lab-guides/gaussian-laser-beams/Test_beam_width_data.csv">this
         data set</a>. Assume the wavelength is <span
         class="math inline">\(\lambda=632.8\ nm\)</span>.
         <ol type="1">
         <li>What is the functional form for your fit function?</li>
         <li>What are the different fit parameters and what do they
         mean?</li>
         <li>Is it a linear or nonlinear fit function? Why?</li>
         </ol></li>
         <li>You should get that a beam waist of <span
         class="math inline">\(w_0=(93.9\pm0.1)\times10^{-6}\ m\)</span>
         and occurs at a position <span
         class="math inline">\(z_w=0.3396\pm0.0003\ m\)</span>.</li>
         </ol>
         <h1 data-number="5" id="fourier-analysis-techniques"><span
         class="header-section-number">5</span> Fourier Analysis
         Techniques</h1>
         <p>In Week 2, you learned about the Nyquist frequency and how
         sample rate affects your ability to accurately capture signals.
         This week, we’ll analyze signals in the <strong>frequency
         domain</strong> using Fourier Transforms. This is a powerful
         technique used throughout physics and engineering.</p>
         <h2 data-number="5.1"
         id="introduction-to-fourier-transforms"><span
         class="header-section-number">5.1</span> Introduction to
         Fourier Transforms</h2>
         <p>The discrete Fourier Transform of a set of data <span
         class="math inline">\(\{y_0,y_1, ... , y_{N-1}\}\)</span> is
         given by</p>
         <p><span class="math display">\[Y_m=\displaystyle
         \sum_{n=0}^{N-1}y_n\cdot e^{-2\pi i \frac{m}{N}n}\]</span></p>
         <p>The basic idea is that a Fourier Transform decomposes the
         data into a set of different frequency components, so the
         amplitude of <span class="math inline">\(Y_m\)</span> tells you
         how much of your signal was formed by an oscillation at the
         <span class="math inline">\(m\)</span>-th frequency.</p>
         <h3 data-number="5.1.1" id="sec:basic-fourier"><span
         class="header-section-number">5.1.1</span> Basic Fourier
         Concepts</h3>
         <ol type="1">
         <li>How do the units of the Fourier Transform array <span
         class="math inline">\(Y_m\)</span> relate to the units of the
         data <span class="math inline">\(y_n\)</span>?</li>
         <li>Does the data <span class="math inline">\(y_n\)</span> have
         to be taken at equally spaced intervals?</li>
         <li>Is it possible for two different sets of data to have the
         same Fourier Transform?</li>
         <li>If a data set has <span class="math inline">\(N\)</span>
         elements, how long is the discrete Fourier Transform?</li>
         </ol>
         <h2 data-number="5.2"
         id="computing-the-power-spectrum-in-python"><span
         class="header-section-number">5.2</span> Computing the Power
         Spectrum in Python</h2>
         <p>NumPy provides efficient FFT (Fast Fourier Transform)
         functions for spectral analysis:</p>
         <div class="sourceCode" id="cb4"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_spectrum(data, sample_rate):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the one-sided power spectrum of a signal.</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">        data: 1D array of signal values</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">        sample_rate: Sample rate in Hz</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">        frequencies: Array of frequency values</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">        power: Power spectrum (magnitude squared)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(data)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute FFT</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    fft_result <span class="op">=</span> np.fft.fft(data)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get positive frequencies only (real signal has symmetric spectrum)</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)[:n_unique]</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.<span class="bu">abs</span>(frequencies)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Power spectrum (magnitude squared, normalized)</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> (np.<span class="bu">abs</span>(fft_result[:n_unique]) <span class="op">/</span> n) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    power[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">*=</span> <span class="dv">2</span>  <span class="co"># Double power for frequencies with both +/- components</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> frequencies, power</span></code></pre></div>
         <h3 data-number="5.2.1"
         id="frequency-resolution-and-maximum-frequency"><span
         class="header-section-number">5.2.1</span> Frequency Resolution
         and Maximum Frequency</h3>
         <p>The relationship between your acquisition parameters and the
         spectrum is:</p>
         <div class="sourceCode" id="cb5"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Frequency resolution and maximum frequency</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>freq_resolution <span class="op">=</span> sample_rate <span class="op">/</span> num_samples  <span class="co"># Hz per bin</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>max_frequency <span class="op">=</span> sample_rate <span class="op">/</span> <span class="dv">2</span>  <span class="co"># Nyquist frequency</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Frequency resolution: </span><span class="sc">{</span>freq_resolution<span class="sc">}</span><span class="ss"> Hz&quot;</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Maximum frequency: </span><span class="sc">{</span>max_frequency<span class="sc">}</span><span class="ss"> Hz&quot;</span>)</span></code></pre></div>
         <p><strong>Key relationships:</strong></p>
         <ul>
         <li><strong>Frequency resolution</strong> = Sample Rate /
         Number of Samples</li>
         <li><strong>Maximum frequency</strong> (Nyquist) = Sample Rate
         / 2</li>
         </ul>
         <p>If the data is sampled for 2 seconds at 100 Hz sample rate:
         - Number of samples = 200 - Frequency resolution = 100 Hz / 200
         = 0.5 Hz - Maximum frequency = 100 Hz / 2 = 50 Hz</p>
         <h2 data-number="5.3"
         id="building-a-real-time-spectral-analyzer"><span
         class="header-section-number">5.3</span> Building a Real-Time
         Spectral Analyzer</h2>
         <p>Create a script that acquires data and displays both
         time-domain and frequency-domain views simultaneously:</p>
         <div class="sourceCode" id="cb6"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nidaqmx</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nidaqmx.constants <span class="im">import</span> AcquisitionType</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, clear_output</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>SAMPLE_RATE <span class="op">=</span> <span class="dv">10000</span>  <span class="co"># Hz</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>NUM_SAMPLES <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>DAQ_CHANNEL <span class="op">=</span> <span class="st">&quot;Dev1/ai0&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_spectrum(data, sample_rate):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Compute one-sided power spectrum.&quot;&quot;&quot;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(data)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    fft_result <span class="op">=</span> np.fft.fft(data)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    frequencies <span class="op">=</span> np.<span class="bu">abs</span>(np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)[:n_unique])</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> (np.<span class="bu">abs</span>(fft_result[:n_unique]) <span class="op">/</span> n) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    power[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> frequencies, power</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up plots</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Time domain plot</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>line1, <span class="op">=</span> ax1.plot([], [], <span class="st">&#39;b-&#39;</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">&#39;Time (ms)&#39;</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">&#39;Voltage (V)&#39;</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">&#39;Time Domain&#39;</span>)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Frequency domain plot</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>line2, <span class="op">=</span> ax2.plot([], [], <span class="st">&#39;r-&#39;</span>)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">&#39;Power&#39;</span>)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">&#39;Frequency Domain (Power Spectrum)&#39;</span>)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>ax2.set_xlim(<span class="dv">0</span>, SAMPLE_RATE <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>last_data <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> nidaqmx.Task() <span class="im">as</span> task:</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    task.ai_channels.add_ai_voltage_chan(DAQ_CHANNEL)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    task.timing.cfg_samp_clk_timing(</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>        rate<span class="op">=</span>SAMPLE_RATE,</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        sample_mode<span class="op">=</span>AcquisitionType.CONTINUOUS</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    task.start()</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Acquiring data... Press Ctrl+C (or Interrupt Kernel) to stop&quot;</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Drain buffer to prevent overflow</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>            samples_available <span class="op">=</span> task.in_stream.avail_samp_per_chan</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> samples_available <span class="op">&gt;=</span> NUM_SAMPLES:</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> task.read(number_of_samples_per_channel<span class="op">=</span>samples_available)</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use most recent samples</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data[<span class="op">-</span>NUM_SAMPLES:]</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>                last_data <span class="op">=</span> np.array(data)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update time domain plot</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>                time_ms <span class="op">=</span> np.arange(<span class="bu">len</span>(data)) <span class="op">/</span> SAMPLE_RATE <span class="op">*</span> <span class="dv">1000</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>                line1.set_data(time_ms, data)</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>                ax1.set_xlim(<span class="dv">0</span>, time_ms[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>                ax1.set_ylim(np.<span class="bu">min</span>(data) <span class="op">-</span> <span class="fl">0.1</span>, np.<span class="bu">max</span>(data) <span class="op">+</span> <span class="fl">0.1</span>)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update frequency domain plot</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>                frequencies, power <span class="op">=</span> compute_spectrum(np.array(data), SAMPLE_RATE)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>                line2.set_data(frequencies, power)</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>                ax2.set_ylim(<span class="dv">0</span>, np.<span class="bu">max</span>(power) <span class="op">*</span> <span class="fl">1.1</span> <span class="op">+</span> <span class="fl">0.001</span>)</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>                clear_output(wait<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>                display(fig)</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:</span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Stopped by user&quot;</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a><span class="co"># Save last dataset</span></span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> last_data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>    np.savetxt(<span class="st">&#39;last_acquisition.csv&#39;</span>,</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>               np.column_stack([np.arange(<span class="bu">len</span>(last_data))<span class="op">/</span>SAMPLE_RATE, last_data]),</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>               delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, header<span class="op">=</span><span class="st">&#39;Time (s), Voltage (V)&#39;</span>, comments<span class="op">=</span><span class="st">&#39;&#39;</span>)</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Last dataset saved to &#39;last_acquisition.csv&#39;&quot;</span>)</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>plt.close(fig)</span></code></pre></div>
         <h2 data-number="5.4" id="exercises-spectral-analysis"><span
         class="header-section-number">5.4</span> Exercises: Spectral
         Analysis</h2>
         <h3 data-number="5.4.1"
         id="understanding-frequency-resolution"><span
         class="header-section-number">5.4.1</span> Understanding
         Frequency Resolution</h3>
         <ol type="1">
         <li><p>Use a waveform generator to output a waveform of your
         choice at a frequency in the tens of Hz to kHz range and view
         the output on the oscilloscope and in your Python
         script.</p></li>
         <li><p>Look at the spectral analysis. How do the
         <strong>frequency resolution</strong> (frequency step size
         between data in the spectrum) and <strong>maximum
         frequency</strong> relate to the <strong>sample rate</strong>
         and <strong>number of samples</strong>? Verify the algebraic
         relationship experimentally.</p></li>
         <li><p>If the data is sampled for 2 seconds at 100 Hz sample
         rate, what frequency does the <span
         class="math inline">\(m\)</span>-th component of the Fourier
         Transform correspond to?</p></li>
         <li><p>How many points are shown in the spectral analysis plot?
         How does this compare to the number of points you expected in
         the Fourier transform (see Section <a
         href="#sec:basic-fourier">5.1.1</a>.4)?</p>
         <p><strong>Note</strong>: The data acquired from the DAQ is
         always a sequence of real numbers <span
         class="math inline">\(\{y_n\}\)</span>. Under the condition
         that the signal is only real numbers, it can be proved that
         <span class="math inline">\(Y_m=Y_{N-M}^*\)</span> so <span
         class="math inline">\(|Y_M|=|Y_{N-m}|\)</span>, meaning the
         spectrum is symmetric about the <span
         class="math inline">\(N/2\)</span>-th data point, which
         corresponds to the Nyquist frequency. For this reason, we
         typically only plot the first half of the Fourier spectrum up
         to the Nyquist frequency.</p></li>
         </ol>
         <h3 data-number="5.4.2"
         id="analyzing-different-waveforms"><span
         class="header-section-number">5.4.2</span> Analyzing Different
         Waveforms</h3>
         <ol type="1">
         <li><p>How do you expect the spectrum of a <strong>sine
         wave</strong> to look? How should it change as you vary the
         amplitude and frequency on the waveform generator? Try
         it.</p></li>
         <li><p>How do you expect the spectrum of a <strong>square
         wave</strong> to look? How should it change as you vary the
         amplitude and frequency on the waveform generator? Try it.</p>
         <p>(Hint: you can look up or calculate the Fourier Series of a
         square wave to see if the observed amplitudes agree with the
         mathematical prediction.)</p></li>
         <li><p>Generate a signal with <strong>two frequencies</strong>
         (if your function generator supports this, or use the sum of
         two signals). Can you identify both frequencies in the
         spectrum?</p></li>
         </ol>
         <h3 data-number="5.4.3"
         id="connecting-fft-to-your-gaussian-beams-experiment"><span
         class="header-section-number">5.4.3</span> Connecting FFT to
         Your Gaussian Beams Experiment</h3>
         <p>The spectral analysis techniques you’ve learned have direct
         applications to your beam profiling work. In this section,
         you’ll analyze the photodetector signal to understand noise
         sources that could affect your Week 4 measurements.</p>
         <ol type="1">
         <li><p><strong>Photodetector noise spectrum.</strong> Connect
         your photodetector to the DAQ (as in Week 2) with the beam
         blocked.</p>
         <ol type="1">
         <li>Acquire 1-2 seconds of data at 10 kHz sample rate.</li>
         <li>Compute and plot the power spectrum.</li>
         <li>Are there any peaks at specific frequencies? If so, what
         are likely physical sources? (Common culprits: 60 Hz power
         line, 120 Hz rectified power, computer switching frequencies,
         room lighting)</li>
         <li>How does the noise spectrum change when you change the
         photodetector gain setting?</li>
         </ol></li>
         <li><p><strong>Signal spectrum with laser.</strong> Now unblock
         the beam so light hits the photodetector.</p>
         <ol type="1">
         <li>Acquire data and compute the power spectrum.</li>
         <li>Compare to the dark noise spectrum. What changed?</li>
         <li>If you see new peaks, what might cause periodic variations
         in laser intensity?</li>
         </ol></li>
         <li><p><strong>Implications for beam profiling.</strong>
         Consider your Week 4 automated measurements.</p>
         <ol type="1">
         <li>Your beam profiler waits 500 ms between steps and takes a
         single voltage reading. Based on your noise spectrum, what
         frequencies could affect your measurement?</li>
         <li>If you wanted to reduce the effect of 60 Hz noise, how long
         should you average each measurement? (Hint: averaging over an
         integer number of periods cancels periodic noise)</li>
         <li>Would it be better to average many fast samples or take one
         slow measurement? Justify your answer using your spectral
         analysis.</li>
         </ol></li>
         <li><p><strong>Quantitative prediction for Week 4.</strong>
         Based on your noise spectrum analysis:</p>
         <ol type="1">
         <li>Calculate the RMS noise you expect in a 100-sample average
         at 10 kHz sample rate. (Hint: if your single-sample RMS noise
         is <span class="math inline">\(\sigma\)</span>, the RMS of an
         N-sample average is <span
         class="math inline">\(\sigma/\sqrt{N}\)</span>, assuming white
         noise.)</li>
         <li>Record this prediction in your notebook: “Predicted RMS
         noise with 100-sample averaging: ______ mV”</li>
         <li>You will test this prediction in Week 4 by examining the
         scatter in your beam profile data.</li>
         </ol></li>
         </ol>
         <h3 data-number="5.4.4" id="analyzing-saved-data"><span
         class="header-section-number">5.4.4</span> Analyzing Saved
         Data</h3>
         <p>Sometimes you may want to analyze data after it is saved
         rather than in real-time:</p>
         <div class="sourceCode" id="cb7"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load saved data</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.loadtxt(<span class="st">&#39;saved_waveform.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>, skiprows<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> data[:, <span class="dv">0</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>signal <span class="op">=</span> data[:, <span class="dv">1</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine sample rate from time data</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (time[<span class="dv">1</span>] <span class="op">-</span> time[<span class="dv">0</span>])</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute FFT</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(signal)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>fft_result <span class="op">=</span> np.fft.fft(signal)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create frequency axis</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Get positive frequencies only</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>positive_mask <span class="op">=</span> frequencies <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>freq_positive <span class="op">=</span> frequencies[positive_mask]</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.<span class="bu">abs</span>(fft_result[positive_mask]) <span class="op">/</span> n</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot spectrum</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>plt.plot(freq_positive, magnitude)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Magnitude&#39;</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">&#39;Fourier Transform of Saved Data&#39;</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
         <h3 data-number="5.4.5" id="exercises-with-saved-data"><span
         class="header-section-number">5.4.5</span> Exercises with Saved
         Data</h3>
         <ol type="1">
         <li><p>Import any saved data set of a periodic function saved
         from the DAQ or the oscilloscope.</p></li>
         <li><p>Use NumPy’s <code>fft</code> function to compute the
         discrete Fourier Transform of the signal.</p>
         <ol type="1">
         <li>Do you expect the FFT output to be real-valued or
         complex-valued?</li>
         </ol></li>
         <li><p>Plot the output of the FFT function. Since the output is
         complex-valued, plot <code>np.abs()</code> or
         <code>np.abs()**2</code>.</p>
         <ol type="1">
         <li>What is the x-axis range and step-size in the plot?</li>
         <li>What frequency range and step size should be displayed on
         the x-axis?</li>
         </ol></li>
         <li><p>Make sure to add the frequency column to create a proper
         plot of spectrum vs. frequency:</p>
         <div class="sourceCode" id="cb8"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Complete example</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(signal)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>sample_rate <span class="op">=</span> <span class="dv">10000</span>  <span class="co"># Adjust to your actual sample rate</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute FFT and frequencies</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>fft_result <span class="op">=</span> np.fft.fft(signal)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>frequencies <span class="op">=</span> np.fft.fftfreq(n, d<span class="op">=</span><span class="dv">1</span><span class="op">/</span>sample_rate)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># One-sided spectrum (positive frequencies)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>n_half <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>freq_pos <span class="op">=</span> frequencies[:n_half]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.<span class="bu">abs</span>(fft_result[:n_half]) <span class="op">*</span> <span class="dv">2</span> <span class="op">/</span> n  <span class="co"># Normalize and account for one-sided</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>magnitude[<span class="dv">0</span>] <span class="op">/=</span> <span class="dv">2</span>  <span class="co"># DC component doesn&#39;t double</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>plt.plot(freq_pos, magnitude)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;Frequency (Hz)&#39;</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;Magnitude&#39;</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, sample_rate<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div></li>
         <li><p>Does the spectral analysis show the same spectrum at the
         same frequencies that you expect from the waveform generator
         settings?</p></li>
         <li><p>NumPy’s FFT uses specific conventions. You can check the
         documentation with:</p>
         <div class="sourceCode" id="cb9"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">help</span>(np.fft.fft)</span></code></pre></div>
         <p>The convention used is: <span class="math inline">\(Y_k =
         \sum_{n=0}^{N-1} y_n e^{-2\pi i k n / N}\)</span></p></li>
         </ol>
         <h1 data-number="6" id="setting-up-the-motor-controller"><span
         class="header-section-number">6</span> Setting Up the Motor
         Controller</h1>
         <p>In Week 4, you will use Python to automate beam profile
         measurements by controlling a motorized translation stage. This
         section guides you through setting up and verifying the motor
         controller hardware. Getting this working now will save
         significant time later.</p>
         <h2 data-number="6.1" id="hardware-overview"><span
         class="header-section-number">6.1</span> Hardware Overview</h2>
         <p>The Thorlabs KST101 is a stepper motor controller that can
         precisely position a translation stage. You will use it to move
         a razor blade across the laser beam while the DAQ records the
         photodetector signal.</p>
         <p>The physical connections are:</p>
         <ol type="1">
         <li><strong>Motor Controller (KST101)</strong>:
         <ul>
         <li>Connect the USB cable from the KST101 cube to your
         computer</li>
         <li>Connect the power supply to the KST101</li>
         <li>The motor should already be mechanically connected to the
         translation stage with the razor</li>
         </ul></li>
         <li><strong>Optical Setup</strong> (for testing):
         <ul>
         <li>Position the photodetector after the knife-edge in the beam
         path</li>
         <li>Ensure the beam passes cleanly through when the razor is
         fully retracted</li>
         </ul></li>
         </ol>
         <h2 data-number="6.2" id="software-prerequisites"><span
         class="header-section-number">6.2</span> Software
         Prerequisites</h2>
         <h3 data-number="6.2.1" id="thorlabs-kinesis-sdk"><span
         class="header-section-number">6.2.1</span> 1. Thorlabs Kinesis
         SDK</h3>
         <p>Download and install from the Thorlabs website: <a
         href="https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control">https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=Motion_Control</a></p>
         <p><strong>Important</strong>: Choose the correct version: - If
         you have 32-bit Python: Install the 32-bit Kinesis software -
         If you have 64-bit Python: Install the 64-bit Kinesis
         software</p>
         <p>To check your Python version, run:</p>
         <div class="sourceCode" id="cb10"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys.maxsize <span class="op">&gt;</span> <span class="dv">2</span><span class="op">**</span><span class="dv">32</span>)  <span class="co"># True = 64-bit, False = 32-bit</span></span></code></pre></div>
         <h3 data-number="6.2.2" id="python-packages"><span
         class="header-section-number">6.2.2</span> 2. Python
         Packages</h3>
         <p>Install the required packages:</p>
         <div class="sourceCode" id="cb11"><pre
         class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pythonnet</span></code></pre></div>
         <p>(You should already have <code>nidaqmx</code>,
         <code>numpy</code>, and <code>matplotlib</code> from Week
         2.)</p>
         <h2 data-number="6.3" id="verifying-the-motor-connection"><span
         class="header-section-number">6.3</span> Verifying the Motor
         Connection</h2>
         <h3 data-number="6.3.1"
         id="test-that-windows-recognizes-the-device"><span
         class="header-section-number">6.3.1</span> Test that Windows
         Recognizes the Device</h3>
         <ol type="1">
         <li>Connect the USB to the KST101, then turn on power</li>
         <li>Open <strong>Device Manager</strong> and look for the
         device under “USB devices” or “Thorlabs APT Device”</li>
         <li>Note the serial number (displayed on the KST101
         screen)</li>
         </ol>
         <p>If you get a driver error, you may need to disable Memory
         Integrity in Windows Security (ask technical staff for help if
         this occurs on a lab computer).</p>
         <h3 data-number="6.3.2"
         id="test-basic-motor-communication"><span
         class="header-section-number">6.3.2</span> Test Basic Motor
         Communication</h3>
         <p>Run this test script to verify Python can communicate with
         the motor:</p>
         <div class="sourceCode" id="cb12"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Add Kinesis .NET assemblies</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Build device list</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Get list of connected devices</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>device_list <span class="op">=</span> DeviceManagerCLI.GetDeviceList()</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Found </span><span class="sc">{</span><span class="bu">len</span>(device_list)<span class="sc">}</span><span class="ss"> device(s):&quot;</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> serial <span class="kw">in</span> device_list:</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Serial: </span><span class="sc">{</span>serial<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
         <p>If this shows your device serial number, the connection is
         working.</p>
         <h3 data-number="6.3.3" id="test-motor-movement"><span
         class="header-section-number">6.3.3</span> Test Motor
         Movement</h3>
         <p><strong>Caution</strong>: Make sure the translation stage
         has room to move before running this test. Check that nothing
         is blocking the stage mechanically.</p>
         <div class="sourceCode" id="cb13"><pre
         class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> clr</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> decimal <span class="im">import</span> Decimal</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="vs">r&quot;C:\Program Files\Thorlabs\Kinesis&quot;</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.DeviceManagerCLI&quot;</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.KCube.StepperMotorCLI&quot;</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>clr.AddReference(<span class="st">&quot;Thorlabs.MotionControl.GenericMotorCLI&quot;</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.DeviceManagerCLI <span class="im">import</span> DeviceManagerCLI</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Thorlabs.MotionControl.KCube.StepperMotorCLI <span class="im">import</span> KCubeStepper</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace with your serial number</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>SERIAL_NUMBER <span class="op">=</span> <span class="st">&quot;26004813&quot;</span>  <span class="co"># Check the display on your KST101</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>DeviceManagerCLI.BuildDeviceList()</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> KCubeStepper.CreateKCubeStepper(SERIAL_NUMBER)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    device.Connect(SERIAL_NUMBER)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Connected!&quot;</span>)</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Wait for settings to initialize</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    device.WaitForSettingsInitialized(<span class="dv">5000</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    device.StartPolling(<span class="dv">50</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    device.EnableDevice()</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    time.sleep(<span class="fl">0.5</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Load motor configuration</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    config <span class="op">=</span> device.LoadMotorConfiguration(SERIAL_NUMBER)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get current position</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> device.Position</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Current position: </span><span class="sc">{</span>pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Move relative (small test movement)</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Moving 0.5 mm...&quot;</span>)</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    device.SetMoveRelativeDistance(Decimal(<span class="fl">0.5</span>))</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    device.MoveRelative(<span class="dv">60000</span>)  <span class="co"># 60 second timeout</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    new_pos <span class="op">=</span> device.Position</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;New position: </span><span class="sc">{</span>new_pos<span class="sc">}</span><span class="ss"> mm&quot;</span>)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a><span class="cf">finally</span>:</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    device.StopPolling()</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    device.Disconnect()</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Disconnected&quot;</span>)</span></code></pre></div>
         <h2 data-number="6.4"
         id="motor-controller-troubleshooting"><span
         class="header-section-number">6.4</span> Motor Controller
         Troubleshooting</h2>
         <p><strong>“Device not found” Error:</strong> - Check USB
         connection - Verify serial number matches the display on the
         KST101 - Make sure no other software (APT User, Kinesis) is
         using the motor</p>
         <p><strong>Motor Doesn’t Move:</strong> - Ensure power is
         connected to the KST101 - Check that the stage isn’t at a
         travel limit - Verify the stage type is configured correctly in
         Kinesis (ZST225B)</p>
         <p><strong>Python Import Errors:</strong> - Ensure Kinesis SDK
         is installed and matches Python architecture (32/64-bit) -
         Check that the path to Kinesis DLLs is correct</p>
         <h2 data-number="6.5" id="exercise-verify-your-setup"><span
         class="header-section-number">6.5</span> Exercise: Verify Your
         Setup</h2>
         <p>Before leaving lab today, verify that:</p>
         <ol type="1">
         <li><input type="checkbox" disabled="" />
         The DAQ can read voltages from the photodetector</li>
         <li><input type="checkbox" disabled="" />
         Python can connect to the motor controller</li>
         <li><input type="checkbox" disabled="" />
         The motor moves when commanded</li>
         <li><input type="checkbox" disabled="" />
         You have noted your motor’s serial number: ____________</li>
         </ol>
         <p>This setup will be essential for the automated measurements
         in Week 4.</p>
         <h2 data-number="6.6" id="troubleshooting-reflection"><span
         class="header-section-number">6.6</span> Troubleshooting
         Reflection</h2>
         <p>Developing systematic troubleshooting skills is essential
         for experimental physics. Answer this question in your
         notebook:</p>
         <p><strong>If the motor doesn’t respond to Python commands,
         what troubleshooting steps would you take?</strong></p>
         <p>List at least three things you would check, <em>in order of
         likelihood</em>, and explain your reasoning. Consider: - What
         are the most common failure modes? - What’s the quickest way to
         isolate hardware vs. software issues? - How would you determine
         if the problem is with Python, the USB connection, or the motor
         itself?</p>
         <p>This systematic approach to troubleshooting will serve you
         well in Week 4 and beyond.</p>
         <h1 data-number="7" id="revisit-measuring-the-beam-width"><span
         class="header-section-number">7</span> Revisit Measuring the
         Beam Width</h1>
         <p>Now that you have the motor controller working, you’re ready
         to prepare for Week 4’s automated measurements. Review (and
         complete if necessary) <a
         href="/PHYS-4430/lab-guides/gaussian-beams-1#measuring-the-beam-width">section
         7</a> from Week 1.</p>
         <p>Make sure you can:</p>
         <ol type="1">
         <li>Take a complete beam profile measurement manually</li>
         <li>Fit the data using the error function model</li>
         <li>Extract the beam width <span
         class="math inline">\(w\)</span> with uncertainty</li>
         <li>Create a plot showing the data and fit</li>
         </ol>
         <p>This will serve as your baseline for comparison with the
         automated measurements next week. If time permits, try using
         the motor controller to take a few data points—this will give
         you confidence that your setup is ready for Week 4.</p>
         <h1 data-number="8" id="deliverables-and-assessment"><span
         class="header-section-number">8</span> Deliverables and
         Assessment</h1>
         <p>Your lab notebook should include the following for this
         week:</p>
         <h2 data-number="8.1" id="prelab-complete-before-lab"><span
         class="header-section-number">8.1</span> Prelab (complete
         before lab)</h2>
         <ol type="1">
         <li><strong>Error propagation exercise</strong>: calculation of
         <span class="math inline">\(w(z)\)</span> uncertainty using the
         <code>uncertainties</code> package</li>
         <li><strong>Paraxial wave equation derivation</strong>: show
         the key steps from Maxwell’s equations to Equation 7</li>
         <li><strong>Gaussian beam model questions</strong>: answers to
         questions 1-4 in “Trying out the Gaussian beam model”</li>
         <li><strong>Beam waist fitting</strong>: fit results for the
         test data set with <span class="math inline">\(w_0\)</span> and
         <span class="math inline">\(z_w\)</span> values</li>
         </ol>
         <h2 data-number="8.2" id="in-lab-documentation"><span
         class="header-section-number">8.2</span> In-Lab
         Documentation</h2>
         <ol type="1">
         <li><strong>FFT exercises</strong>:
         <ul>
         <li>Plots comparing time-domain and frequency-domain
         representations</li>
         <li>Answers to frequency resolution questions</li>
         <li>Analysis of sine wave, square wave, and multi-frequency
         signals</li>
         <li><strong>Photodetector noise spectrum</strong> (new
         section): dark noise and signal spectra with analysis of
         implications for beam profiling</li>
         </ul></li>
         <li><strong>Motor controller verification</strong>:
         <ul>
         <li>Completed setup checklist (DAQ, motor connection, movement
         test)</li>
         <li>Motor serial number recorded</li>
         </ul></li>
         <li><strong>Beam width measurement</strong> (from Week 1 or
         new):
         <ul>
         <li>Data table: position vs. voltage</li>
         <li>Fit plot with extracted beam width and uncertainty</li>
         </ul></li>
         </ol>
         <h2 data-number="8.3" id="code-deliverables"><span
         class="header-section-number">8.3</span> Code Deliverables</h2>
         <ol type="1">
         <li>Working spectral analysis script</li>
         <li>Motor communication test script</li>
         </ol>
         <h2 data-number="8.4" id="reflection-questions"><span
         class="header-section-number">8.4</span> Reflection
         Questions</h2>
         <ol type="1">
         <li><p>Your FFT shows an unexpected peak at 120 Hz that wasn’t
         present in your function generator signal. List three possible
         physical sources for this frequency and describe how you would
         determine which is responsible.</p></li>
         <li><p>You measure a beam width of <span
         class="math inline">\(w = 0.52 \pm 0.03\)</span> mm at position
         <span class="math inline">\(z = 1.5\)</span> m. Using the
         Gaussian beam equations, predict <span
         class="math inline">\(w\)</span> at <span
         class="math inline">\(z = 2.0\)</span> m, including the
         propagated uncertainty. Show your calculation.</p></li>
         </ol>
               </div>
            <!-- Mathjax -->
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script>

      </script>
   </body>
</html>
